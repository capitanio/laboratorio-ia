<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Algoritmi – Laboratorio di Intelligenza Artificiale</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./3 machine learning.html" rel="next">
<link href="./1 elementi di Python.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./2 algoritmi.html"><span class="chapter-title">Algoritmi</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Laboratorio di Intelligenza Artificiale</a> 
        <div class="sidebar-tools-main tools-wide">
    <div class="dropdown">
      <a href="" title="Download" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Download"><i class="bi bi-download"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./libro.pdf">
              <i class="bi bi-file-pdf pe-1"></i>
            Download PDF
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="./libro.epub">
              <i class="bi bi-journal pe-1"></i>
            Download ePub
            </a>
          </li>
      </ul>
    </div>
    <div class="dropdown">
      <a href="" title="Share" id="quarto-navigation-tool-dropdown-1" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label="Share"><i class="bi bi-share"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-1">
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
              <i class="bi bi-twitter pe-1"></i>
            Twitter
            </a>
          </li>
          <li>
            <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
              <i class="bi bi-facebook pe-1"></i>
            Facebook
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefazione</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./0 introduzione.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Introduzione</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1 elementi di Python.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Elementi di Python</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2 algoritmi.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">Algoritmi</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3 machine learning.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">Machine learning</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#inferenza-logica" id="toc-inferenza-logica" class="nav-link active" data-scroll-target="#inferenza-logica">Inferenza Logica</a>
  <ul class="collapse">
  <li><a href="#proposizioni-logiche" id="toc-proposizioni-logiche" class="nav-link" data-scroll-target="#proposizioni-logiche">Proposizioni Logiche</a></li>
  <li><a href="#calcolo-delle-proposizioni-logiche" id="toc-calcolo-delle-proposizioni-logiche" class="nav-link" data-scroll-target="#calcolo-delle-proposizioni-logiche">Calcolo delle Proposizioni Logiche</a></li>
  <li><a href="#basi-della-conoscenza" id="toc-basi-della-conoscenza" class="nav-link" data-scroll-target="#basi-della-conoscenza">Basi della Conoscenza</a></li>
  <li><a href="#sistemi-basati-sulla-conoscenza" id="toc-sistemi-basati-sulla-conoscenza" class="nav-link" data-scroll-target="#sistemi-basati-sulla-conoscenza">Sistemi basati sulla conoscenza</a></li>
  <li><a href="#semplice-sistema-esperto-in-ambito-penale" id="toc-semplice-sistema-esperto-in-ambito-penale" class="nav-link" data-scroll-target="#semplice-sistema-esperto-in-ambito-penale">Semplice Sistema Esperto in ambito penale</a></li>
  </ul></li>
  <li><a href="#inferenza-probabilistica" id="toc-inferenza-probabilistica" class="nav-link" data-scroll-target="#inferenza-probabilistica">Inferenza Probabilistica</a>
  <ul class="collapse">
  <li><a href="#inferenza-probabilistica-e-la-teoria-delle-probabilità" id="toc-inferenza-probabilistica-e-la-teoria-delle-probabilità" class="nav-link" data-scroll-target="#inferenza-probabilistica-e-la-teoria-delle-probabilità">Inferenza probabilistica e La teoria delle probabilità</a></li>
  <li><a href="#cacolo-della-probabilità-incondizionata-o-a-priori" id="toc-cacolo-della-probabilità-incondizionata-o-a-priori" class="nav-link" data-scroll-target="#cacolo-della-probabilità-incondizionata-o-a-priori">Cacolo della probabilità incondizionata o a priori</a></li>
  <li><a href="#variabili-aleatorie" id="toc-variabili-aleatorie" class="nav-link" data-scroll-target="#variabili-aleatorie">Variabili aleatorie</a></li>
  <li><a href="#distribuzioni-di-probabilità" id="toc-distribuzioni-di-probabilità" class="nav-link" data-scroll-target="#distribuzioni-di-probabilità">Distribuzioni di probabilità</a></li>
  <li><a href="#probabilità-congiunta" id="toc-probabilità-congiunta" class="nav-link" data-scroll-target="#probabilità-congiunta">Probabilità congiunta</a></li>
  <li><a href="#indipendenza-delle-variabili-aleatorie" id="toc-indipendenza-delle-variabili-aleatorie" class="nav-link" data-scroll-target="#indipendenza-delle-variabili-aleatorie">Indipendenza delle variabili aleatorie</a></li>
  <li><a href="#negazione" id="toc-negazione" class="nav-link" data-scroll-target="#negazione">Negazione</a></li>
  <li><a href="#inclusione" id="toc-inclusione" class="nav-link" data-scroll-target="#inclusione">Inclusione</a></li>
  <li><a href="#marginalizzazione" id="toc-marginalizzazione" class="nav-link" data-scroll-target="#marginalizzazione">Marginalizzazione</a></li>
  <li><a href="#probabilità-condizionata" id="toc-probabilità-condizionata" class="nav-link" data-scroll-target="#probabilità-condizionata">probabilità condizionata</a></li>
  <li><a href="#condizionamento" id="toc-condizionamento" class="nav-link" data-scroll-target="#condizionamento">Condizionamento</a></li>
  </ul></li>
  <li><a href="#inferenza-bayesiana" id="toc-inferenza-bayesiana" class="nav-link" data-scroll-target="#inferenza-bayesiana">Inferenza Bayesiana</a>
  <ul class="collapse">
  <li><a href="#il-teorema-di-bayes" id="toc-il-teorema-di-bayes" class="nav-link" data-scroll-target="#il-teorema-di-bayes">Il Teorema di Bayes</a></li>
  <li><a href="#applicazioni-pratiche" id="toc-applicazioni-pratiche" class="nav-link" data-scroll-target="#applicazioni-pratiche">Applicazioni Pratiche</a></li>
  <li><a href="#reti-di-bayes" id="toc-reti-di-bayes" class="nav-link" data-scroll-target="#reti-di-bayes">reti di Bayes</a></li>
  </ul></li>
  <li><a href="#algoritmi-di-ricerca" id="toc-algoritmi-di-ricerca" class="nav-link" data-scroll-target="#algoritmi-di-ricerca">Algoritmi di Ricerca</a>
  <ul class="collapse">
  <li><a href="#glossario-della-ricerca" id="toc-glossario-della-ricerca" class="nav-link" data-scroll-target="#glossario-della-ricerca">Glossario della ricerca</a></li>
  <li><a href="#problemi-di-ricerca" id="toc-problemi-di-ricerca" class="nav-link" data-scroll-target="#problemi-di-ricerca">Problemi di ricerca</a></li>
  <li><a href="#algoritmo-generale-di-ricerca" id="toc-algoritmo-generale-di-ricerca" class="nav-link" data-scroll-target="#algoritmo-generale-di-ricerca">Algoritmo “generale” di ricerca</a></li>
  <li><a href="#strategie-di-ricerca-non-informate" id="toc-strategie-di-ricerca-non-informate" class="nav-link" data-scroll-target="#strategie-di-ricerca-non-informate">Strategie di ricerca non informate</a></li>
  <li><a href="#algoritmi-di-ricerca-informati" id="toc-algoritmi-di-ricerca-informati" class="nav-link" data-scroll-target="#algoritmi-di-ricerca-informati">Algoritmi di ricerca informati</a></li>
  </ul></li>
  <li><a href="#algoritmi-equitativi" id="toc-algoritmi-equitativi" class="nav-link" data-scroll-target="#algoritmi-equitativi">Algoritmi Equitativi</a>
  <ul class="collapse">
  <li><a href="#agenti-partecipanti" id="toc-agenti-partecipanti" class="nav-link" data-scroll-target="#agenti-partecipanti">agenti partecipanti</a></li>
  <li><a href="#beni" id="toc-beni" class="nav-link" data-scroll-target="#beni">beni</a></li>
  <li><a href="#regole-e-assunzioni" id="toc-regole-e-assunzioni" class="nav-link" data-scroll-target="#regole-e-assunzioni">Regole e assunzioni</a></li>
  <li><a href="#matematica-elementare-per-algoritmi-di-ripartizione-equa" id="toc-matematica-elementare-per-algoritmi-di-ripartizione-equa" class="nav-link" data-scroll-target="#matematica-elementare-per-algoritmi-di-ripartizione-equa">Matematica elementare per algoritmi di ripartizione equa</a></li>
  <li><a href="#algoritmi-di-ripartizione-equitativa" id="toc-algoritmi-di-ripartizione-equitativa" class="nav-link" data-scroll-target="#algoritmi-di-ripartizione-equitativa">Algoritmi di Ripartizione Equitativa</a></li>
  <li><a href="#gli-algoritmi-di-divisione-equa-in-letteratura" id="toc-gli-algoritmi-di-divisione-equa-in-letteratura" class="nav-link" data-scroll-target="#gli-algoritmi-di-divisione-equa-in-letteratura">Gli algoritmi di divisione equa in letteratura</a></li>
  </ul></li>
  <li><a href="#algoritmi-predittivi" id="toc-algoritmi-predittivi" class="nav-link" data-scroll-target="#algoritmi-predittivi">Algoritmi Predittivi</a>
  <ul class="collapse">
  <li><a href="#definizione-del-problema" id="toc-definizione-del-problema" class="nav-link" data-scroll-target="#definizione-del-problema">Definizione del Problema</a></li>
  <li><a href="#raccolta-dei-dati" id="toc-raccolta-dei-dati" class="nav-link" data-scroll-target="#raccolta-dei-dati">Raccolta dei Dati</a></li>
  <li><a href="#pre-elaborazione-dei-dati" id="toc-pre-elaborazione-dei-dati" class="nav-link" data-scroll-target="#pre-elaborazione-dei-dati">Pre-elaborazione dei Dati</a></li>
  <li><a href="#divisione-dei-dati" id="toc-divisione-dei-dati" class="nav-link" data-scroll-target="#divisione-dei-dati">Divisione dei Dati</a></li>
  <li><a href="#scelta-dell-algoritmo" id="toc-scelta-dell-algoritmo" class="nav-link" data-scroll-target="#scelta-dell-algoritmo">Scelta dell’ algoritmo</a></li>
  <li><a href="#addestramento-del-modello" id="toc-addestramento-del-modello" class="nav-link" data-scroll-target="#addestramento-del-modello">Addestramento del modello</a></li>
  <li><a href="#valutazione-del-modello" id="toc-valutazione-del-modello" class="nav-link" data-scroll-target="#valutazione-del-modello">Valutazione del modello</a></li>
  <li><a href="#ottimizzazione-degli-iperparametri" id="toc-ottimizzazione-degli-iperparametri" class="nav-link" data-scroll-target="#ottimizzazione-degli-iperparametri">Ottimizzazione degli iperparametri</a></li>
  <li><a href="#deployment" id="toc-deployment" class="nav-link" data-scroll-target="#deployment">Deployment</a></li>
  <li><a href="#monitoraggio-e-manutenzione" id="toc-monitoraggio-e-manutenzione" class="nav-link" data-scroll-target="#monitoraggio-e-manutenzione">Monitoraggio e manutenzione</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">Algoritmi</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Gli algoritmi sono il cuore pulsante dell’intelligenza artificiale e svolgono un ruolo cruciale nel trasformare i dati grezzi in informazioni utili. In questo capitolo, esploreremo vari tipi di algoritmi utilizzati nell’IA. Approfondiremo l’inferenza logica, probabilistica e bayesiana, nonché gli algoritmi di ricerca, equitativi e predittivi.</p>
<section id="inferenza-logica" class="level2">
<h2 class="anchored" data-anchor-id="inferenza-logica">Inferenza Logica</h2>
<blockquote class="blockquote">
<p><strong>definizione Treccani</strong>: inferenza logica sinonimo di «argomentazione logica» utilizzato per designare il processo di deduzione di una formula A, detta conclusione, a partire da una o più formule, dette premesse. Secondo A. De Morgan, una inferenza è la «produzione di una proposizione come conseguenza necessaria di una o più proposizioni».</p>
</blockquote>
<p>L’inferenza logica è un processo fondamentale nel campo della logica, della matematica e della filosofia, utilizzato per derivare conclusioni a partire da premesse o informazioni date. Questo processo può essere visto come un mezzo per scoprire nuove verità o per confermare la validità di affermazioni esistenti. L’inferenza logica si suddivide principalmente in due categorie: deduttiva e induttiva.</p>
<p>L’inferenza deduttiva è quella in cui la conclusione deriva necessariamente dalle premesse; se le premesse sono vere, la conclusione non può che essere vera. Un classico esempio di inferenza deduttiva è il sillogismo: “Tutti gli uomini sono mortali; Socrate è un uomo; quindi, Socrate è mortale.” In questo caso, la verità delle premesse garantisce la verità della conclusione.</p>
<p>L’inferenza induttiva, invece, opera diversamente: partendo da osservazioni specifiche o da una serie di dati, arriva a conclusioni più generali, che non sono necessariamente certe ma probabili. Ad esempio, se si osserva che il sole è sorto ogni giorno, si potrebbe inferire che il sole sorgerà anche domani. Questa forma di inferenza è molto utilizzata nella scienza, dove gli scienziati formulano ipotesi basate su dati osservati e sperimentali.</p>
<p>Un altro tipo di inferenza logica è l’abduzione, che implica la formazione della migliore spiegazione possibile data un insieme di osservazioni. Questo tipo di inferenza è spesso utilizzato nella diagnosi medica, nella ricerca scientifica e nelle indagini criminali, dove si cerca di spiegare i dati osservati nel modo più coerente possibile.</p>
<p>L’inferenza logica è strettamente legata al concetto di validità e di correttezza degli argomenti. Un’argomentazione è valida se la sua struttura logica è tale che, qualora le premesse siano vere, anche la conclusione deve essere vera. Tuttavia, un’argomentazione può essere valida senza essere corretta; per essere corretta, deve avere anche premesse vere. Ad esempio, l’argomentazione “Tutti gli unicorni sono verdi; io possiedo un unicorno; quindi, il mio unicorno è verde” è valida dal punto di vista logico, ma non è corretta perché le premesse non sono vere.</p>
<p>L’inferenza logica è alla base di molti sistemi di intelligenza artificiale e di calcolo automatico, dove gli algoritmi vengono progettati per inferire nuove informazioni a partire da dati iniziali. Nei sistemi esperti, per esempio, vengono utilizzate regole di inferenza per simulare il processo decisionale umano. In conclusione, l’inferenza logica è uno strumento potente e versatile che permea molte aree del pensiero umano e della tecnologia, consentendo di avanzare nella conoscenza e nella comprensione del mondo che ci circonda. L’inferenza logica è una tecnica fondamentale dell’intelligenza artificiale che utilizza le regole logiche per derivare nuove informazioni da quelle esistenti. Nella giurisprudenza, l’inferenza logica può essere utilizzata per analizzare le leggi e determinare le conseguenze logiche delle azioni legali.</p>
<blockquote class="blockquote">
<p><strong>I sistemi esperti</strong> - Negli anni ’80, l’inferenza logica è stata fondamentale nello sviluppo dei sistemi esperti, strumenti avanzati di intelligenza artificiale progettati per risolvere problemi complessi emulando il ragionamento umano. Due noti prodotti commerciali di quel periodo sono stati MYCIN, un sistema esperto per la diagnosi di infezioni del sangue, e XCON, utilizzato per configurare sistemi di computer VAX di Digital Equipment Corporation. MYCIN e XCON sfruttavano regole di inferenza per elaborare informazioni e fornire raccomandazioni o soluzioni, dimostrando l’efficacia dell’inferenza logica in applicazioni pratiche e commerciali &gt; - <a href="https://www.shortliffe.net/Buchanan-Shortliffe-1984/MYCIN%20Book.htm">“Rule-based Expert Systems : The MYCIN Experiments of the Stanford Heuristic Programming Project”, edited by Bruce G. Buchanan, Edward H. Shortliffe (AddisonWesley, 1984)</a> - <a href="https://cdn.aaai.org/AAAI/1980/AAAI80-076.pdf">“RI: an Expert in the Computer Systems Domain”</a></p>
</blockquote>
<section id="proposizioni-logiche" class="level3">
<h3 class="anchored" data-anchor-id="proposizioni-logiche">Proposizioni Logiche</h3>
<p>Le proposizioni logiche sono dichiarazioni atomiche che possono essere valutate come vere o false. Le proposizioni possono essere combinate utilizzando operatori logici come AND, OR, NOT, IMPLIES, che permettono di costruire regole complesse rappresentate da formule logiche.</p>
<p>Ecco alcuni esempi di proposizioni logiche:</p>
<p>p: “Il sole è luminoso” (Vero) q: “La Luna è fatta di formaggio” (Falso) r: “Se piove, allora la strada sarà bagnata” (Condizionale)</p>
</section>
<section id="calcolo-delle-proposizioni-logiche" class="level3">
<h3 class="anchored" data-anchor-id="calcolo-delle-proposizioni-logiche">Calcolo delle Proposizioni Logiche</h3>
<p>Le proposizioni logiche possono essere manipolate utilizzando vari operatori logici che eseguono operazioni specifiche:</p>
<p><strong>Congiunzione (AND - ∧)</strong>: L’operatore AND restituisce vero solo quando entrambe le proposizioni coinvolte sono vere. Ad esempio, se abbiamo due proposizioni p e q, p ∧ q è vero solo se entrambe p e q sono vere. La cosidetta tabella di verità riportata qui sotto consente di vedere come funziona l’operatore AD.</p>
<table class="table-hover caption-top table">
<caption>Tavola della verità per la congiunzione</caption>
<thead>
<tr class="header">
<th style="text-align: left;">p</th>
<th style="text-align: left;">q</th>
<th style="text-align: left;">p ∧ q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="even">
<td style="text-align: left;">False</td>
<td style="text-align: left;">True</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="odd">
<td style="text-align: left;">True</td>
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="even">
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
</tr>
</tbody>
</table>
<p><strong>Disgiunzione (OR - ∨)</strong>: L’operatore OR restituisce vero se almeno una delle due proposizioni coinvolte è vera. Ad esempio, p ∨ q è vero se p è vero oppure se q è vero oppure se entrambi sono veri. La tabella di verità riportata qui sotto consente di vedere come funziona l’operatore OR.</p>
<table class="table-hover caption-top table">
<caption>Tavola della verità per la disgiunzione</caption>
<thead>
<tr class="header">
<th style="text-align: left;">p</th>
<th style="text-align: left;">q</th>
<th style="text-align: left;">p ∨ q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="even">
<td style="text-align: left;">False</td>
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
</tr>
<tr class="odd">
<td style="text-align: left;">True</td>
<td style="text-align: left;">False</td>
<td style="text-align: left;">True</td>
</tr>
<tr class="even">
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
</tr>
</tbody>
</table>
<p><strong>Negazione (NOT - ¬)</strong>: L’operatore NOT cambia il valore di verità di una proposizione. Ad esempio, ¬p è vero se p è falso e viceversa.</p>
<table class="table-hover caption-top table">
<caption>Tavola della verità per la negazione</caption>
<thead>
<tr class="header">
<th style="text-align: left;">p</th>
<th style="text-align: left;">¬p</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">False</td>
<td style="text-align: left;">True</td>
</tr>
<tr class="even">
<td style="text-align: left;">True</td>
<td style="text-align: left;">False</td>
</tr>
</tbody>
</table>
<p><strong>Implicazione (→)</strong>: L’implicazione è un’operazione logica che collega due proposizioni e stabilisce una relazione di condizionalità. Si rappresenta con il simbolo “→” e si legge come “se… allora”. In un’implicazione del tipo “p → q”, la proposizione p è chiamata l’antecedente e la proposizione q è il conseguente. L’implicazione è falsa solo nel caso in cui l’antecedente è vero e il conseguente è falso. In tutti gli altri casi, l’implicazione è considerata vera. Poiché questa operazione è alla base di molti algoritmi di inferenza, è importante capire come funziona. La tabella di verità riportata qui sotto consente di vedere come funziona l’operatore implicazione.</p>
<table class="table-hover caption-top table">
<caption>Tavola della verità per l’implicazione</caption>
<thead>
<tr class="header">
<th>p</th>
<th>q</th>
<th>p → q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>False</td>
<td>False</td>
<td>True</td>
</tr>
<tr class="even">
<td>False</td>
<td>True</td>
<td>True</td>
</tr>
<tr class="odd">
<td>True</td>
<td>False</td>
<td>False</td>
</tr>
<tr class="even">
<td>True</td>
<td>True</td>
<td>True</td>
</tr>
</tbody>
</table>
<p>Esempio di Implicazione: supponiamo di avere le seguenti proposizioni: - p: Il sole splende. - q: Faccio una passeggiata.</p>
<p>L’implicazione che possiamo formulare è: “Se il sole splende, allora faccio una passeggiata”, che si scrive come “p → q”. Dalla tabella della verità, possiamo vedere che in tre dei quattro casi l’implicazione “p → q” è vera. L’unico caso in cui l’implicazione è falsa è quando il sole splende (p è vero) ma non faccio una passeggiata (q è falso).</p>
<p>Quindi, in base alla logica dell’implicazione, se il sole splende, sto effettivamente facendo una passeggiata o potrei anche non farla (ad eccezione del caso in cui il sole splenda e io non faccia una passeggiata, in cui l’implicazione è falsa).</p>
<p><strong>Implicazione Bilaterale (↔︎)</strong>: L’implicazione bilaterale è un’operazione logica che stabilisce che due proposizioni sono equivalenti, cioè che entrambe le proposizioni hanno lo stesso valore di verità. Si rappresenta con il simbolo “↔︎” e si legge come “se e solo se”. L’implicazione bilaterale è vera solo quando le proposizioni hanno lo stesso valore di verità, sia entrambe vere che entrambe false.</p>
<table class="table-hover caption-top table">
<caption>Tavola della verità per l’implicazione bilaterale</caption>
<thead>
<tr class="header">
<th style="text-align: left;">p</th>
<th style="text-align: left;">q</th>
<th style="text-align: left;">p ↔︎ q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
<td style="text-align: left;">True</td>
</tr>
<tr class="even">
<td style="text-align: left;">False</td>
<td style="text-align: left;">True</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="odd">
<td style="text-align: left;">True</td>
<td style="text-align: left;">False</td>
<td style="text-align: left;">False</td>
</tr>
<tr class="even">
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
<td style="text-align: left;">True</td>
</tr>
</tbody>
</table>
<p>L’implicazione bilaterale, anche conosciuta come “se e solo se”, è un importante concetto logico che stabilisce che due proposizioni sono logicamente equivalenti, cioè entrambe sono vere o entrambe sono false contemporaneamente.</p>
<p>Esempio di Implicazione Bilaterale: supponiamo di avere le seguenti proposizioni:</p>
<ul>
<li>p: Oggi è venerdì.</li>
<li>q: Domani è sabato.</li>
</ul>
<p>L’implicazione bilaterale tra p e q può essere scritta come p ↔︎ q, che si legge come “Oggi è venerdì se e solo se domani è sabato”.</p>
<p>Dalla tabella di verità, possiamo notare che l’implicazione bilaterale “Oggi è venerdì se e solo se domani è sabato” è vera solo nei casi in cui entrambe le proposizioni sono vere (primo e ultimo caso) o entrambe sono false. Se c’è una discrepanza nelle verità delle proposizioni, l’implicazione bilaterale diventa falsa (secondo e terzo caso).</p>
<p>Quindi, nel nostro esempio, l’affermazione “Oggi è venerdì se e solo se domani è sabato” è vera solo quando entrambe le proposizioni sono vere o entrambe sono false, evidenziando l’equivalenza logica tra le due proposizioni nel contesto dell’implicazione bilaterale.</p>
</section>
<section id="basi-della-conoscenza" class="level3">
<h3 class="anchored" data-anchor-id="basi-della-conoscenza">Basi della Conoscenza</h3>
<p>La base della conoscenza in un agente a inferenza logica è costituita da proposizioni logiche, che sono affermazioni dichiarative che possono essere vere o false. Le proposizioni possono essere atomiche o composte e sono spesso rappresentate utilizzando variabili proposizionali. Queste variabili assumono valori di verità (vero o falso) e vengono combinate tramite operatori logici per formare regole logiche complesse. La base della conoscenza in un sistema logico definisce le relazioni tra le proposizioni e fornisce le fondamenta per il ragionamento e l’inferenza. Un agente a inferenza logica usa la Base della Conoscenza per giungere a conclusioni circa il mondo che la circonda; Per fare ciò ha bisogno di regole di implicazione logica (⊨): Se α ⊨ β, ovvero se α implica logicamente β, in ogni mondo dove α è vera allora β è vera. È diversa dall’implicazione perché non è un connettivo logico ma una relazione che dice che se α è vera allora β è vera e basta!</p>
</section>
<section id="sistemi-basati-sulla-conoscenza" class="level3">
<h3 class="anchored" data-anchor-id="sistemi-basati-sulla-conoscenza">Sistemi basati sulla conoscenza</h3>
<p>I sistemi basati sulla conoscenza sono strumenti informatici progettati per emulare il processo decisionale umano attraverso l’utilizzo di una base di conoscenza strutturata. Questi sistemi raccolgono, organizzano e utilizzano informazioni specifiche di un dominio per risolvere problemi complessi che richiedono competenza specialistica. Una componente fondamentale è la <strong>base di conoscenza</strong>, che contiene fatti, regole ed euristiche rappresentative del sapere umano in un determinato campo. Il <strong>motore di inferenza</strong> è l’altro elemento chiave: applica regole logiche ai dati presenti nella base di conoscenza per dedurre nuove informazioni o prendere decisioni informate.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Sistemi basati sulla conoscenza.png" class="img-fluid figure-img" alt="Processo di creazione e gestione di un sistema basato sulla conoscenza" width="600"></p>
<figcaption>Processo di creazione e gestione di un sistema basato sulla conoscenza</figcaption>
</figure>
</div>
<p>Il processo di creazione di un sistema esperto basato sull’inferenza logica inizia con l’acquisizione della conoscenza, dove gli esperti del dominio collaborano per estrarre informazioni e regole rilevanti. Queste conoscenze vengono poi formalizzate nella rappresentazione della conoscenza, utilizzando strutture come regole if-then, ontologie o reti semantiche, che alimentano la base di conoscenza. Il motore di inferenza viene sviluppato per applicare queste regole logiche ai dati forniti, deducendo nuove informazioni o prendendo decisioni informate. La gestione del sistema include l’aggiornamento continuo della base di conoscenza per riflettere nuove scoperte o cambiamenti nel dominio, nonché la verifica e la validazione del sistema per garantirne l’accuratezza e l’affidabilità. Gli utenti interagiscono con il sistema attraverso un’interfaccia che facilita l’inserimento dei dati e la visualizzazione dei risultati, permettendo anche il feedback per miglioramenti futuri.</p>
<p>Questi sistemi trovano applicazione in vari settori, come la medicina, l’ingegneria, la finanza e l’assistenza clienti. Ad esempio, in ambito medico, un sistema basato sulla conoscenza può aiutare nella diagnosi di malattie analizzando sintomi e storie cliniche dei pazienti. L’efficacia di tali sistemi dipende dalla qualità e dall’aggiornamento costante della base di conoscenza, nonché dalla capacità del motore di inferenza di elaborare correttamente le informazioni.</p>
<p>Un vantaggio significativo dei sistemi basati sulla conoscenza è la possibilità di conservare e diffondere l’esperienza di esperti, rendendola accessibile a un pubblico più ampio e contribuendo alla standardizzazione delle pratiche. Tuttavia, la creazione e la manutenzione di una base di conoscenza richiedono notevoli risorse e competenze. Con l’avanzamento dell’intelligenza artificiale e dell’apprendimento automatico, questi sistemi continuano a evolversi, integrando nuove tecniche per migliorare l’efficienza, l’accuratezza e la capacità di apprendimento autonomo nelle loro applicazioni.</p>
</section>
<section id="semplice-sistema-esperto-in-ambito-penale" class="level3">
<h3 class="anchored" data-anchor-id="semplice-sistema-esperto-in-ambito-penale">Semplice Sistema Esperto in ambito penale</h3>
<p>In questo paragrafo, useremo la libreria <a href="https://www.sympy.org/en/index.html"><strong>SymPy</strong></a> in Python per creare un semplice sistema esperto basato sull’inferenza logica nell’ambito del diritto penale. Questo sistema aiuterà a determinare se determinati comportamenti costituiscono un reato, in base ai fatti noti e alle norme applicabili. Si noti che la libreria <strong>SymPy</strong> è stata sviluppata per consentire il calcolo simbolico in Python. In questo caso useremo le funzionalità di calcolo simbolico per la rappresentazione della conoscenza, usando le funzionalità di calcolo logico, e per l’inferenza logica.</p>
<p><a href="https://colab.research.google.com/github/capitanio/laboratorio-ia/blob/main/2 sistema esperto inferenza logica.ipynb" target="_blank" rel="noopener noreferrer"><img align="left" src="https://colab.research.google.com/assets/colab-badge.svg" alt="Esegui in Colab" title="Apri e esegui in Google Colaboratory"></a> <br></p>
<p>(click-ando su questo pulsante aprirete il quaderno all’interno di COLAB di Google dove potrete eseguire il quaderno online senza bisogno di avere un ambiente Python sulla vostra macchina.)</p>
<section id="introduzione" class="level4">
<h4 class="anchored" data-anchor-id="introduzione">Introduzione</h4>
<p>Il diritto penale si basa su norme che definiscono quali comportamenti sono considerati reati e quali elementi devono essere presenti affinché un’azione sia punibile. Un sistema esperto in questo contesto può aiutare a:</p>
<ul>
<li>Valutare se un’azione specifica costituisce un reato.</li>
<li>Identificare gli elementi costitutivi del reato.</li>
<li>Fornire una base logica per decisioni legali.</li>
</ul>
<p>Utilizzeremo SymPy per modellare proposizioni logiche, regole legali e per effettuare inferenze.</p>
<hr>
</section>
<section id="installazione-di-sympy" class="level4">
<h4 class="anchored" data-anchor-id="installazione-di-sympy">Installazione di SymPy</h4>
<p>Assicurati di avere SymPy installato:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install sympy</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Se stai utilizzando questo notebook in un ambiente in cui SymPy non è installato, esegui la seguente cella:</p>
<div id="cell-5" class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install sympy</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="concetti-di-base-nel-diritto-penale" class="level4">
<h4 class="anchored" data-anchor-id="concetti-di-base-nel-diritto-penale">Concetti di Base nel Diritto Penale</h4>
<p>Prima di iniziare, definiamo alcuni concetti chiave:</p>
<ul>
<li><strong>Fatti</strong>: Eventi o azioni specifiche accadute.</li>
<li><strong>Reati</strong>: Comportamenti definiti come illeciti dalla legge penale.</li>
<li><strong>Elementi Costitutivi del Reato</strong>: Condizioni che devono essere soddisfatte perché un comportamento sia considerato un reato (ad esempio, azione, intenzione, nesso causale).</li>
<li><strong>Regole Legali</strong>: Norme che stabiliscono le condizioni in cui un comportamento è punibile.</li>
</ul>
<hr>
</section>
<section id="modellazione-con-sympy" class="level4">
<h4 class="anchored" data-anchor-id="modellazione-con-sympy">Modellazione con SymPy</h4>
<p><strong>Passo 1: Importare i Moduli Necessari</strong></p>
<p>Importiamo i moduli necessari da SymPy per lavorare con la logica proposizionale.</p>
<div id="cell-8" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sympy <span class="im">import</span> symbols</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sympy.logic.boolalg <span class="im">import</span> And, Or, Not, Implies, Equivalent</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sympy.logic.inference <span class="im">import</span> satisfiable</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Passo 2: Definire le Proposizioni Logiche</strong></p>
<p>Definiamo le variabili che rappresentano i fatti e gli elementi costitutivi del reato.</p>
<div id="cell-10" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fatti</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>Azione, Intenzione, NessoCausale <span class="op">=</span> symbols(<span class="st">'Azione Intenzione NessoCausale'</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Reato</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>Omicidio <span class="op">=</span> symbols(<span class="st">'Omicidio'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Passo 3: Definire le Regole che discendono dal Codice Penale</strong></p>
<p>Ad esempio, secondo il codice penale, l’omicidio richiede:</p>
<ul>
<li><strong>Azione</strong>: Causare la morte di una persona.</li>
<li><strong>Intenzione</strong>: Volontà di causare la morte (dolo).</li>
<li><strong>Nesso Causale</strong>: La morte è conseguenza dell’azione.</li>
</ul>
<p>Definiamo la regola:</p>
<div id="cell-12" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Regola: Se c'è Azione, Intenzione e Nesso Causale, allora si configura l'Omicidio</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>regola_omicidio <span class="op">=</span> Implies(And(Azione, Intenzione, NessoCausale), Omicidio)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Passo 4: Definire i Fatti Noti</strong></p>
<p>Supponiamo di avere i seguenti fatti:</p>
<ul>
<li>Una persona ha compiuto un’azione che ha causato la morte di un’altra.</li>
<li>Aveva l’intenzione di causare la morte.</li>
<li>Esiste un nesso causale tra l’azione e la morte.</li>
</ul>
<div id="cell-14" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fatti noti</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>fatto1 <span class="op">=</span> Azione  <span class="co"># L'azione di causare la morte</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>fatto2 <span class="op">=</span> Intenzione  <span class="co"># Intenzione di causare la morte</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>fatto3 <span class="op">=</span> NessoCausale  <span class="co"># La morte è conseguenza dell'azione</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Passo 5: Creare la Base di Conoscenza</strong></p>
<p>Combiniamo fatti e regole:</p>
<div id="cell-16" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Base di conoscenza</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>base_conoscenza <span class="op">=</span> And(fatto1, fatto2, fatto3, regola_omicidio)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Passo 6: Inferenza Logica</strong></p>
<p>Verifichiamo se, sulla base dei fatti e delle regole, possiamo concludere che si tratta di omicidio.</p>
<div id="cell-18" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verifichiamo se Omicidio è deducibile</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>ipotesi <span class="op">=</span> And(base_conoscenza, Not(Omicidio))</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>risultato <span class="op">=</span> satisfiable(ipotesi)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> risultato:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Si configura il reato di omicidio."</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Non possiamo concludere che si tratti di omicidio."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Si configura il reato di omicidio.</code></pre>
</div>
</div>
<p><strong>Output atteso:</strong></p>
<pre><code>Si configura il reato di omicidio.</code></pre>
</section>
<section id="espansione-del-sistema" class="level4">
<h4 class="anchored" data-anchor-id="espansione-del-sistema">Espansione del Sistema</h4>
<p><strong>Caso con Mancanza di Intenzione</strong></p>
<p>Supponiamo che l’intenzione non sia presente (ad esempio, si tratta di omicidio colposo).</p>
<div id="cell-21" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Fatti noti senza Intenzione</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>fatto1 <span class="op">=</span> Azione</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>fatto2 <span class="op">=</span> Not(Intenzione)  <span class="co"># Mancanza di intenzione</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>fatto3 <span class="op">=</span> NessoCausale</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Base di conoscenza aggiornata</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>base_conoscenza <span class="op">=</span> And(fatto1, fatto2, fatto3, regola_omicidio)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Inferenza per Omicidio</strong></p>
<div id="cell-23" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Inferenza</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>ipotesi <span class="op">=</span> And(base_conoscenza, Not(Omicidio))</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>risultato <span class="op">=</span> satisfiable(ipotesi)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> risultato:</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Si configura il reato di omicidio."</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Non possiamo concludere che si tratti di omicidio."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Non possiamo concludere che si tratti di omicidio.</code></pre>
</div>
</div>
<p><strong>Output atteso:</strong></p>
<pre><code>Non possiamo concludere che si tratti di omicidio.</code></pre>
<section id="aggiunta-di-altre-regole" class="level5">
<h5 class="anchored" data-anchor-id="aggiunta-di-altre-regole">Aggiunta di Altre Regole</h5>
<p>Aggiungiamo la regola per l’<strong>omicidio colposo</strong>:</p>
<div id="cell-26" class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Definizione del reato di Omicidio Colposo</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>OmicidioColposo <span class="op">=</span> symbols(<span class="st">'OmicidioColposo'</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Regola per Omicidio Colposo: Azione e Nesso Causale senza Intenzione</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>regola_omicidio_colposo <span class="op">=</span> Implies(And(Azione, Not(Intenzione), NessoCausale), OmicidioColposo)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Aggiorniamo la base di conoscenza</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>base_conoscenza <span class="op">=</span> And(fatto1, fatto2, fatto3, regola_omicidio, regola_omicidio_colposo)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Inferenza per Omicidio Colposo</strong></p>
<div id="cell-28" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verifichiamo se si configura l'Omicidio Colposo</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>ipotesi <span class="op">=</span> And(base_conoscenza, Not(OmicidioColposo))</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>risultato <span class="op">=</span> satisfiable(ipotesi)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> risultato:</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Si configura il reato di omicidio colposo."</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Non possiamo concludere che si tratti di omicidio colposo."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Si configura il reato di omicidio colposo.</code></pre>
</div>
</div>
<p><strong>Output atteso:</strong></p>
<pre><code>Si configura il reato di omicidio colposo.</code></pre>
</section>
</section>
<section id="conclusione" class="level4">
<h4 class="anchored" data-anchor-id="conclusione">Conclusione</h4>
<p>Abbiamo visto come utilizzare SymPy per modellare un semplice sistema esperto nel campo del diritto penale. Questo esempio illustra come le regole legali e i fatti possono essere formalizzati utilizzando la logica proposizionale, permettendo al sistema di effettuare inferenze logiche.</p>
<p>Ricorda che questo è un modello semplificato e che il diritto penale è complesso e richiede una comprensione approfondita per essere modellato accuratamente. Questo sistema può essere un punto di partenza per sviluppi più avanzati e per esplorare l’intersezione tra intelligenza artificiale e diritto.</p>
</section>
</section>
</section>
<section id="inferenza-probabilistica" class="level2">
<h2 class="anchored" data-anchor-id="inferenza-probabilistica">Inferenza Probabilistica</h2>
<p>L’inferenza probabilistica utilizza la teoria delle probabilità per fare previsioni o inferenze basate su dati incompleti o incerti. Questo tipo di inferenza è particolarmente utile in tutti i contesti dove le informazioni possono essere incomplete o incerte.</p>
<p>L’agente artificiale in situazioni di incertezza affronta la sfida di prendere decisioni razionali quando non si dispone di informazioni complete o quando le informazioni disponibili sono soggette a variabilità. In tali contesti, l’agente deve essere in grado di gestire e interpretare l’incertezza in modo efficace per agire in modo intelligente e adattivo.</p>
<p>L’incertezza può derivare da diversi fattori, come la natura incompleta delle informazioni, la presenza di rumore nei dati, l’aleatorietà degli eventi o la complessità dei problemi da affrontare. Gli agenti artificiali, dotati di capacità di ragionamento probabilistico e di inferenza, sono in grado di valutare le conseguenze di diverse azioni in base alle probabilità associate agli eventi futuri e agli esiti attesi.</p>
<p>L’inferenza probabilistica è una tecnica utilizzata nell’ambito dell’Intelligenza Artificiale per prendere decisioni o formulare previsioni basate su informazioni incerte o parziali. In pratica, ciò significa che invece di avere risposte binarie (vero o falso), lavoriamo con probabilità, cioè con il grado di certezza o incertezza riguardo a una determinata affermazione o evento.</p>
<p><strong>Esempio in un contesto legale</strong></p>
<p>Immagina un caso giuridico in cui una persona è accusata di un crimine. Nel sistema giuridico, la giuria deve prendere una decisione sulla colpevolezza o innocenza dell’imputato. Tuttavia, spesso non abbiamo prove definitive o testimonianze che garantiscono una certezza assoluta. In questo contesto, l’inferenza probabilistica può essere applicata. Invece di dire semplicemente “colpevole” o “innocente,” i giurati possono assegnare una probabilità alla colpevolezza dell’imputato. Ad esempio, potrebbero dire che ci sono il 70% di probabilità che l’imputato sia colpevole e il 30% di probabilità che sia innocente. Infine, una soglia sulla probabilità di colpevolezza potrebbe dare origine alla sentenza.</p>
<p><strong>Esempio in un generico contesto di diagnosi</strong></p>
<p>Nel caso di una diagnosi ( in qualunque settore) è necessario prendere una decisione con conoscenza incerta. Si è in una situazione di incertezza in quanto la lista di situazioni e cause da descrivere non può essere esaustiva (praticamente infinita per la mancanza di conoscenza universale). Non si può usare la logica del primo ordine per gestire la diagnosi perché: - è impossibile elencare l’insieme praticamente infinito di antecedenti e conseguenti per evitare eccezioni - è impossibile avere una conoscenza metodologica completa - è impossibile avere una conoscenza applicativa completa - L’agente non potrà mai agire con una piena consapevolezza di verità e correttezza, avrà solo un grado di credenza sulla bontà delle azioni da intraprendere e dei risultati.</p>
<section id="inferenza-probabilistica-e-la-teoria-delle-probabilità" class="level3">
<h3 class="anchored" data-anchor-id="inferenza-probabilistica-e-la-teoria-delle-probabilità">Inferenza probabilistica e La teoria delle probabilità</h3>
<p>L’inferenza probabilistica è un processo di ragionamento che utilizza il calcolo delle probabilità per prendere decisioni o formulare previsioni in situazioni in cui le informazioni sono incomplete o incerte. L’inferenza probabilistica è fondamentale in vari campi, come la statistica, l’apprendimento automatico, la medicina, la finanza e molti altri.</p>
<p>Il calcolo delle probabilità è una branca della matematica che si occupa di misurare e analizzare la probabilità di eventi casuali. La probabilità è una misura numerica che descrive la possibilità che un evento specifico accada.</p>
<blockquote class="blockquote">
<p>“Il concetto di probabilità è il più importante della scienza moderna, soprattutto perché nessuno ha la più pallida idea del suo significato.” (Bertrand Russel)</p>
</blockquote>
<p>La teoria della probabilità assume la stessa assunzione ontologica della logica: - i fatti del mondo sono: veri o falsi (con una certa probabilità) - Ogni possibile situazione in cui si trova il nostro agente è un mondo µ; Esempio: nel caso del gioco del Lotto, per la singola estrazione ci possono essere 90 mondi, uno per ogni numero che può essere estratto. - Ogni mondo µ è un insieme di fatti: - fatti veri (V) - fatti falsi (F) - fatti incerti (I)</p>
<p>Tale teoria può essere formulata in diversi modi a seconda del tipo di assunzioni iniziali che si utilizzano. In questo testo si utilizza la teoria della probabilità basata sui cosiddetti assiomi di Kolmogorov e per questo detta <strong>Teoria Assiomatica della Probabilità</strong>.</p>
<p>Gli assiomi di Kolmogorov costituiscono la base matematica della teoria delle probabilità, formulata dal matematico russo Andrey Kolmogorov nel suo lavoro “Grundbegriffe der Wahrscheinlichkeitsrechnung” nel 1933.</p>
<p>Ecco una descrizione dei tre assiomi di Kolmogorov:</p>
<ul>
<li><p><strong>Primo Assioma (Non-negatività):</strong> La probabilità di un evento è sempre un numero reale non negativo: P(A)≥0 per ogni evento A. Per rappresentare la probabilità di un certo mondo si usa il simbolo P(µ), 0 &lt;= P(µ) &lt;= 1</p>
<ul>
<li>P(µ) = 0 significa che il mondo µ non ha nessuna possibilità di verificarsi. Ad esempio la probabilità che al lotto venga estratto il numero 0 (zero)</li>
<li>P(µ) = 1 significa che il mondo µ è certo. Ad esempio la probabilità che il risultato di una estrazione sia minore o uguale a 90 è 1 Più è «grande» P(µ) è più è verosimile che si verifichi il mondo µ.</li>
</ul></li>
<li><p><strong>Secondo Assioma (Normalizzazione) :</strong> La somma delle probabilità di tutti gli eventi possibili nello spazio campione è uguale a 1: P(S) = 1, dove S rappresenta lo spazio campione. Ad esempio, la somma delle probabilità di estrazione di tutti i numeri del lotto è pari a 1</p></li>
<li><p><strong>Terzo Assioma (Additività) :</strong> Se A1, A2, A3, … sono eventi mutuamente esclusivi (cioè non possono accadere simultaneamente), allora la probabilità dell’unione di questi eventi è uguale alla somma delle loro probabilità individuarie: P(A1 ∪ A2 ∪ A3 ∪ …) = P(A1) + P(A2) + P(A3) + … Ad esempio, la probabilità di estrarre un numero pari al lotto è pari alla somma delle probabilità di estrarre i numeri pari da 2 a 90. ​</p></li>
</ul>
<p>Gli assiomi di Kolmogorov forniscono un fondamento rigoroso per definire le probabilità e garantiscono che le probabilità siano consistenti e soddisfino le proprietà chiave della teoria delle probabilità. Questi assiomi sono essenziali per lo studio formale della probabilità e vengono utilizzati per sviluppare e applicare concetti probabilistici in varie discipline, inclusi statistica, teoria dei giochi, intelligenza artificiale e molti altri campi scientifici.</p>
</section>
<section id="cacolo-della-probabilità-incondizionata-o-a-priori" class="level3">
<h3 class="anchored" data-anchor-id="cacolo-della-probabilità-incondizionata-o-a-priori">Cacolo della probabilità incondizionata o a priori</h3>
<p><strong>calcolo della probabilità di estrazione di un numero x al lotto Usando i tre assiomi di Kolmogorov :</strong></p>
<p>si può calcolare la probabilità di estrazione di un numero x al lotto. - Dal primo assionmato si ha che P(x) &gt;= 0. - Dal secondo assioma si ha che la somma di tutti i P(x), con x che va da 1 a 90, è pari a 1. - Dal terzo si evince che essendo le probabilità di estrazione di un numero x uguale a quella di estrarre un numero y, con x diverso da y, si ha che la probabilità di estrarre un numero x è pari a 1/90.</p>
<p><strong>calcolo della probabilità del risultato x nel lancio di un dado Nel lancio di un dado a 6 facce:</strong></p>
<p>la probabilità P(n) di ottenere il numero n è P(n) = 1/6 perché all’esito del lancio tutte le facce del dado hanno uguale probabilità.</p>
<p><strong>calcolo della probabilità del risultato nel lancio di due dadi :</strong> Nell’esito del lancio di due dadi, dobbiamo considerare che i mondi possibili ed equiprobabili sono 6x6=36 e quindi la probabilità di uno di questi mondi è 1/36.</p>
<p><strong>calcolo della probabilità del risultato x come somma dei valori nel lancio di due dadi :</strong> Nell’esito del lancio di due dadi, se vogliamo calcolare la probabilità che esca un certo valore x come somma dei valori dei due dadi dobbaimo considerare che i valori possibili di x [2,12] non sono equiprobabili. Infatti, per esempio, la probabilità di ottenere 2 è 1/36, mentre la probabilità di ottenere 7 è 6/36. Per calcolare la probabilità del valore x è sufficiente contare quanti sono i mondi in cui il valore x si ottiene come somma dei valori dei due dadi e poi dividere per il numero totale di mondi possibili. I possibili risultati del lancio di due dadi sono 36 :</p>
<table class="caption-top table">
<caption>Lancio di due dadi</caption>
<colgroup>
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">+</th>
<th style="text-align: right;">1</th>
<th style="text-align: right;">2</th>
<th style="text-align: right;">3</th>
<th style="text-align: right;">4</th>
<th style="text-align: right;">5</th>
<th style="text-align: right;">6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>1</strong></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>4</strong></td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>5</strong></td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">11</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>6</strong></td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">11</td>
<td style="text-align: right;">12</td>
</tr>
</tbody>
</table>
<p>La probabilità di ottenere 2 è data dal numero di esiti favorevoli al risultato 2, in questo caso è solo uno, diviso il numero totale di esiti possibili, in questo caso 36. La possibilità di ottenere 3 è data dal numero di esiti favorevoli al risultato 3, in questo caso sono 2, diviso il numero totale di esiti possibili, in questo caso 36. …</p>
<p>P(2)=1/36, P(3)=2/36, P(4)=3/36, P(5)=4/36, P(6)=5/36, P(7)=6/36, P(8)=5/36, P(9)=4/36, P(10)=3/36, P(11)=2/36, P(12)=1/36</p>
</section>
<section id="variabili-aleatorie" class="level3">
<h3 class="anchored" data-anchor-id="variabili-aleatorie">Variabili aleatorie</h3>
<p>Una variabile aleatoria nel calcolo delle probabilità è una variabile che può assumere uno dei possibili valori in un certo dominio: - La variabile lancio nel lancio di un dado può assumere uno dei valori nel dominio {1,2,3,4,5,6} - La variabile sentenza nel processo penale può assumere uno dei valori nel dominio {«Non luogo a procedere», «Proscioglimento», «Condanna»} - La variabile diagnosi in campo medico può assumere uno dei valori nel dominio {«Malattia», «Non malattia»}.</p>
<p>Nell’inferenza probsbilistica si è interessati alla probabilità che una certa variabile aleatoria assuma un certo valore. Ad esempio, in un determinato processo penale si potrebbe avere:</p>
<ul>
<li>P(sentenza = «Non luogo a procedere») = 0,1</li>
<li>P(sentenza = «Proscioglimento») = 0,1</li>
<li>P(sentenza = «Condanna») = 0,8</li>
</ul>
<p>Per codificare la variabile aleatoria “sentenza” in Python, si può utilizzare ad esempio la struttura dati dizionario che mappa i possibili esiti (“Non luogo a procedere”, “Proscioglimento”, “Condanna”) ai rispettivi valori numerici di probabilità. Ecco un esempio di come si potrebbe codificare la variabile aleatoria “sentenza” in Python utilizzando un dizionario:</p>
<div id="cell-35" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Definizione della variabile aleatoria sentenza con i suoi possibili valori</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>sentenza <span class="op">=</span> {</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Non luogo a procedere"</span>: <span class="fl">0.128</span>, <span class="co"># probabilità del 12.8% di non luogo a procedere</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Proscioglimento"</span>: <span class="fl">0.548</span>,       <span class="co"># probabilità del 54.8% di proscioglimento</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Condanna"</span>: <span class="fl">0.324</span>               <span class="co"># probabilità del 32.4% di condanna</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>somma <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> esito, probabilita <span class="kw">in</span> sentenza.items():</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"La probabilità di '</span><span class="sc">{</span>esito<span class="sc">}</span><span class="ss">' è: </span><span class="sc">{</span>probabilita<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    somma <span class="op">=</span> somma <span class="op">+</span> probabilita</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" la somma delle probabilità è pari a "</span>, somma)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>La probabilità di 'Non luogo a procedere' è: 0.128
La probabilità di 'Proscioglimento' è: 0.548
La probabilità di 'Condanna' è: 0.324
 la somma delle probabilità è pari a  1.0</code></pre>
</div>
</div>
</section>
<section id="distribuzioni-di-probabilità" class="level3">
<h3 class="anchored" data-anchor-id="distribuzioni-di-probabilità">Distribuzioni di probabilità</h3>
<p>le distribuzioni di probabilità sono funzioni che descrivono la probabilità di ogni possibile valore di una variabile aleatoria. Ad esempio, la distribuzione di probabilità della variabile aleatoria “sentenza” nel processo penale può essere rappresentata come segue: P(sentenza) = {0.1, 0.1, 0.8}. Nel seguito vedremo alcune distribuzioni di probabilità notevoli.</p>
</section>
<section id="probabilità-congiunta" class="level3">
<h3 class="anchored" data-anchor-id="probabilità-congiunta">Probabilità congiunta</h3>
<p>La probabilità congiunta è la probabilità che due eventi si verifichino contemporaneamente. Ad esempio, la probabilità che un processo penale porti a una condanna e che il condannato sia colpevole è data dalla probabilità congiunta di questi due eventi. Oppure, in ambito medico, la probabilità che un paziente abbia una certa patologia e che il test diagnostico sia positivo è data dalla probabilità congiunta di questi due eventi. Oppure, in ambito metereologico, la probabilità che sia nuvolo e che piova è la probabilità congiunta di questi due eventi:</p>
<p>probabilità che sia nuvoloso:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">nuvoloso</th>
<th style="text-align: center;">¬nuvoloso</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P(n)</td>
<td style="text-align: center;">0,7</td>
<td style="text-align: center;">0,3</td>
</tr>
</tbody>
</table>
<p>probabilità che piova:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">piove</th>
<th style="text-align: center;">¬piove</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">P(p)</td>
<td style="text-align: center;">0,2</td>
<td style="text-align: center;">0,8</td>
</tr>
</tbody>
</table>
<p>probabilità che sia nuvoloso e piova: | P(p,n) | nuvoloso | ¬nuvoloso | | :-: | :-: | :-: | | piove | 0,55 | 0,05 | | ¬piove | 0,15 | 0,25 |</p>
</section>
<section id="indipendenza-delle-variabili-aleatorie" class="level3">
<h3 class="anchored" data-anchor-id="indipendenza-delle-variabili-aleatorie">Indipendenza delle variabili aleatorie</h3>
<p>L’indipendenza di due eventi indica che il verificarsi di uno non influenza il verificarsi dell’altro. Ad esempio: Lancio di due dadi. Il lancio del primo non influenza il secondo; Il contrario, la dipendenza, indica che il verificarsi di uno influenza il verificarsi dell’altro. Nel caso in cui due variabili aleatorie siano indipendenti si ha la seguente proprietà:</p>
<p>P(a “∧” b)=P(a)*P(b)</p>
</section>
<section id="negazione" class="level3">
<h3 class="anchored" data-anchor-id="negazione">Negazione</h3>
<p>La negazione di un evento è l’evento che si verifica quando l’evento originale non si verifica. Ad esempio, la negazione dell’evento “piove” è “non piove”.</p>
<p>Se la probabilità che un evento è α, la probabilità che l’evento non si verifichi è 1 - α.</p>
<p>P(A) = α, allora P(¬A) = 1 - α</p>
</section>
<section id="inclusione" class="level3">
<h3 class="anchored" data-anchor-id="inclusione">Inclusione</h3>
<p>P(a ∨ b) = P(a) + P(b) - P(a ∧ b).</p>
<p>La probabilità che si verifichi l’evento a o l’evento b è uguale alla somma delle probabilità dei due eventi meno la probabilità congiunta. Si noti che se gli eventi sono incompatibili la probabilità congiunta è nulla! image-2.png</p>
</section>
<section id="marginalizzazione" class="level3">
<h3 class="anchored" data-anchor-id="marginalizzazione">Marginalizzazione</h3>
<p>La marginalizzazione è una tecnica utilizzata per calcolare la probabilità di un evento dato un insieme di eventi. Ad esempio, la probabilità che un processo penale porti a una condanna dato che il condannato è colpevole è data dalla marginalizzazione della probabilità congiunta di questi due eventi.</p>
<p>P(a) = P(a, b) + P(a, ¬b).</p>
<p>La probabilità che si verifichi b è disgiunta dalla probabilità che si verifichi ¬b. Quindi, quando si verifica a si ha b oppure ¬b ma non entrambi quindi se sommo le probabilità P(a, b) + P(a, ¬b) ottengo P(a)</p>
</section>
<section id="probabilità-condizionata" class="level3">
<h3 class="anchored" data-anchor-id="probabilità-condizionata">probabilità condizionata</h3>
<p>La probabilità condizionata è la probabilità che un evento si verifichi dato che un altro evento si è verificato. Ad esempio, la probabilità che un processo penale porti a una condanna dato che il sottoposto a giudizio è colpevole è data dalla probabilità condizionata di questi due eventi.</p>
<p>E’ possibile fare inferenze a proposito della probabilità di una proposizione ignota A, data la prova B, calcolando P(A/B) (probabilità di A dato che tutto ciò che sappiamo è B) (inferenza probabilistica)</p>
<p>Un’interrogazione ad un sistema di ragionamento probabilistico chiederà di calcolare il valore di una particolare probabilità condizionata.</p>
<p>Fin qui abbiamo visto casi in cui il singolo evento non era condizionato da altro evento:</p>
<ul>
<li>Prima estrazione del lotto;</li>
<li>Lancio di uno o due dadi</li>
<li>Cosa succede alla probabilità quando l’avverarsi di una proposizione è condizionata all’avverarsi di un’altra proposizione?</li>
</ul>
<p>P(a|b) = probabilità dell’evento a dato che noi sappiamo che l’evento b si è verificato. Oppure, “ la probabilità di a dato b” Possiamo chiederci:</p>
<ul>
<li>Qual’è la probabilità che vinca la “ Roma” se ha vinto la “ Lazio”?, P(Roma/Lazio).</li>
<li>Qual’è la probabilità che arrivi il “38” se è arrivato il “52”?”, P(“38”/”52”).</li>
</ul>
<p>La formula per calcolare la probabilità condizionata di a dato b è la seguente: <span class="math display">\[
P(a/b) =(𝑃(𝑎 ∧ 𝑏) )/(𝑃(𝑏));
\]</span> “siamo interessati agli eventi dove a e b sono vere, ma solo nei mondi dove b è vera!” <span class="math display">\[
P(a ∧ b)=P(b)P(a/b)
\]</span> <span class="math display">\[
P(a ∧ b)=P(b)P(a/b)
\]</span></p>
<section id="sec-CPC-lancio-due-dadi" class="level4">
<h4 class="anchored" data-anchor-id="sec-CPC-lancio-due-dadi">calcolo della probabilità condizionata: lancio di due dadi</h4>
<p>Qual è la probabilità che si ottenga una somma pari 9 lanciando due dadi se il primo dado è 6, P(9/6)? La risposta si ottiene direttamente dalla formula della probabilità condizionata e da quella della probabilità congiunta: p(9/6) = P(9 ∧ 6) / P(6) = 1/36 / 1/6 = 1/6</p>
<p>La proposizione a = «somma=9» si verifica con i seguenti lanci:</p>
<p>a = {(6,3),(5,4),(4,5),(3,6)}  P(a) = 4/36</p>
<p>La proposizione b = «primo dado=6» si verifica con i seguenti lanci:</p>
<p>b = {(6,1),(6,2),(6,3),(6,4),(6,5),(6,6)}  P(b) = 6/36</p>
<p>a “∧” b = {(6,3)}  P(a “∧” b) = 1/36</p>
<p>P(a/b) =(𝑃(𝑎 “∧” 𝑏) )/(𝑃(𝑏))= (1/36)/(6/36)=1/6</p>
<table class="caption-top table">
<caption>Lancio di due dadi</caption>
<colgroup>
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">+</th>
<th style="text-align: right;">1</th>
<th style="text-align: right;">2</th>
<th style="text-align: right;">3</th>
<th style="text-align: right;">4</th>
<th style="text-align: right;">5</th>
<th style="text-align: right;">6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>1</strong></td>
<td style="text-align: right;">2</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>2</strong></td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>3</strong></td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>4</strong></td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>5</strong></td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">11</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>6</strong></td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">11</td>
<td style="text-align: right;">12</td>
</tr>
</tbody>
</table>
<p>Ovvero, per risolvere l’esercizio dobbiamo osservare l’ ultima riga della tabella realtiva al lancio del primo dado con risultato 6. i casi favorevoli sono solo 1, mentre i casi possibili sono 6. Quindi la probabilità è 1/6.</p>
</section>
<section id="sec-CPC-caso-penale" class="level4">
<h4 class="anchored" data-anchor-id="sec-CPC-caso-penale">calcolo della probabilità condizionata: caso penale</h4>
<p>Supponiamo di avere un dataset di 1.000 casi penali. Per ogni caso, raccogliamo le seguenti informazioni:</p>
<ul>
<li><strong>Alibi</strong> del sospettato (Sì/No)</li>
<li><strong>Testimone oculare</strong> presente (Sì/No)</li>
<li><strong>Condanna</strong> del sospettato (Sì/No)</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;">Alibi</th>
<th style="text-align: center;">Testimone Oculare</th>
<th style="text-align: center;">Condanna</th>
<th style="text-align: right;">Numero di Casi</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Sì</td>
<td style="text-align: center;">Sì</td>
<td style="text-align: center;">Sì</td>
<td style="text-align: right;">50</td>
</tr>
<tr class="even">
<td style="text-align: center;">Sì</td>
<td style="text-align: center;">Sì</td>
<td style="text-align: center;">No</td>
<td style="text-align: right;">20</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Sì</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Sì</td>
<td style="text-align: right;">30</td>
</tr>
<tr class="even">
<td style="text-align: center;">Sì</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="odd">
<td style="text-align: center;">No</td>
<td style="text-align: center;">Sì</td>
<td style="text-align: center;">Sì</td>
<td style="text-align: right;">200</td>
</tr>
<tr class="even">
<td style="text-align: center;">No</td>
<td style="text-align: center;">Sì</td>
<td style="text-align: center;">No</td>
<td style="text-align: right;">50</td>
</tr>
<tr class="odd">
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Sì</td>
<td style="text-align: right;">150</td>
</tr>
<tr class="even">
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: right;">400</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>totale</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: right;"><strong>1.000</strong></td>
</tr>
</tbody>
</table>
<p>Questo dataset può essere utilizzato per calcolare varie probabilità condizionate.</p>
<p><strong>Esercizio 2.1: Probabilità di condanna dato che il sospettato non ha un alibi e c’è un testimone oculare.</strong></p>
<ul>
<li><strong>Formula:</strong> <span class="math inline">\(P(\text{Condanna} = \text{Sì} \mid \text{Alibi} = \text{No}, \text{Testimone} = \text{Sì})\)</span></li>
<li><strong>Calcolo:</strong>
<ul>
<li>Numero di casi con Alibi = No, Testimone = Sì, Condanna = Sì: 200</li>
<li>Numero totale di casi con Alibi = No, Testimone = Sì: 200 + 50 = 250</li>
<li><span class="math inline">\(P = \frac{200}{250} = 0{,}8  (80\%)\)</span></li>
</ul></li>
</ul>
<p><strong>Esercizio 2.2: Probabilità che ci sia un testimone oculare dato che il sospettato è stato condannato.</strong></p>
<ul>
<li><strong>Formula:</strong> <span class="math inline">\(P(\text{Testimone} = \text{Sì} \mid \text{Condanna} = \text{Sì})\)</span></li>
<li><strong>Calcolo:</strong>
<ul>
<li>Numero di casi con Testimone = Sì, Condanna = Sì: <span class="math inline">\(50 + 200 = 250\)</span></li>
<li>Numero totale di casi con Condanna = Sì: <span class="math inline">\(50 + 30 + 200 + 150 = 430\)</span></li>
<li><span class="math inline">\(P = \frac{250}{430} \approx 0{,}581  (58,1\%)\)</span></li>
</ul></li>
</ul>
<p><strong>Esercizio 2.3: Probabilità che un sospettato non abbia un alibi dato che non è stato condannato.</strong></p>
<ul>
<li><strong>Formula:</strong> $P( = = ) $</li>
<li><strong>Calcolo:</strong>
<ul>
<li>Numero di casi con Alibi = No, Condanna = No: 50 + 400 = 450</li>
<li>Numero totale di casi con Condanna = No: 20 + 100 + 50 + 400 = 570</li>
<li><span class="math inline">\(P = \frac{450}{570} \approx 0{,}789  (78,9\%)\)</span></li>
</ul></li>
</ul>
<p>Questo dataset consente di esplorare come diverse variabili influenzino le probabilità di determinati esiti nel contesto del diritto penale. Può essere utilizzato per analisi statistiche, studi accademici o simulazioni di casi giudiziari.</p>
</section>
</section>
<section id="condizionamento" class="level3">
<h3 class="anchored" data-anchor-id="condizionamento">Condizionamento</h3>
<p><span class="math display">\[
P(a) = P(a/b)P(b) + P(a/¬b)P(¬b).
\]</span> Il condizionamento discende immediatamente dalla marginalizzazione. La probabilità che si verifichi a è data dalla marginalizzazione della probabilità congiunta di questi due eventi. La probabilità che si verifichi b è disgiunta dalla probabilità che si verifichi ¬b. Quindi, quando si verifica a si ha b oppure ¬b ma non entrambi quindi se sommo le probabilità P(a, b) + P(a, ¬b) ottengo P(a).</p>
<p>Vediamo due esempi di applicazioni della formula di condizionamento in Python, uno nel campo medico e uno nel campo giuridico penale:</p>
<p><strong>Campo medico Supponiamo di avere le seguenti informazioni:</strong></p>
<p>La probabilità che una persona sviluppi un certo effetto collaterale a seguito di un farmaco è <span class="math inline">\(P(Effetto collaterale) = 0.2\)</span>.</p>
<p>Si sa che se una persona sviluppa l’effetto collaterale, la probabilità che abbia assunto il farmaco è <span class="math inline">\(P(Farmaco|Effetto collaterale) = 0.9\)</span>. D’altra parte, se una persona non mostra l’effetto collaterale, la probabilità che abbia comunque assunto il farmaco è <span class="math inline">\(P(Farmaco|¬Effetto collaterale) = 0.1\)</span>. In questo caso, il condizionamento riguarda la probabilità di assunzione del farmaco date le informazioni sull’effetto collaterale senza coinvolgere il teorema di Bayes.</p>
<p>Quindi, la probabilità di assunzione del farmaco è <span class="math display">\[
P(Farmaco) = P(Farmaco|Effetto collaterale)P(Effetto collaterale) + P(Farmaco|¬Effetto collaterale)P(¬Effetto collaterale).
\]</span></p>
<p>la codifica in Python è la seguente:</p>
<div id="cell-40" class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">#definizioni delle probaibilità</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>P_effetto_collaterale <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>P_farmaco_effetto_collaterale <span class="op">=</span> <span class="fl">0.9</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>P_farmaco_non_effetto_collaterale <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>P_farmaco <span class="op">=</span> P_farmaco_effetto_collaterale <span class="op">*</span> P_effetto_collaterale <span class="op">+</span> P_farmaco_non_effetto_collaterale <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> P_effetto_collaterale)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"La probabilità che una pesona abbia assunto il farmaco è : </span><span class="sc">{</span>P_farmaco<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Output atteso :</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>La probabilità che una pesona abbia assunto il farmaco è : <span class="fl">0.26</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Campo Giuridico Penale :</strong></p>
<p>Immaginiamo di avere le seguenti informazioni in un contesto giuridico penale: $P(Condanna con prove schiaccianti) = 0.95 $</p>
<p><span class="math inline">\(P(Condanna senza prove schiaccianti) = 0.2\)</span></p>
<p><span class="math inline">\(P(Prove schiaccianti) = 0.3\)</span></p>
<p>Utilizziamo la formula di condizionamento per calcolare la probabilità di condanna:</p>
<p><span class="math display">\[
P(Condanna) =   P(Condanna con prove schiaccianti)P(Prove schiaccianti) +
                P(Condanna senza prove schiaccianti)(1-P(Prove schiaccianti))
\]</span></p>
<p>La codifica in Python è la seguente:</p>
<div id="cell-42" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>prob_condanna_prove_schiaccianti <span class="op">=</span> <span class="fl">0.95</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>prob_condanna_no_prove_schiaccianti <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>prob_prove_schiaccianti <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>prob_condanna <span class="op">=</span> prob_condanna_prove_schiaccianti <span class="op">*</span> prob_prove_schiaccianti <span class="op">+</span> prob_condanna_no_prove_schiaccianti <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> prob_prove_schiaccianti)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"La probabilità che un imputato sia colpevole dato che ci sono prove schiaccianti è: </span><span class="sc">{</span>prob_condanna<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>La probabilità che un imputato sia colpevole dato che ci sono prove schiaccianti è: 0.42499999999999993</code></pre>
</div>
</div>
<p><strong>Output atteso :</strong></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>La probabilità che un imputato sia colpevole dato che ci sono prove schiaccianti è: <span class="fl">0.42499999999999993</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Questi due esempi illustrano come la formula di condizionamento possa essere applicata in contesti medici e giuridici penali per calcolare probabilità condizionate basate su informazioni specifiche relative agli eventi considerati.</p>
</section>
</section>
<section id="inferenza-bayesiana" class="level2">
<h2 class="anchored" data-anchor-id="inferenza-bayesiana">Inferenza Bayesiana</h2>
<blockquote class="blockquote">
<p>“Mr.&nbsp;Bayes … design … was to find out a method by which we might judge concerning the probability that an event has to happen, in given circumstances, upon supposition that we know nothing concerning it but that, under the same circumstances, it has happened a certain number of times, and failed a certain other number of times.” - (Richard Price, presentando lo scritto dell’amico Thomas Bayes alla Royal Society of London)</p>
</blockquote>
<p>Il Teorema di Bayes, formalizzato dal reverendo Thomas Bayes nel XVIII secolo, è uno strumento fondamentale nell’ambito della statistica e dell’intelligenza artificiale che permette di aggiornare le nostre credenze riguardo ad un’ipotesi sulla base di nuove evidenze. Le tecniche di inferenza basate su questo teorema sono ampiamente utilizzate in diversi campi, dall’analisi dei dati alla diagnostica medica, dalla finanza alla progettazione di algoritmi di machine learning.</p>
<section id="il-teorema-di-bayes" class="level3">
<h3 class="anchored" data-anchor-id="il-teorema-di-bayes">Il Teorema di Bayes</h3>
<p>Il Teorema di Bayes fornisce un modo per calcolare la probabilità condizionata di un’ipotesi data l’evidenza osservata. Formalmente, il teorema può essere espresso come:</p>
<p><span class="math display">\[
P(A|B) = \frac{P(B|A) \cdot P(A)}{P(B)}
\]</span></p>
<p>Dove: - P(A|B) è la probabilità dell’ipotesi A dato l’evidenza B. - P(B|A) è la probabilità dell’evidenza B dato l’ipotesi A. - P(A) è la probabilità a priori dell’ipotesi A. - P(B) è la probabilità dell’evidenza B.</p>
</section>
<section id="applicazioni-pratiche" class="level3">
<h3 class="anchored" data-anchor-id="applicazioni-pratiche">Applicazioni Pratiche</h3>
<p><strong>Diagnostica Medica</strong></p>
<p>Nel campo della diagnostica medica, il Teorema di Bayes è utilizzato per valutare la probabilità che un paziente abbia una certa malattia sulla base dei sintomi presentati e dei risultati dei test di laboratorio. Ad esempio, se la probabilità di un test positivo dato che il paziente ha la malattia e la probabilità che il paziente abbia effettivamente la malattia sono note, il teorema di Bayes può essere impiegato per calcolare la probabilità che il paziente abbia la malattia date le informazioni disponibili.</p>
<p><strong>Finanza</strong></p>
<p>Nel settore finanziario, il Teorema di Bayes viene adoperato per valutare il rischio e formulare previsioni basate su dati storici e informazioni di mercato. Ad esempio, il teorema può essere utilizzato per stimare la probabilità di un evento futuro, come un aumento dei tassi di interesse, sulla base di indicatori economici attuali.</p>
<p><strong>Machine Learning</strong></p>
<p>Nei modelli di machine learning, come le reti bayesiane, il Teorema di Bayes svolge un ruolo chiave nell’aggiornare le probabilità delle variabili all’interno del modello in risposta ai nuovi dati. Questo processo di apprendimento bayesiano consente ai modelli di essere più flessibili ed adattabili all’evoluzione dei dati nel tempo.</p>
<p><strong>diritto penale</strong></p>
<p>Dalle statistiche (false perché inventate da me :) di un certo tribunale o dal Ministero della Giustizia abbiamo che - 80% degli imputati condannati hanno precedenti penali P(precedenti/condanna) = 0,8; - 10% degli imputati sono condannati P(condanna) = 0,1 - 20% degli imputati hanno precedenti penali P(precedenti) = 0,2</p>
<p>Applicando il teorema di Bayes abbiamo che la probabilità che un imputato con precedenti sia condannato è <span class="math display">\[
P(condanna/precedenti) = P(condanna) \cdot \frac{P(precedenti/condanna)}{P(precedenti)} = 0,1 \cdot \frac{0,8}{0,2}= 0,4
\]</span></p>
<p>Si osservi che la probabilità di essere condannati era del 10%. Applicando il teorema di Bayes abbiamo scoperto che la probabilità di essere condannato è del 40% se sappiamo che la persona sottoposta a giudizio ha dei precedenti penali. Ovvero, la probabilità iniziale di essere condannati senza sapere se sono presenti o meno precedenti penali viene moltiplicata per 4 (il cosidetto fattore di Bayes).</p>
<p>Le tecniche di inferenza basate sul Teorema di Bayes forniscono un approccio potente per il ragionamento probabilistico e l’aggiornamento delle credenze in base alle evidenze disponibili. Utilizzate in una vasta gamma di settori, queste tecniche consentono di prendere decisioni informate e di sfruttare al meglio le informazioni a disposizione. La comprensione e l’applicazione corretta del Teorema di Bayes sono cruciali per ottenere risultati accurati e significativi nelle analisi statistiche e nel machine learning.</p>
<section id="sec-TB-caso-penale" class="level4">
<h4 class="anchored" data-anchor-id="sec-TB-caso-penale">Applicazione del Teorema di Bayes: caso penale</h4>
<p>Applicazione del teorema di Bayes al data set del caso pratico <a href="#sec-CPC-caso-penale" class="quarto-xref"><span class="quarto-unresolved-ref">sec-CPC-caso-penale</span></a> il Teorema di Bayes per calcolare la probabilità che un sospettato venga <strong>condannato dato che non ha un alibi</strong>, cioè <span class="math inline">\(P(\text{Condanna} = \text{Sì} \mid \text{Alibi} = \text{No})\)</span>. Questo ci permette di comprendere meglio l’impatto dell’assenza di un alibi sulla probabilità di condanna.</p>
<p><strong>Obiettivo:</strong> Calcolare <span class="math inline">\(P(\text{Condanna} = \text{Sì} \mid \text{Alibi} = \text{No})\)</span>.</p>
<p><strong>Teorema di Bayes:</strong></p>
<p><span class="math display">\[
P(\text{Condanna} = \text{Sì} \mid \text{Alibi} = \text{No}) = \frac{P(\text{Alibi} = \text{No} \mid \text{Condanna} = \text{Sì}) \times P(\text{Condanna} = \text{Sì})}{P(\text{Alibi} = \text{No})}
\]</span></p>
<p><strong>Passo 1:</strong> Calcolare <span class="math inline">\(P(\text{Alibi} = \text{No} \mid \text{Condanna} = \text{Sì})\)</span></p>
<ul>
<li><p><strong>Numero totale di casi con Condanna = Sì:</strong><br>
<span class="math inline">\(50 + 30 + 200 + 150 = 430\)</span> casi.</p></li>
<li><p><strong>Numero di casi con Alibi = No e Condanna = Sì:</strong><br>
<span class="math inline">\(200 + 150 = 350\)</span> casi.</p></li>
<li><p><strong>Calcolo:</strong><br>
<span class="math display">\[
P(\text{Alibi} = \text{No} \mid \text{Condanna} = \text{Sì}) = \frac{350}{430} \approx 0{,}8139 \ (81{,}39\%)
\]</span></p></li>
</ul>
<p><strong>Passo 2:</strong> Calcolare $ P( = )$</p>
<ul>
<li><p><strong>Numero totale di casi con Condanna = Sì:</strong> $ 430 $ (come sopra).</p></li>
<li><p><strong>Numero totale di casi:</strong> <span class="math inline">\(1.000\)</span>.</p></li>
<li><p><strong>Calcolo:</strong><br>
<span class="math display">\[
P(\text{Condanna} = \text{Sì}) = \frac{430}{1.000} = 0{,}43 \ (43\%)
\]</span></p></li>
</ul>
<p><strong>Passo 3:</strong> Calcolare <span class="math inline">\(P(\text{Alibi} = \text{No})\)</span></p>
<ul>
<li><p><strong>Numero totale di casi con Alibi = No:</strong><br>
<span class="math inline">\(200 + 50 + 150 + 400 = 800\)</span> casi.</p></li>
<li><p><strong>Numero totale di casi:</strong> <span class="math inline">\(1.000\)</span>.</p></li>
<li><p><strong>Calcolo:</strong><br>
<span class="math display">\[
P(\text{Alibi} = \text{No}) = \frac{800}{1.000} = 0{,}8 \ (80\%)
\]</span></p></li>
</ul>
<p><strong>Passo 4: Applicare il Teorema di Bayes</strong></p>
<p><span class="math display">\[
P(\text{Condanna} = \text{Sì} \mid \text{Alibi} = \text{No}) = \frac{0{,}8139 \times 0{,}43}{0{,}8} = \frac{0{,}349977}{0{,}8} = 0{,}4375 \ (43{,}75\%)
\]</span></p>
<p><strong>Risultato:</strong></p>
<p>La probabilità che un sospettato venga <strong>condannato dato che non ha un alibi</strong> è circa <strong>43,75%</strong>.</p>
<hr>
<p><strong>Verifica Diretta dai Dati del Dataset</strong></p>
<p>Per confermare il risultato, possiamo calcolare direttamente <span class="math inline">\(P(\text{Condanna} = \text{Sì} \mid \text{Alibi} = \text{No})\)</span>:</p>
<ul>
<li><p><strong>Numero di casi con Alibi = No:</strong> <span class="math inline">\(800\)</span> (come calcolato sopra).</p></li>
<li><p><strong>Numero di casi con Alibi = No e Condanna = Sì:</strong> <span class="math inline">\(200 + 150 = 350\)</span>.</p></li>
<li><p><strong>Calcolo diretto:</strong><br>
<span class="math display">\[
P(\text{Condanna} = \text{Sì} \mid \text{Alibi} = \text{No}) = \frac{350}{800} = 0{,}4375 \ (43{,}75\%)
\]</span></p></li>
</ul>
<p>Il risultato conferma il calcolo effettuato tramite il Teorema di Bayes. Questo risultato indica che, secondo i dati del dataset:</p>
<ul>
<li><p><strong>Se un sospettato non ha un alibi</strong>, ha una probabilità del <strong>43,75%</strong> di essere condannato.</p></li>
<li><p>L’assenza di un alibi non aumenta significativamente la probabilità di condanna rispetto alla probabilità generale di condanna nel dataset, che è del <strong>43%</strong>.</p></li>
<li><p><strong>Importanza dell’Alibi:</strong> In questo dadaset, l’alibi non sembra essere un fattore importante nel determinare l’esito di un caso. Avere un alibi può ridurre la probabilità di condanna.</p></li>
<li><p><strong>Utilizzo del Teorema di Bayes:</strong> Questo esempio illustra come il Teorema di Bayes possa essere utilizzato per aggiornare le probabilità in base a informazioni nuove o specifiche, nel contesto del diritto penale.</p></li>
</ul>
</section>
</section>
<section id="reti-di-bayes" class="level3">
<h3 class="anchored" data-anchor-id="reti-di-bayes">reti di Bayes</h3>
<p>Una&nbsp;<a href="https://it.wikipedia.org/wiki/Rete_bayesiana">rete bayesiana</a>&nbsp;(BN,&nbsp;Bayesian network) è un modello grafico probabilistico che rappresenta un insieme di variabili stocastiche con le loro dipendenze condizionali attraverso l’uso di un&nbsp;<a href="https://it.wikipedia.org/wiki/Grafo_aciclico_diretto">grafo aciclico diretto&nbsp;(DAG)</a> . Per esempio una rete Bayesiana potrebbe rappresentare la relazione probabilistica esistente tra i sintomi e le malattie. Dati i sintomi, la rete può essere usata per calcolare la probabilità della presenza di diverse malattie. Le reti Bayesiane sono Grafi diretti. Ogni nodo rappresenta una variabile aleatoria e ogni freccia da X a Y indica che X è un genitore di Y. Ovvero, indica che la distribuzione probabilistica di Y dipende da X. Ogni nodo ha la distribuzione probabilistica P(X | Genitori(X)). Vediamo un esempio sui mezzi di trasporto (:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rete di Bayes treno.png" class="img-fluid figure-img"></p>
<figcaption>Rete di Bayes puntualità treno</figcaption>
</figure>
</div>
<p><a href="https://colab.research.google.com/github/capitanio/laboratorio-ia/blob/main/2 Rete Bayesiana treno.ipynb" target="_blank" rel="noopener noreferrer"><img align="left" src="https://colab.research.google.com/assets/colab-badge.svg" alt="Esegui in Colab" title="Apri e esegui in Google Colaboratory">Rete Bayesiana treno.ipynb</a> <br></p>
<p>(click-ando su questo pulsante aprirete il quaderno all’interno di COLAB di Google dove potrete eseguire il quaderno online senza bisogno di avere un ambiente Python sulla vostra macchina.)</p>
<p>Una rete bayesiana (di credenza) richiede che ogni nodo del grafo sia condizionatamente indipendente da qualsiasi sottoinsieme di nodi che non siano discendenti dei predecessori diretti del nodo stesso. Ci si affida ad un esperto di dominio per la definizione della topologia della rete di credenze (quali nodi e quali relazioni condizionali di dipendenza), poi si calcolano le influenze dirette e le conseguenti probabilità. Ciò equivale a definire la conoscenza del mondo in cui può avvenire un evento. Ovvero, la rete rappresenta le assunzioni che si possono fare su quel dominio. Le probabilità condizionate tra i nodi riassumono un insieme potenzialmente infinito di circostanze a noi ignote e che potrebbero influenzare l’evento. La topologia della rete è la base di conoscenza generale ed astratta dell’ambiente in cui si possono verificare gli eventi e rappresenta la struttura generale del processo causale nel dominio, piuttosto che fornire dettagli su un particolare elemento. Nelle reti bayesiane gli archi che connettono i nodi esprimono le relazioni causali dirette (causa -&gt; effetto). Una volta definita la topologia bisogna specificare la tabella delle probabilità condizionate associata ad ogni nodo. Ogni riga della tabella esprime la probabilità del valore di ogni nodo per un caso condizionante (combinazione di valori dei nodi genitori produttoria delle prob. condiz.) Un nodo con nessun genitore è rappresentato dalla probabilità a priori.</p>
<section id="esempio-di-rete-bayesiana-indagine-criminale" class="level4">
<h4 class="anchored" data-anchor-id="esempio-di-rete-bayesiana-indagine-criminale">Esempio di rete bayesiana: indagine criminale</h4>
<p><a href="https://colab.research.google.com/github/capitanio/laboratorio-ia/blob/main/2 Rete Bayesiana indagine criminale.ipynb" target="_blank" rel="noopener noreferrer"><img align="left" src="https://colab.research.google.com/assets/colab-badge.svg" alt="Esegui in Colab" title="Apri e esegui in Google Colaboratory"></a> <br></p>
<p>(click-ando su questo pulsante aprirete il quaderno all’interno di COLAB di Google dove potrete eseguire il quaderno online senza bisogno di avere un ambiente Python sulla vostra macchina.)</p>
<p>Scriviamo il codice Python necessario per creare un modello di Rete Bayesiana per analizzare la probabilità di colpevolezza di un sospetto in un’indagine criminale. Il modello considera tre elementi di prova: la presenza di un’arma (Arma), un movente (Movente) e un alibi (Alibi), e come questi influenzano la probabilità di colpevolezza (Colpevolezza).</p>
<p>Il codice non richiederà input diretti dall’utente. Invece, definisce la struttura della Rete Bayesiana e imposta le tabelle di probabilità per ciascun fattore basate su valori predefiniti che dovrebbero essere estrapolati da statistiche sulle indagini criminali.</p>
<p><strong><em>Descrizione del codice</em></strong></p>
<p>L’output di questo codice è: - un modello di Rete Bayesiana verificato; - la stampa del modello; - la stampa delle Distribuzioni di Probabilità Condizionata (CPD) per ogni variabile nella rete; - il grafo della rete Bayesiana.</p>
<p>Inizialmente, definiamo la struttura della Rete Bayesiana, mostrando come i fattori di prova (Arma, Movente, Alibi) influenzano la colpevolezza (Colpevolezza). Quindi, definiamo le tabelle di probabilità per ciascun fattore. Ad esempio, la probabilità che un’arma sia presente sia presente sul luogo del delitto la poniamo pari al 70% (0.7) e la sua assenza al 30% (0.3). Più complessa è la definizione della tabella di probabilità per la colpevolezza, che considera tutte le possibili combinazioni dei fattori di prova. Tutte queste tabelle sono aggiunte al modello di Rete Bayesiana. Infine, verifichiamo se il modello è definito correttamente e stampiamo tutte le distribuzioni di probabilità.</p>
<p>La logica chiave in questo codice è come esso rappresenta le relazioni tra diversi elementi di prova e la colpevolezza. Ad esempio, la presenza di un’arma, un movente e la mancanza di un alibi aumenterebbero la probabilità di colpevolezza, mentre la loro assenza la diminuirebbe. Questo è riflesso nella tabella di probabilità per ‘Colpevolezza’, che considera tutte le possibili combinazioni di prove:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Arma</th>
<th>Motive</th>
<th>Alibi</th>
<th>P(Non Colpevole)</th>
<th>P(Colpevole)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.1</td>
<td>0.9</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>1</td>
<td>0.2</td>
<td>0.8</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0.3</td>
<td>0.7</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td>0.4</td>
<td>0.6</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>0.5</td>
<td>0.5</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>0.6</td>
<td>0.4</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>0</td>
<td>0.7</td>
<td>0.3</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td>0.8</td>
<td>0.2</td>
</tr>
</tbody>
</table>
<p>In questa tabella:</p>
<p>0 rappresenta l’assenza (di arma, movente o alibi) 1 rappresenta la presenza Le ultime due colonne mostrano le probabilità di non colpevolezza e colpevolezza per ogni combinazione di evidenze</p>
<p>Questa Rete Bayesiana può essere utilizzata per calcolare la probabilità di colpevolezza dato uno scenario di prove, aiutando gli investigatori a quantificare e ragionare sull’incertezza nei casi criminali.</p>
<div id="cell-48" class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pgmpy.models <span class="im">import</span> BayesianNetwork</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pgmpy.factors.discrete <span class="im">import</span> TabularCPD</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Definizione del modello</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> BayesianNetwork([(<span class="st">'Arma'</span>, <span class="st">'Colpevolezza'</span>),</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>                       (<span class="st">'Movente'</span>, <span class="st">'Colpevolezza'</span>),</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                       (<span class="st">'Alibi'</span>, <span class="st">'Colpevolezza'</span>)])</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Definizione delle probabilità condizionate</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>cpd_arma <span class="op">=</span> TabularCPD(variable<span class="op">=</span><span class="st">'Arma'</span>, variable_card<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>                      values<span class="op">=</span>[[<span class="fl">0.7</span>], [<span class="fl">0.3</span>]])</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>cpd_Movente <span class="op">=</span> TabularCPD(variable<span class="op">=</span><span class="st">'Movente'</span>, variable_card<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>                        values<span class="op">=</span>[[<span class="fl">0.6</span>], [<span class="fl">0.4</span>]])</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>cpd_alibi <span class="op">=</span> TabularCPD(variable<span class="op">=</span><span class="st">'Alibi'</span>, variable_card<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>                       values<span class="op">=</span>[[<span class="fl">0.5</span>], [<span class="fl">0.5</span>]])</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>cpd_colpevolezza <span class="op">=</span> TabularCPD(variable<span class="op">=</span><span class="st">'Colpevolezza'</span>, variable_card<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>                              values<span class="op">=</span>[[<span class="fl">0.9</span>, <span class="fl">0.7</span>, <span class="fl">0.6</span>, <span class="fl">0.4</span>, <span class="fl">0.6</span>, <span class="fl">0.4</span>, <span class="fl">0.3</span>, <span class="fl">0.1</span>],</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>                                      [<span class="fl">0.1</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>, <span class="fl">0.6</span>, <span class="fl">0.4</span>, <span class="fl">0.6</span>, <span class="fl">0.7</span>, <span class="fl">0.9</span>]],</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>                              evidence<span class="op">=</span>[<span class="st">'Arma'</span>, <span class="st">'Movente'</span>, <span class="st">'Alibi'</span>],</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>                              evidence_card<span class="op">=</span>[<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>])</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a><span class="co"># cpd_colpevolezza = TabularCPD(variable='Colpevolezza', variable_card=2,</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a><span class="co">#                               values=[[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a><span class="co">#                                       [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]],</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a><span class="co">#                               evidence=['Arma', 'Movente', 'Alibi'],</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a><span class="co">#                               evidence_card=[2, 2, 2])</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Aggiunta delle probabilità condizionate al modello</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>model.add_cpds(cpd_arma, cpd_Movente, cpd_alibi, cpd_colpevolezza)</span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Verifica del modello</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Il modello è corretto: "</span>, model.check_model())</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Stampa del modello</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> cpd <span class="kw">in</span> model.get_cpds():</span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"CPD di </span><span class="sc">{variable}</span><span class="st">:"</span>.<span class="bu">format</span>(variable<span class="op">=</span>cpd.variable))</span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(cpd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Il modello è corretto:  True
CPD di Arma:
+---------+-----+
| Arma(0) | 0.7 |
+---------+-----+
| Arma(1) | 0.3 |
+---------+-----+
CPD di Movente:
+------------+-----+
| Movente(0) | 0.6 |
+------------+-----+
| Movente(1) | 0.4 |
+------------+-----+
CPD di Alibi:
+----------+-----+
| Alibi(0) | 0.5 |
+----------+-----+
| Alibi(1) | 0.5 |
+----------+-----+
CPD di Colpevolezza:
+-----------------+------------+-----+------------+------------+
| Arma            | Arma(0)    | ... | Arma(1)    | Arma(1)    |
+-----------------+------------+-----+------------+------------+
| Movente         | Movente(0) | ... | Movente(1) | Movente(1) |
+-----------------+------------+-----+------------+------------+
| Alibi           | Alibi(0)   | ... | Alibi(0)   | Alibi(1)   |
+-----------------+------------+-----+------------+------------+
| Colpevolezza(0) | 0.9        | ... | 0.3        | 0.1        |
+-----------------+------------+-----+------------+------------+
| Colpevolezza(1) | 0.1        | ... | 0.7        | 0.9        |
+-----------------+------------+-----+------------+------------+</code></pre>
</div>
</div>
<div id="cell-49" class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> networkx <span class="im">as</span> nx</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Assumendo che 'model' sia il tuo BayesianNetwork già definito</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> nx.DiGraph()</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>G.add_edges_from(model.edges())</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> nx.spring_layout(G)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>nx.draw(G, pos, with_labels<span class="op">=</span><span class="va">True</span>, node_color<span class="op">=</span><span class="st">'lightblue'</span>,</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        node_size<span class="op">=</span><span class="dv">3000</span>, arrowsize<span class="op">=</span><span class="dv">20</span>, font_size<span class="op">=</span><span class="dv">12</span>, font_weight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Rete di Bayes per l'Analisi della Colpevolezza"</span>)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="2 algoritmi_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Infine, una volta costruita la rete di Bayes possiamo interrogarla per avere una stima della probabilità di un determinato evento. Qual è la probabiltà che un indagato senza alibi, senza movente e in assenza di arma del delitto sia colpevole?</p>
<div id="cell-51" class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pgmpy.inference <span class="im">import</span> VariableElimination</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Creiamo un oggetto per l'inferenza</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>inference <span class="op">=</span> VariableElimination(model)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Definiamo l'evidenza per la situazione descritta</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>evidence <span class="op">=</span> {</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Alibi'</span>: <span class="dv">0</span>,  <span class="co"># 0 rappresenta l'assenza di alibi</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Movente'</span>: <span class="dv">0</span>, <span class="co"># 0 rappresenta l'assenza di motivo</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Arma'</span>: <span class="dv">0</span>    <span class="co"># 0 rappresenta che l'arma non è stata trovata</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcoliamo la probabilità di colpevolezza dato l'evidenza</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> inference.query([<span class="st">'Colpevolezza'</span>], evidence<span class="op">=</span>evidence)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Stampiamo il risultato</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Probabilità di colpevolezza:"</span>)</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result.values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Probabilità di colpevolezza:
[0.9 0.1]</code></pre>
</div>
</div>
<div id="cell-52" class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pgmpy.inference <span class="im">import</span> VariableElimination</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Creiamo un oggetto per l'inferenza</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>inference <span class="op">=</span> VariableElimination(model)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Definiamo l'evidenza per la situazione descritta</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>evidence <span class="op">=</span> {</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Alibi'</span>: <span class="dv">1</span>,  <span class="co"># 0 rappresenta l'assenza di alibi</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Movente'</span>: <span class="dv">0</span>, <span class="co"># 0 rappresenta l'assenza di motivo</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Arma'</span>: <span class="dv">0</span>    <span class="co"># 0 rappresenta che l'arma non è stata trovata</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcoliamo la probabilità di colpevolezza dato l'evidenza</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> inference.query([<span class="st">'Colpevolezza'</span>], evidence<span class="op">=</span>evidence)</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Stampiamo il risultato</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Probabilità di colpevolezza:"</span>)</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result.values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Probabilità di colpevolezza:
[0.7 0.3]</code></pre>
</div>
</div>
</section>
</section>
</section>
<section id="algoritmi-di-ricerca" class="level2">
<h2 class="anchored" data-anchor-id="algoritmi-di-ricerca">Algoritmi di Ricerca</h2>
<p>Gli algoritmi di ricerca sono utilizzati per esplorare spazi di soluzione vasti e complessi. Nel contesto legale, possono essere utilizzati per trovare precedenti giuridici o per esplorare possibili risultati di un caso. In generale, i problemi di ricerca coinvolgono un agente a cui viene assegnato uno stato iniziale e uno stato obiettivo e restituisce una soluzione su come passare dal primo al secondo.</p>
<p>Gli algoritmi di ricerca sono usati in molte applicazioni della intelligenza artificiale, tra cui:</p>
<ul>
<li><strong>Problemi di pianificazione</strong>: trovare una sequenza di azioni per raggiungere un obiettivo.</li>
<li><strong>Risoluzione di puzzle e giochi</strong>: come il cubo di Rubik, gli scacchi o il gioco del 15.</li>
<li><strong>Navigazione e percorsi</strong>: trovare il percorso migliore in mappe o reti stradali.</li>
<li><strong>Ottimizzazione di processi</strong>: trovare la configurazione ottimale in problemi complessi.</li>
<li><strong>Scheduling</strong>: organizzare attività o risorse in modo efficiente.</li>
<li><strong>Riconoscimento di pattern</strong>: identificare strutture o sequenze in dati complessi.</li>
<li><strong>Diagnosi medica</strong>: identificare possibili malattie basandosi su sintomi.</li>
<li><strong>Elaborazione del linguaggio naturale</strong>: analisi sintattica e semantica.</li>
<li><strong>Visione artificiale</strong>: riconoscimento di oggetti e scene in immagini.</li>
<li><strong>Robotica</strong>: pianificazione del movimento e navigazione autonoma.</li>
</ul>
<p>Questi algoritmi sono versatili e possono essere adattati a molti altri domini, rendendo la ricerca un’area fondamentale dell’intelligenza artificiale.</p>
<section id="glossario-della-ricerca" class="level3">
<h3 class="anchored" data-anchor-id="glossario-della-ricerca">Glossario della ricerca</h3>
<ul>
<li><strong>agente</strong>: Una entità che percepisce e agisce nel suo ambiente.</li>
<li><strong>stato</strong>: Una configurazione di un agente nel suo ambiente.</li>
<li><strong>stato iniziale</strong>: Lo stato iniziale di un agente.</li>
<li><strong>stato finale</strong>: Lo stato obiettivo di un agente.</li>
<li><strong>azioni</strong>: Le azioni che un agente può eseguire da un determinato stato</li>
<li><strong>modello di transizione di stato</strong>: Un modello che descrive come un agente può cambiare lo stato in seguito a un’azione.</li>
<li><strong>spazio degli stati</strong>: L’insieme di tutti gli stati raggiungibili da uno stato iniziale.</li>
<li><strong>costo</strong> di un cammino o percorso: La somma dei costi delle azioni lungo un percorso.</li>
<li><strong>soluzione</strong>: Un percorso che porta da uno stato iniziale a uno stato finale. Se ha un costo minimo, è una soluzpoon ottima.</li>
<li><strong>algoritmo di ricerca</strong>: Un algoritmo che cerca di trovare una soluzione.</li>
</ul>
</section>
<section id="problemi-di-ricerca" class="level3">
<h3 class="anchored" data-anchor-id="problemi-di-ricerca">Problemi di ricerca</h3>
<p>I problemi che si possono affrontare con gli algoritmi di ricerca sono generalmente caratterizzati da una struttura specifica:</p>
<ol type="1">
<li><strong>Stato iniziale</strong>: Questo rappresenta la condizione o la configurazione di partenza del problema.</li>
<li><strong>Azioni o operatori</strong>: Questi rappresentano le possibili mosse o le transizioni che possono essere effettuate a partire da uno stato.</li>
<li><strong>Test obiettivo (goal test)</strong>: Questo è un criterio che determina se uno stato specifico risolve il problema.</li>
<li><strong>Funzione costo</strong>: Questa associa un costo a ogni operatore o azione. Il costo può rappresentare, ad esempio, il tempo, lo sforzo o le risorse necessarie per eseguire un’azione.</li>
</ol>
<p>A seconda della natura del problema, lo stato iniziale può essere un singolo stato o un insieme di stati. Inoltre, i problemi possono essere classificati in base alla conoscenza che l’agente ha sullo stato in cui si trova e sulle azioni.</p>
<p>Una volta definito il problema in questi termini, l’algoritmo di ricerca può essere utilizzato per esplorare lo spazio degli stati e trovare una soluzione, che è una sequenza di azioni che porta dallo stato iniziale a uno stato che soddisfa il test obiettivo¹.</p>
<p><strong>esempio di problema di ricerca</strong></p>
<p>Un esempio classico di problema che segue questa struttura: il problema del commesso viaggiatore (<a href="[https://](https://it.wikipedia.org/wiki/Problema_del_commesso_viaggiatore)">Travelling Salesman Problem</a>, TSP).</p>
<p>Dato un insieme di città, e note le distanze tra ciascuna coppia di esse, trovare il tragitto di minima percorrenza che un commesso viaggiatore deve seguire per visitare tutte le città una ed una sola volta e ritornare alla città di partenza</p>
<ol type="1">
<li><p><strong>Stato iniziale</strong>: Il commesso viaggiatore si trova in una città specifica (ad esempio, Roma) e deve visitare tutte le altre città una sola volta e tornare alla città di partenza.</p></li>
<li><p><strong>Azioni o operatori</strong>: Il commesso viaggiatore può scegliere di viaggiare da una città all’altra. Ogni possibile percorso da una città all’altra rappresenta un’azione.</p></li>
<li><p><strong>Test obiettivo (goal test)</strong>: Il test obiettivo verifica se tutte le città sono state visitate una sola volta e se il commesso viaggiatore è tornato alla città di partenza.</p></li>
<li><p><strong>Funzione costo</strong>: Il costo di un percorso può essere la distanza totale percorsa o il tempo totale impiegato per il viaggio.</p></li>
</ol>
<p>L’obiettivo del problema del commesso viaggiatore è trovare il percorso più breve (o il percorso che minimizza il tempo di viaggio) che visita tutte le città una sola volta e ritorna alla città di partenza. Gli algoritmi di ricerca possono essere utilizzati per esplorare lo spazio degli stati (cioè, tutti i possibili percorsi) e trovare la soluzione ottimale.</p>
</section>
<section id="algoritmo-generale-di-ricerca" class="level3">
<h3 class="anchored" data-anchor-id="algoritmo-generale-di-ricerca">Algoritmo “generale” di ricerca</h3>
<p>In ogni istante l’agente si troverà davanti un insieme di stati possibili da esplorare. Questo insieme di stati è noto come la «frontiera» (Come nel far west :). Abbiamo bisogno di una struttura dati in grado di contenere gli stati della frontiera che l’agente può esplorare.Vedremo almeno due implementazioni. Lo pseudocodice dell’algoritmo “generale” di ricerca è il seguente:</p>
<pre><code>1 Se la Frontiera è vuota, Finito!.&nbsp;Si tratta di un problema insolubile!.
2 Rimuovi un nodo dalla frontiera e consideralo come candidato.
3    Se il nodo contiene lo stato finale, Restituisci la soluzione. Finito!
4    Altrimenti
5        Cerca tutti i nodi raggiungibili dal nodo corrente e aggiungili alla frontiera.
6        Aggiungi il nodo corrente all’insieme dei nodi visitati.
7 Torna al passo 1.</code></pre>
<p>L’algoritmo di ricerca generale è un approccio generale per risolvere problemi di ricerca. Nella descrizione di questo algoritmo è stato omesso un passo fondamentale: come si fa a scegliere il nodo da rimuovere dalla frontiera? La scelta del nodo da rimuovere dalla frontiera è un passo cruciale nell’algoritmo di ricerca. Questa scelta è basata su una strategia di ricerca, che determina l’ordine in cui i nodi vengono esplorati. L’implementazione della frontierà è quindi legata alla strategia di ricerca. Le struttre dati usate per la frontiera sono le seguenti:</p>
<ul>
<li><strong>Stack</strong>: L’ultimo nodo inserito è il primo estratto (LIFO = Last In First Out) –&gt; Algoritmo Depth First search (<strong>DFS</strong>)</li>
<li><strong>Queue</strong>: Il primo nodo inserito è il primo estratto (FIFO = First In First Out) –&gt; Algoritmo Breadth First Search (<strong>BFS</strong>)</li>
<li><strong>Priority Queue</strong>: Il nodo con il valore di prirità più alto è il primo estratto –&gt; Algoritmo Best First Search (<strong>BFS</strong>)</li>
<li><strong>Set</strong>: L’elemento con il valore di costo più basso è il primo estratto –&gt; Algoritmo A* (<strong>A*</strong>)</li>
</ul>
<pre><code>def ricerca_generale(problema, strategia):
    frontiera = Strategia(problema)
    while not frontiera.vuota():
        nodo = frontiera.rimuovi_nodo()
        if problema.test_obiettivo(nodo.stato):
            return nodo
        frontiera.aggiungi_nodi(nodo.genera_successori())
    return None</code></pre>
</section>
<section id="strategie-di-ricerca-non-informate" class="level3">
<h3 class="anchored" data-anchor-id="strategie-di-ricerca-non-informate">Strategie di ricerca non informate</h3>
<blockquote class="blockquote">
<p>Nelle strategie di ricerca non informate l’agente non vede e non sente se non il proprio stato.</p>
</blockquote>
<p>Le strategie di ricerca non informate sono un tipo di algoritmo di ricerca che non utilizza alcuna conoscenza specifica o informazione aggiuntiva sul problema da risolvere. Questi algoritmi utilizzano solo la struttura del problema e la definizione di stato e azione per esplorare lo spazio degli stati. Esempi di strategie di ricerca non informate:</p>
<ol type="1">
<li><strong>Ricerca in profondità (Depth-First Search, DFS)</strong>: Questa strategia esplora lo spazio degli stati andando in profondità prima di esplorare i nodi adiacenti. È una strategia ricorsiva che inizia dallo stato iniziale e procede fino a quando non raggiunge uno stato finale o non può più espandere ulteriormente.</li>
<li><strong>Ricerca in ampiezza (Breadth-First Search, BFS)</strong>: Questa strategia esplora lo spazio degli stati espandendo prima i nodi adiacenti allo stato iniziale, quindi i nodi adiacenti ai nodi adiacenti, e così via. È una strategia che esplora lo spazio degli stati in modo uniforme, garantendo che vengano esplorati prima i nodi più vicini allo stato iniziale.</li>
<li>…</li>
</ol>
<section id="ricerca-in-profondità-depth-first-search-dfs" class="level4">
<h4 class="anchored" data-anchor-id="ricerca-in-profondità-depth-first-search-dfs">Ricerca in profondità (Depth-First Search, DFS)</h4>
<p>La ricerca in profondità (Depth-First Search, DFS) è una strategia di ricerca che esplora lo spazio degli stati andando in profondità prima di esplorare i nodi adiacenti. È una strategia ricorsiva che inizia dallo stato iniziale e procede fino a quando non raggiunge uno stato finale o non può più espandere ulteriormente. Questo algoritmo si basa sull’adozione di una struttura dati a coda per implementare la frontiera. ::: {.content-visible when-format=“html”} <img src="https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif" class="img-fluid" alt="Depth-First Search, DFS"> ::: ::: {.content-visible when-format=“pdf”} <img src="https://upload.wikimedia.org/wikipedia/commons/1/1f/Depth-first-tree.svg" class="img-fluid" alt="Depth-First Search, DFS"> ::: #### Ricerca in ampiezza (Breadth-First Search, BFS) La ricerca in ampiezza (Breadth-First Search, BFS) è una strategia di ricerca che esplora lo spazio degli stati espandendo prima i nodi adiacenti allo stato iniziale, quindi i nodi adiacenti ai nodi adiacenti, e così via. È una strategia che esplora lo spazio degli stati in modo uniforme, garantendo che vengano esplorati prima i nodi più vicini allo stato iniziale. Questo algoritmo si basa sull’adozione di una struttura dati a pila per implementare la frontiera. ::: {.content-visible when-format=“html”} <img src="https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif" class="img-fluid" alt="Breadth-First Search, BFS"> ::: ::: {.content-visible when-format=“pdf”} <img src="https://upload.wikimedia.org/wikipedia/commons/3/33/Breadth-first-tree.svg" class="img-fluid" alt="Breadth-First Search, BFS"> :::</p>
</section>
<section id="dfs-e-bfs-in-python" class="level4">
<h4 class="anchored" data-anchor-id="dfs-e-bfs-in-python">DFS e BFS in Python</h4>
<p>Usando l’algoritmo generico di ricerca che abbiamo visto fin qui si possono risolvere diversi problemi. Ad esempio, con l’agente AI fin qui sviluppata possiamo risolvere il problema di trovare il percorso in un labirinto. Per fare questo dobbiamo solo codificare lo spazio degli stati di questo problema e applicare la nostra AI a qualche caso reale.</p>
<p><strong>struttura dati per i nodi</strong></p>
<p>La struttura dati per memorizzare il generico nodo del grafo dei possibili stati è</p>
<div id="cell-54" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Nodo():</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, stato, genitore, azione):</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stato <span class="op">=</span> stato</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.genitore <span class="op">=</span> genitore</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.azione <span class="op">=</span> azione</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Struttura dati per la frontiera</strong></p>
<p>L’altra struttura dati di cui abbiamo bisogno è una struttura dati per la Frontiera. Come abbiamo visto ci sono due tipo di struttura dati che possiamo usare per la frontiera.</p>
<ul>
<li>Struttura dati “pila” per la frontiera Depth First Search (DFS). La pila è una struttura dati che adotta una logica Last In First Out (l’ultimo a entrare è il primo ad uscire come accade per una pila, appunto, di piatti :)</li>
<li>Struttura dati “coda” per la frontiera Breadth First Search (BFS). La coda è una struttura dati che adotta una logica First In First Out (l’elemento che entra per primo è l’elemento che esce per primo come accade nella coda ad uno sportello :)</li>
</ul>
<div id="cell-56" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FrontieraPila():</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.frontiera <span class="op">=</span> []</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> aggiungiStato(<span class="va">self</span>, nodo):</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.frontiera.append(nodo)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> contieneStato(<span class="va">self</span>, stato):</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">any</span>(nodo.stato <span class="op">==</span> stato <span class="cf">for</span> nodo <span class="kw">in</span> <span class="va">self</span>.frontiera)</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> eVuota(<span class="va">self</span>):</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(<span class="va">self</span>.frontiera) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rimuoviStato(<span class="va">self</span>):</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.eVuota():</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Frontiera vuota"</span>)</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>            nodo <span class="op">=</span> <span class="va">self</span>.frontiera[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.frontiera <span class="op">=</span> <span class="va">self</span>.frontiera[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> nodo</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FrontieraCoda(FrontieraPila):</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rimuoviStato(<span class="va">self</span>):</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.eVuota():</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Frontiera vuota"</span>)</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>            nodo <span class="op">=</span> <span class="va">self</span>.frontiera[<span class="dv">0</span>]</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.frontiera <span class="op">=</span> <span class="va">self</span>.frontiera[<span class="dv">1</span>:]</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> nodo</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Possiamo valutare il funzionamento delle due strutture dati introdptte con una semplice simulazione. Memorizziamo 3 stati A,B e C nelle due strutture dati e osserviamo quale stato è estratto dal metodo rimuoviStato:</p>
<div id="cell-58" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>pila <span class="op">=</span> FrontieraPila()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>pila.aggiungiStato(<span class="st">"A"</span>) <span class="co"># pila = ["A"]</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>pila.aggiungiStato(<span class="st">"B"</span>) <span class="co"># pila = ["A", "B"]</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>pila.aggiungiStato(<span class="st">"C"</span>) <span class="co"># pila = ["A", "B", "C"]</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>pila.rimuoviStato()     <span class="co"># pila = ["A", "B"]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>'C'</code></pre>
</div>
</div>
<div id="cell-59" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>coda <span class="op">=</span> FrontieraCoda()</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>coda.aggiungiStato(<span class="st">"A"</span>) <span class="co"># coda = ["A"]</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>coda.aggiungiStato(<span class="st">"B"</span>) <span class="co"># coda = ["A", "B"]</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>coda.aggiungiStato(<span class="st">"C"</span>) <span class="co"># coda = ["A", "B", "C"]</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>coda.rimuoviStato() <span class="co"># coda = ["B", "C"]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>'A'</code></pre>
</div>
</div>
<p>Per descrivere un labirinto useremo un semplice formato testuale come il seguente:</p>
<pre><code>#####B#
##### #
A     #
#### ##
     ##
#######</code></pre>
<p>Dove il simbolo # rappresenta una parete, il simbolo A un punto di partenza, il simbolo B un punto di arrivo e lo spazio una cella libera. Il labirinto sarà memorizzato in un file testuale (.txt) e sarà “passato” al risolutore di labirinti. La classe Python che si definirà qui di seguito si occupa del caricamento del labirinto da file di tipo testuale, della sua rappresentazione grafica e della sua risoluzione.</p>
<div id="cell-61" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Labirinto():</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, nomeFile):</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># legge il file del labirinto e imposta altezza e larghezza del labirinto</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="bu">open</span>(nomeFile) <span class="im">as</span> f:</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>            contenuti <span class="op">=</span> f.read()</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Verifica che il file contenga almeno uno stato iniziale (= un ingresso) e uno finale (= una uscita)</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> contenuti.count(<span class="st">"A"</span>) <span class="op">!=</span> <span class="dv">1</span>:</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Un labirinto deve avere esattamente un punto di partenza"</span>)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> contenuti.count(<span class="st">"B"</span>) <span class="op">!=</span> <span class="dv">1</span>:</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Un labirinto deve avere esattamente un obiettivo"</span>)</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calcola l'altezza e la larghezza del labirinto</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>        contenuti <span class="op">=</span> contenuti.splitlines()</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.altezza <span class="op">=</span> <span class="bu">len</span>(contenuti)</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.larghezza <span class="op">=</span> <span class="bu">max</span>(<span class="bu">len</span>(line) <span class="cf">for</span> line <span class="kw">in</span> contenuti)</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># tiene traccia dei muri del labirinto</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.muri <span class="op">=</span> []</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.altezza):</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>            riga <span class="op">=</span> []</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.larghezza):</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> contenuti[i][j] <span class="op">==</span> <span class="st">"A"</span>:</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>                        <span class="va">self</span>.start <span class="op">=</span> (i, j)</span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>                        riga.append(<span class="va">False</span>)</span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">elif</span> contenuti[i][j] <span class="op">==</span> <span class="st">"B"</span>:</span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>                        <span class="va">self</span>.goal <span class="op">=</span> (i, j)</span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a>                        riga.append(<span class="va">False</span>)</span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">elif</span> contenuti[i][j] <span class="op">==</span> <span class="st">" "</span>:</span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a>                        riga.append(<span class="va">False</span>)</span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>                        riga.append(<span class="va">True</span>)</span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">IndexError</span>:</span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>                    riga.append(<span class="va">False</span>)</span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.muri.append(riga)</span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.soluzione <span class="op">=</span> <span class="va">None</span></span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> nodiVicini(<span class="va">self</span>, stato):</span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a>        riga, col <span class="op">=</span> stato</span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a>        candidati <span class="op">=</span> [</span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a>            (<span class="st">"su"</span>, (riga <span class="op">-</span> <span class="dv">1</span>, col)),</span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>            (<span class="st">"giu"</span>, (riga <span class="op">+</span> <span class="dv">1</span>, col)),</span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a>            (<span class="st">"sin"</span>, (riga, col <span class="op">-</span> <span class="dv">1</span>)),</span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a>            (<span class="st">"des"</span>, (riga, col <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a>        risultato <span class="op">=</span> []</span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> azione, (r, c) <span class="kw">in</span> candidati:</span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> r <span class="op">&lt;</span> <span class="va">self</span>.altezza <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> c <span class="op">&lt;</span> <span class="va">self</span>.larghezza <span class="kw">and</span> <span class="kw">not</span> <span class="va">self</span>.muri[r][c]:</span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a>                risultato.append((azione, (r, c)))</span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> risultato</span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> risolvi(<span class="va">self</span>,frontiera):</span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Trova una soluzione al labirinto, se ne esiste una!"""</span></span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a>        <span class="co"># contiene il conteggio degli stati esplorati</span></span>
<span id="cb42-64"><a href="#cb42-64" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.numeroStatiEsplorati <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb42-65"><a href="#cb42-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-66"><a href="#cb42-66" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Inizializziamo la frontiera con lo stato iniziale</span></span>
<span id="cb42-67"><a href="#cb42-67" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> Nodo(stato<span class="op">=</span><span class="va">self</span>.start, genitore<span class="op">=</span><span class="va">None</span>, azione<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb42-68"><a href="#cb42-68" aria-hidden="true" tabindex="-1"></a>        frontiera.aggiungiStato(start)</span>
<span id="cb42-69"><a href="#cb42-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-70"><a href="#cb42-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Inizializzazione di un set di stati esplorati al momento vuoto</span></span>
<span id="cb42-71"><a href="#cb42-71" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.statiEsplorati <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb42-72"><a href="#cb42-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-73"><a href="#cb42-73" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Continua a eseguire in ciclo finché non si trova una soluzione o il problema non è risolvibile</span></span>
<span id="cb42-74"><a href="#cb42-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb42-75"><a href="#cb42-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-76"><a href="#cb42-76" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Se non c'è nulla nella frontiera vuol dire che il problema non è risolvibile.</span></span>
<span id="cb42-77"><a href="#cb42-77" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Ovvero, non c'è un cammino tra start e goal!</span></span>
<span id="cb42-78"><a href="#cb42-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> frontiera.eVuota():</span>
<span id="cb42-79"><a href="#cb42-79" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">"Non esiste una soluzione"</span>)</span>
<span id="cb42-80"><a href="#cb42-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-81"><a href="#cb42-81" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Sceglie un nodo dalla froniera</span></span>
<span id="cb42-82"><a href="#cb42-82" aria-hidden="true" tabindex="-1"></a>            nodo <span class="op">=</span> frontiera.rimuoviStato()</span>
<span id="cb42-83"><a href="#cb42-83" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.numeroStatiEsplorati <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb42-84"><a href="#cb42-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-85"><a href="#cb42-85" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Se il nodo estratto è il nodo goal allora abbiamo trovato il nodo di arrivo e risolto il problema</span></span>
<span id="cb42-86"><a href="#cb42-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nodo.stato <span class="op">==</span> <span class="va">self</span>.goal:</span>
<span id="cb42-87"><a href="#cb42-87" aria-hidden="true" tabindex="-1"></a>                azioni <span class="op">=</span> []</span>
<span id="cb42-88"><a href="#cb42-88" aria-hidden="true" tabindex="-1"></a>                celle <span class="op">=</span> []</span>
<span id="cb42-89"><a href="#cb42-89" aria-hidden="true" tabindex="-1"></a>                <span class="co"># ripercorre il cammino al contrario dal goal verso lo stato start per creare il cammino</span></span>
<span id="cb42-90"><a href="#cb42-90" aria-hidden="true" tabindex="-1"></a>                <span class="co"># che porta dallo start al goal. Ovvero, la soluzione.</span></span>
<span id="cb42-91"><a href="#cb42-91" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> nodo.genitore <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb42-92"><a href="#cb42-92" aria-hidden="true" tabindex="-1"></a>                    azioni.append(nodo.azione)</span>
<span id="cb42-93"><a href="#cb42-93" aria-hidden="true" tabindex="-1"></a>                    celle.append(nodo.stato)</span>
<span id="cb42-94"><a href="#cb42-94" aria-hidden="true" tabindex="-1"></a>                    nodo <span class="op">=</span> nodo.genitore</span>
<span id="cb42-95"><a href="#cb42-95" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Siccome ha costruito il cammino soluzione in direzione inversa, ovvero da goal a start</span></span>
<span id="cb42-96"><a href="#cb42-96" aria-hidden="true" tabindex="-1"></a>                <span class="co"># per avere il cammino orientato in modo corretto deve invertire sia la lista degli stati</span></span>
<span id="cb42-97"><a href="#cb42-97" aria-hidden="true" tabindex="-1"></a>                <span class="co"># che quella delle azioni</span></span>
<span id="cb42-98"><a href="#cb42-98" aria-hidden="true" tabindex="-1"></a>                azioni.reverse()</span>
<span id="cb42-99"><a href="#cb42-99" aria-hidden="true" tabindex="-1"></a>                celle.reverse()</span>
<span id="cb42-100"><a href="#cb42-100" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Quindi memorizza la lista degli stati e la lista delle azioni da intraprendere nell'attributo</span></span>
<span id="cb42-101"><a href="#cb42-101" aria-hidden="true" tabindex="-1"></a>                <span class="co"># soluzione della classe Labirinto</span></span>
<span id="cb42-102"><a href="#cb42-102" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.soluzione <span class="op">=</span> (azioni, celle)</span>
<span id="cb42-103"><a href="#cb42-103" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span></span>
<span id="cb42-104"><a href="#cb42-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-105"><a href="#cb42-105" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Altrimenti marchiamo il nodo estratto come esplorato</span></span>
<span id="cb42-106"><a href="#cb42-106" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.statiEsplorati.add(nodo.stato)</span>
<span id="cb42-107"><a href="#cb42-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-108"><a href="#cb42-108" aria-hidden="true" tabindex="-1"></a>            <span class="co"># E aggiungiamo i nodi vicini alla frontiera</span></span>
<span id="cb42-109"><a href="#cb42-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> azione, stato <span class="kw">in</span> <span class="va">self</span>.nodiVicini(nodo.stato):</span>
<span id="cb42-110"><a href="#cb42-110" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> frontiera.contieneStato(stato) <span class="kw">and</span> stato <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.statiEsplorati:</span>
<span id="cb42-111"><a href="#cb42-111" aria-hidden="true" tabindex="-1"></a>                    child <span class="op">=</span> Nodo(stato<span class="op">=</span>stato, genitore<span class="op">=</span>nodo, azione<span class="op">=</span>azione)</span>
<span id="cb42-112"><a href="#cb42-112" aria-hidden="true" tabindex="-1"></a>                    frontiera.aggiungiStato(child)</span>
<span id="cb42-113"><a href="#cb42-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-114"><a href="#cb42-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-115"><a href="#cb42-115" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> stampaLabirinto(<span class="va">self</span>, mostraSoluzione<span class="op">=</span><span class="va">True</span>, mostraStatiEsplorati<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb42-116"><a href="#cb42-116" aria-hidden="true" tabindex="-1"></a>        soluzione <span class="op">=</span> <span class="va">self</span>.soluzione[<span class="dv">1</span>] <span class="cf">if</span> <span class="va">self</span>.soluzione <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb42-117"><a href="#cb42-117" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>()</span>
<span id="cb42-118"><a href="#cb42-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, riga <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.muri):</span>
<span id="cb42-119"><a href="#cb42-119" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j, col <span class="kw">in</span> <span class="bu">enumerate</span>(riga):</span>
<span id="cb42-120"><a href="#cb42-120" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> col:</span>
<span id="cb42-121"><a href="#cb42-121" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">"█"</span>, end<span class="op">=</span><span class="st">""</span>)</span>
<span id="cb42-122"><a href="#cb42-122" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> (i, j) <span class="op">==</span> <span class="va">self</span>.start:</span>
<span id="cb42-123"><a href="#cb42-123" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">"A"</span>, end<span class="op">=</span><span class="st">""</span>)</span>
<span id="cb42-124"><a href="#cb42-124" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> (i, j) <span class="op">==</span> <span class="va">self</span>.goal:</span>
<span id="cb42-125"><a href="#cb42-125" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">"B"</span>, end<span class="op">=</span><span class="st">""</span>)</span>
<span id="cb42-126"><a href="#cb42-126" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> soluzione <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> mostraSoluzione <span class="kw">and</span> (i, j) <span class="kw">in</span> soluzione:</span>
<span id="cb42-127"><a href="#cb42-127" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">"*"</span>, end<span class="op">=</span><span class="st">""</span>)</span>
<span id="cb42-128"><a href="#cb42-128" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Stati esplorati</span></span>
<span id="cb42-129"><a href="#cb42-129" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> soluzione <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> mostraStatiEsplorati <span class="kw">and</span> (i, j) <span class="kw">in</span> <span class="va">self</span>.statiEsplorati:</span>
<span id="cb42-130"><a href="#cb42-130" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">"o"</span>, end<span class="op">=</span><span class="st">""</span>)</span>
<span id="cb42-131"><a href="#cb42-131" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb42-132"><a href="#cb42-132" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">" "</span>, end<span class="op">=</span><span class="st">""</span>)</span>
<span id="cb42-133"><a href="#cb42-133" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>()</span>
<span id="cb42-134"><a href="#cb42-134" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Possiamo caricare un labirinto e vedere la sua stampa a video:</p>
<div id="cell-63" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> Labirinto(<span class="st">"labirinto2.txt"</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Labirinto:"</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>l.stampaLabirinto(<span class="va">False</span>,<span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Labirinto:

███                 █████████
█   ███████████████████   █ █
█ ████                █ █ █ █
█ ███████████████████ █ █ █ █
█                     █ █ █ █
█████████████████████ █ █ █ █
█   ██                █ █ █ █
█ █ ██ ███ ██ █████████ █ █ █
█ █    █   ██B█         █ █ █
█ █ ██ ████████████████ █ █ █
███ ██             ████ █ █ █
███ ██████████████ ██ █ █ █ █
███             ██    █ █ █ █
██████ ████████ ███████ █ █ █
██████ ████             █   █
A      ██████████████████████
</code></pre>
</div>
</div>
<p>Adesso, usando il metodo risolvi della classe labirinto appena definita possiamo risolvere il labirinto. La prima soluzione la cerchiamo con l’algoritmo DFS passando al risolutore una frontiera a pila</p>
<div id="cell-65" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> timedelta</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Sto cercando una soluzione con una frontiera pila (DFS)..."</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>tempoIniziale <span class="op">=</span> time.time_ns()</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>l.risolvi(FrontieraPila())</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Numero di stati esplorati : "</span>, l.numeroStatiEsplorati)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>tempoImpiegato <span class="op">=</span> time.time_ns() <span class="op">-</span> tempoIniziale</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>msg <span class="op">=</span> <span class="st">"L'esecuzione del codice ha richiesto : </span><span class="sc">%s</span><span class="st"> microsecondi (Wall clock time)"</span> <span class="op">%</span> timedelta(microseconds<span class="op">=</span><span class="bu">round</span>(tempoImpiegato<span class="op">/</span><span class="dv">1000</span>))</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(msg)</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Soluzione trovata : "</span>)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>l.stampaLabirinto(mostraStatiEsplorati<span class="op">=</span><span class="va">True</span>,mostraSoluzione<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sto cercando una soluzione con una frontiera pila (DFS)...
Numero di stati esplorati :  194
L'esecuzione del codice ha richiesto : 0:00:00.000809 microsecondi (Wall clock time)
Soluzione trovata : 

███ooooooooooooooooo█████████
█ooo███████████████████ooo█o█
█o████oooooooooooooooo█o█o█o█
█o███████████████████o█o█o█o█
█ooooooooooooooooooooo█o█o█o█
█████████████████████o█o█o█o█
█   ██********oooooooo█o█o█o█
█ █ ██*███ ██*█████████o█o█o█
█ █****█   ██B█ooooooooo█o█o█
█ █*██o████████████████o█o█o█
███*██ooooooooooooo████o█o█o█
███*██████████████o██o█o█o█o█
███****ooooooooo██oooo█o█o█o█
██████*████████o███████o█o█o█
██████*████ooooooooooooo█ooo█
A******██████████████████████
</code></pre>
</div>
</div>
<p>Quindi, cerchiamo con l’algoritmo BFS passando al risolutore una frontiera a coda</p>
<div id="cell-67" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Sto cercando una soluzione con una frontiera a coda (BFS)..."</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>tempoIniziale <span class="op">=</span> time.time_ns()</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>l.risolvi(FrontieraCoda())</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Numero di stati esplorati : "</span>, l.numeroStatiEsplorati)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>tempoImpiegato <span class="op">=</span> time.time_ns() <span class="op">-</span> tempoIniziale</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>msg <span class="op">=</span> <span class="st">"L'esecuzione del codice ha richiesto : </span><span class="sc">%s</span><span class="st"> microsecondi (Wall clock time)"</span> <span class="op">%</span> timedelta(microseconds<span class="op">=</span><span class="bu">round</span>(tempoImpiegato<span class="op">/</span><span class="dv">1000</span>))</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(msg)</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Soluzione trovata : "</span>)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>l.stampaLabirinto(mostraStatiEsplorati<span class="op">=</span><span class="va">True</span>,mostraSoluzione<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sto cercando una soluzione con una frontiera a coda (BFS)...
Numero di stati esplorati :  77
L'esecuzione del codice ha richiesto : 0:00:00 microsecondi (Wall clock time)
Soluzione trovata : 

███                 █████████
█   ███████████████████   █ █
█ ████                █ █ █ █
█ ███████████████████ █ █ █ █
█                     █ █ █ █
█████████████████████ █ █ █ █
█ooo██********o       █ █ █ █
█o█o██*███o██*█████████ █ █ █
█o█****█ooo██B█         █ █ █
█o█*██o████████████████ █ █ █
███*██ooooooooo    ████ █ █ █
███*██████████████ ██ █ █ █ █
███****ooooooooo██    █ █ █ █
██████*████████o███████o█ █ █
██████*████ooooooooooooo█   █
A******██████████████████████
</code></pre>
</div>
</div>
<p>Osserviamo dai risultati ottenuti che per questo labirinto l’algoritmo di ricerca più veloce è il BFS perché ha trovato la soluzione visitando 77 nodi mentre l’algoritmo DFS ha visitato 194 nodi per arrivare alla stessa soluzione.</p>
</section>
</section>
<section id="algoritmi-di-ricerca-informati" class="level3">
<h3 class="anchored" data-anchor-id="algoritmi-di-ricerca-informati">Algoritmi di ricerca informati</h3>
<p>Gli algoritmi di ricerca informati sono una classe di algoritmi di ricerca che utilizzano una funzione euristica per guidare la ricerca verso la soluzione in modo più efficiente rispetto agli algoritmi di ricerca non informati come BFS e DFS. Questi algoritmi sfruttano informazioni aggiuntive sul problema, come la distanza stimata dalla soluzione, per esplorare in modo intelligente lo spazio di ricerca.</p>
<p>Uno degli algoritmi di ricerca informati più noti è l’algoritmo A* (pronunciato “A star”). Esso combina in modo bilanciato le informazioni sulla distanza già percorsa e una stima della distanza rimanente dalla soluzione, utilizzando una funzione euristica. L’algoritmo A* è completo, ovvero garantisce di trovare una soluzione se esiste, ed è anche ottimale, cioè trova il percorso più breve verso la soluzione se la funzione euristica è ammissibile.</p>
<p>Altri algoritmi di ricerca informati includono la ricerca di best-first, che espande sempre il nodo più promettente in base alla funzione euristica, e la ricerca greedy, che si basa esclusivamente sulla stima euristica senza considerare il costo del percorso già fatto. Questi algoritmi possono essere più veloci dell’A* in alcuni casi, ma non garantiscono necessariamente di trovare la soluzione ottimale.</p>
<p>Gli algoritmi di ricerca informati trovano applicazione in numerosi campi, come l’intelligenza artificiale, la robotica, la pianificazione di percorsi e la risoluzione di problemi di ottimizzazione. La scelta dell’algoritmo più appropriato dipende dalle caratteristiche del problema, come la complessità dello spazio di ricerca, la disponibilità di informazioni euristiche accurate e i requisiti di ottimalità della soluzione.</p>
<section id="funzioni-euristiche" class="level4">
<h4 class="anchored" data-anchor-id="funzioni-euristiche">Funzioni euristiche</h4>
<p>Le funzioni euristiche svolgono un ruolo cruciale negli algoritmi di ricerca informati, fornendo una stima della distanza o del costo rimanente per raggiungere la soluzione. Queste funzioni sono progettate per guidare la ricerca in modo intelligente, evitando di esplorare percorsi poco promettenti e concentrandosi sulle regioni dello spazio di ricerca più vicine alla soluzione.</p>
<p>Una buona funzione euristica dovrebbe essere ammissibile, ovvero non sovrastimare mai il costo effettivo per raggiungere la soluzione. Ciò garantisce che l’algoritmo di ricerca, come A*, trovi una soluzione ottimale se esiste. Inoltre, una funzione euristica accurata e informativa può accelerare notevolmente la ricerca, riducendo il numero di nodi esplorati prima di trovare la soluzione.</p>
<p>Nella risoluzione di labirinti, una funzione euristica comune è la distanza di Manhattan o la distanza euclidea tra la posizione corrente e l’uscita del labirinto. Queste funzioni forniscono una stima della distanza minima rimanente, ignorando gli ostacoli presenti nel labirinto. Tuttavia, funzioni euristiche più sofisticate possono tenere conto di ulteriori informazioni, come la disposizione degli ostacoli o la topologia del labirinto, per ottenere stime più accurate.</p>
<p>La progettazione di funzioni euristiche efficaci è spesso una sfida cruciale nell’applicazione degli algoritmi di ricerca informati a problemi complessi del mondo reale.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="distanze.png" class="img-fluid figure-img"></p>
<figcaption>Distanze euclidee e di Manhattan</figcaption>
</figure>
</div>
<p><strong>Distanza euclidea</strong> La distanza euclidea, anche nota come distanza in linea retta, è una misura della distanza tra due punti in uno spazio euclideo, come il piano cartesiano o lo spazio tridimensionale. Essa rappresenta la lunghezza del segmento di retta che congiunge i due punti.</p>
<p>La formula per calcolare la distanza euclidea tra due punti <span class="math inline">\(A=(x_A, y_A)\)</span> e <span class="math inline">\(B=(x_B, y_B)\)</span> in un piano cartesiano bidimensionale è:</p>
<p><span class="math display">\[d_{euclide}=\sqrt{(x_B-x_A)^2+(y_B-Y_A)^2}\]</span></p>
<p>La distanza euclidea è ampiamente utilizzata come funzione euristica negli algoritmi di ricerca informati, come l’algoritmo A*, per stimare la distanza rimanente dalla soluzione. Essa fornisce una stima ammissibile (non sovrastima) della distanza effettiva, soddisfacendo così i requisiti per garantire l’ottimalità dell’algoritmo di ricerca.</p>
<p>Tuttavia, la distanza euclidea può essere una stima poco accurata in alcuni contesti, come nei labirinti o in presenza di ostacoli, poiché non tiene conto degli impedimenti lungo il percorso. In questi casi, possono essere utilizzate funzioni euristiche più sofisticate per ottenere stime più precise.</p>
<p><strong><em>Distanza di Manhattan</em></strong> La distanza di Manhattan, anche nota come distanza city-block o distanza tassista, è una metrica utilizzata per calcolare la distanza tra due punti in uno spazio a coordinate cartesiane. Essa prende il nome dalla griglia di strade di Manhattan, dove i percorsi possibili sono limitati a spostamenti orizzontali e verticali.</p>
<p>La formula per calcolare la distanza di Manhattan tra due punti <span class="math inline">\(A=(x_A, y_A)\)</span> e <span class="math inline">\(B=(x_B, y_B)\)</span> in un piano cartesiano bidimensionale è:</p>
<p><span class="math display">\[d_{Manhattan}=(x_B-x_A)+(y_B-Y_A)\]</span></p>
<p>Essenzialmente, la distanza di Manhattan è la somma delle differenze assolute delle coordinate x e y dei due punti.</p>
<p>La distanza di Manhattan è spesso utilizzata come funzione euristica negli algoritmi di ricerca informati, come l’algoritmo A*, per risolvere problemi di ricerca su griglie o labirinti. Essa fornisce una stima ammissibile della distanza effettiva, garantendo così l’ottimalità dell’algoritmo di ricerca.</p>
<p>Rispetto alla distanza euclidea, la distanza di Manhattan può essere una stima più accurata in contesti come i labirinti, poiché tiene conto delle restrizioni di movimento lungo le direzioni orizzontali e verticali. Tuttavia, può sottostimare la distanza effettiva in situazioni in cui sono possibili percorsi diagonali.</p>
<p>La scelta tra la distanza euclidea e la distanza di Manhattan come funzione euristica dipende dalle caratteristiche specifiche del problema di ricerca e dalle proprietà dello spazio di ricerca.</p>
</section>
<section id="algoritmo-di-ricerca-informato-greedy-best-first-search" class="level4">
<h4 class="anchored" data-anchor-id="algoritmo-di-ricerca-informato-greedy-best-first-search">3.4.5.2 Algoritmo di ricerca informato Greedy Best-First Search</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="ricerca informata.png" class="img-fluid figure-img"></p>
<figcaption>ricerca informata</figcaption>
</figure>
</div>
<p>Quando l’algoritmo si trova nella cella colorata di azzurro deve scegliere se proseguire nella cella a distanza 9 o in quella a distanza 11 dal goal. Quale scegliere? GBF sceglie la cella con distanza 9 dall’obiettivo. È una buona scelta? Direi di no! Il cammino scelto è il più lungo. Forse, si può fare di meglio? Se esaminiamo le cella a e b notiamo l’euristica che ci ha portato in b con GBS è minore dell’ euristica in a. Ma, che cosa succede se oltre a considerare la distanza dall’obbiettivo aggiungo il cammino fatto all’euristica h? Ovvero: <span class="math display">\[H = distanza da percorrere + distanza percorsa\]</span> Entra l’algoritmo informato A*</p>
</section>
<section id="algoritmo-di-ricerca-informato-a" class="level4">
<h4 class="anchored" data-anchor-id="algoritmo-di-ricerca-informato-a">3.4.5.3 Algoritmo di ricerca informato A*</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="attachment:image-2.png" class="img-fluid figure-img"></p>
<figcaption>image-2.png</figcaption>
</figure>
</div>
<p>L’algoritmo A* è un algoritmo di ricerca informato che utilizza una funzione di valutazione per guidare la ricerca verso la soluzione ottimale. La funzione di valutazione, nota come funzione di costo <span class="math inline">\(h(n)\)</span>, è composta da due componenti: 1. <strong>Costo del cammino</strong>: <span class="math inline">\(g(n)\)</span>, che rappresenta il costo del cammino per raggiungere il nodo <span class="math inline">\(n\)</span> dalla radice. 2. <strong>Stima del costo rimanente</strong>: <span class="math inline">\(f(n)\)</span>, che rappresenta una stima del costo rimanente per raggiungere la soluzione ottimale partendo dal nodo <span class="math inline">\(n\)</span>. La funzione di valutazione <span class="math inline">\(h(n)\)</span> è definita come: <span class="math display">\[h(n) = g(n) + f(n)\]</span> L’algoritmo A* utilizza una coda di priorità per mantenere i nodi da esplorare in base al valore della funzione di valutazione <span class="math inline">\(f(n)\)</span>. I nodi con il valore più basso di <span class="math inline">\(h(n)\)</span> vengono estratti dalla coda e esplorati prima. Nel caso in figura, con questa nuova euristica vediamo che a è una scelta migliore di b perché ha una euristica minore.</p>
</section>
</section>
</section>
<section id="algoritmi-equitativi" class="level2">
<h2 class="anchored" data-anchor-id="algoritmi-equitativi">Algoritmi Equitativi</h2>
<p>L’avvento dell’Intelligenza Artificiale e il progresso nella capacità computazionale delle moderne macchine hanno rivoluzionato molteplici aspetti della nostra vita quotidiana. Tra le numerose applicazioni dell’IA, gli algoritmi predittivi e gli algoritmi di ripartizione equitativa si distinguono per il loro potenziale straordinario e per le sfide etiche che presentano.</p>
<p>Gli algoritmi predittivi, capaci di effettuare previsioni estremamente accurate in svariati scenari, sono diventati strumenti essenziali in settori cruciali come quello giudiziario, creditizio, assicurativo e sanitario. Questi algoritmi analizzano enormi quantità di dati per prendere decisioni che possono avere un impatto significativo sulla vita delle persone. Tuttavia, il loro crescente impiego ha sollevato una preoccupazione fondamentale: l’equità.</p>
<p>L’equità negli algoritmi si riferisce alla loro capacità di trattare in modo imparziale tutti i gruppi di persone, indipendentemente da attributi sensibili come etnia, genere, età o stato socioeconomico. Senza adeguate misure di equità, gli algoritmi rischiano di perpetuare o addirittura amplificare disuguaglianze sociali ed economiche esistenti, poiché i dati utilizzati per il loro addestramento possono contenere pregiudizi storici e sistemici.</p>
<p>Parallelamente, gli algoritmi di ripartizione equitativa giocano un ruolo cruciale nella distribuzione giusta e bilanciata di risorse o beni tra più parti. Questi algoritmi trovano applicazione in scenari diversi, dalla divisione dei beni durante un divorzio alla distribuzione di fondi di emergenza in situazioni di crisi.</p>
<p>Per affrontare le sfide legate all’equità, sono stati sviluppati vari approcci e metodologie. Tra questi, la pre-elaborazione dei dati mira a correggere i bias presenti nei dati prima dell’addestramento degli algoritmi. Durante lo sviluppo, si possono includere vincoli di equità nei processi di ottimizzazione per evitare che l’algoritmo favorisca ingiustamente un gruppo rispetto a un altro. Il post-processamento dei risultati permette di aggiustare le previsioni per eliminare disparità tra gruppi diversi.</p>
<p>La trasparenza e la spiegabilità degli algoritmi sono essenziali per affrontare le questioni etiche correlate. Spesso, gli algoritmi più avanzati sono percepiti come “scatole nere”, rendendo difficile comprendere i processi decisionali e attribuire responsabilità in caso di errori. Questo solleva importanti questioni di responsabilità e trasparenza.</p>
<p>L’implementazione di algoritmi equitativi può avere impatti significativi in vari settori. Nel sistema giudiziario, strumenti equi possono promuovere la fiducia nel sistema legale. Nei processi di assunzione, possono garantire valutazioni basate sulle competenze piuttosto che su caratteristiche personali. Nel campo sanitario, possono migliorare l’accesso e la qualità delle cure per tutte le popolazioni.</p>
<p>In conclusione, l’equità nell’IA è un aspetto cruciale che richiede attenzione e considerazione. Mentre gli algoritmi predittivi e gli algoritmi di ripartizione equitativa rivestono un ruolo fondamentale nella nostra vita quotidiana, è essenziale garantire che siano sviluppati e utilizzati in modo equo e trasparente. Solo così possiamo trarre il massimo beneficio dalla potenza dell’IA senza incorrere in potenziali disuguaglianze e pregiudizi. In questo paragrafo, esploreremo gli algoritmi di ripartizione equitativa, che sono essenziali per garantire che le risorse o i beni siano distribuiti in modo equo tra le parti interessate. Questi algoritmi trovano applicazione in scenari diversi, dalla divisione dei beni durante un divorzio alla distribuzione di fondi di emergenza in situazioni di crisi.</p>
<section id="agenti-partecipanti" class="level3">
<h3 class="anchored" data-anchor-id="agenti-partecipanti">agenti partecipanti</h3>
<p>In generale, si ha a che fare con un insieme N di agenti o partecipanti o giocatori. Questi agenti hanno la necessità di mettersi d’accordo sulla divisione di un certo numero M di beni, risorse, oggetti, ecc.</p>
</section>
<section id="beni" class="level3">
<h3 class="anchored" data-anchor-id="beni">beni</h3>
<p>Gli algoritmi di suddivisione equa possono essere applicati a diversi tipi di beni, ciascuno con caratteristiche specifiche che influenzano il modo in cui la suddivisione deve essere effettuata. Questi beni possono essere classificati in diverse categorie:</p>
<p><strong>Beni Divisibili</strong> I beni divisibili sono quelli che possono essere suddivisi in parti più piccole senza perdere il loro valore intrinseco. Esempi includono:</p>
<ul>
<li><strong>Cibo</strong>: come una torta o una pizza, che possono essere tagliati in fette.</li>
<li><strong>Terreni</strong>: una proprietà terriera può essere suddivisa in appezzamenti più piccoli.</li>
<li><strong>Denaro</strong>: che può essere facilmente diviso in unità più piccole.</li>
</ul>
<p><strong>Beni Indivisibili</strong> I beni indivisibili non possono essere suddivisi senza perdere il loro valore o funzionalità. Esempi includono:</p>
<ul>
<li><strong>Oggetti fisici unici</strong>: come una macchina, un’opera d’arte o un elettrodomestico.</li>
<li><strong>Ruoli o incarichi</strong>: come una posizione lavorativa o un incarico specifico in un progetto.</li>
</ul>
<p><strong>Beni Combinati</strong> Alcuni beni possono essere considerati una combinazione di elementi divisibili e indivisibili. Ad esempio:</p>
<ul>
<li><strong>Pacchetti di beni</strong>: come un set di mobili dove ogni pezzo è indivisibile, ma il set complessivo può essere suddiviso.</li>
<li><strong>Progetti con compiti specifici</strong>: dove i singoli compiti possono essere indivisibili, ma l’intero progetto può essere suddiviso tra diversi partecipanti.</li>
</ul>
<p><strong>Beni con Valore Soggettivo</strong> Alcuni beni hanno un valore che varia a seconda delle preferenze individuali dei partecipanti. Esempi includono:</p>
<ul>
<li><strong>Oggetti con valore sentimentale</strong>: come regali o ricordi di famiglia.</li>
<li><strong>Elementi artistici o culturali</strong>: come quadri o libri, il cui valore può dipendere dal gusto personale.</li>
</ul>
<p><strong>Beni Temporanei</strong> Questi sono beni che possono essere utilizzati per un certo periodo di tempo e poi riassegnati. Esempi includono:</p>
<ul>
<li><strong>Uso di risorse comuni</strong>: come una sala conferenze, un campo sportivo o un’attrezzatura condivisa.</li>
<li><strong>Servizi o turni di lavoro</strong>: dove il tempo di servizio o il turno può essere diviso tra più persone.</li>
</ul>
<p><strong>Beni Digitali</strong> I beni digitali possono essere suddivisi e duplicati senza perdere valore. Esempi includono:</p>
<ul>
<li><strong>Software</strong>: che può essere concesso in licenza a più utenti.</li>
<li><strong>Contenuti digitali</strong>: come e-book, musica o video, che possono essere condivisi tra più persone. Per affrontare questi problemi, gli algoritmi di suddivisione equa utilizzano criteri diversi, come la proporzionalità, l’efficienza, l’equita, l’invidia-zero (nessun partecipante dovrebbe invidiare la parte degli altri) e altre nozioni di giustizia.</li>
</ul>
<p><strong>Esempi di criteri di equità</strong></p>
<ol type="1">
<li><strong>Proporzionalità</strong>: Ogni partecipante riceve una quota proporzionale alle proprie pretese o contributi.</li>
<li><strong>Invidia-zero</strong>: Nessun partecipante deve preferire la parte assegnata a un altro partecipante alla propria parte.</li>
<li><strong>Efficienza Pareto</strong>: Non è possibile riassegnare le risorse in modo che qualcuno sia in una situazione migliore senza che qualcun altro sia in una situazione peggiore.</li>
<li><strong>Equità equitativa</strong>: Ogni partecipante percepisce di aver ricevuto una parte equa in base a criteri specifici.</li>
</ol>
<p>Gli algoritmi di suddivisione equa cercano di trovare soluzioni che bilancino questi criteri, a seconda delle specifiche esigenze del contesto in cui vengono applicati.</p>
</section>
<section id="regole-e-assunzioni" class="level3">
<h3 class="anchored" data-anchor-id="regole-e-assunzioni">Regole e assunzioni</h3>
<p><strong>Regole</strong> Affinché la divisione di un bene S sia equa: - i giocatori devono essere partecipanti volontari e accettare le regole del gioco come vincolanti.</p>
<ul>
<li><p>I giocatori devono agire razionalmente secondo il loro sistema di credenze.</p></li>
<li><p>Le regole della matematica si applicano quando si assegnano valori agli oggetti in S.</p></li>
<li><p>Solo i giocatori sono coinvolti nel gioco, non ci sono agenti esterni come avvocati o altri intermediari.</p></li>
</ul>
<p>Se i giocatori seguono le regole, il gioco terminerà dopo un numero finito di mosse dei giocatori e risulterà in una divisione di S.</p>
<p><strong>Assunzioni</strong></p>
<p>Gli algoritmi si basano sulle seguenti assunzionimere quanto segue:</p>
<ul>
<li><p>Tutti i giocatori giocano in modo corretto.</p></li>
<li><p>Non hanno informazioni precedenti sui gusti o le avversioni degli altri giocatori.</p></li>
<li><p>Non assegnano valori in modo da manipolare il gioco.</p></li>
<li><p>Tutti i giocatori hanno uguali diritti nella condivisione dell’insieme S. In altre parole, se ci sono tre giocatori, ogni giocatore ha diritto ad almeno 1/3 di S.</p></li>
</ul>
<p>Se queste assunzioni non sono soddisfatte, la divisione potrebbe non essere completamente equa.</p>
</section>
<section id="matematica-elementare-per-algoritmi-di-ripartizione-equa" class="level3">
<h3 class="anchored" data-anchor-id="matematica-elementare-per-algoritmi-di-ripartizione-equa">Matematica elementare per algoritmi di ripartizione equa</h3>
<ul>
<li><strong>Percentuale</strong>: Una percentuale è una frazione con un denominatore di 100. Ad esempio, il 50% è la metà, il 25% è un quarto e il 100% è l’intero.</li>
<li><strong>Percentuale di un numero</strong>: Per trovare la percentuale di un numero, moltiplica il numero per la percentuale come decimale. Ad esempio, il 25% di 80 è 0,25 x 80 = 20.</li>
<li><strong>Percentuale di un numero n1 rispetto a un numero n2</strong>: Per calcolare la percentuale di un numero n1 rispetto a un numero n2, dividi n1 per n2 e moltiplica per 100. Ad esempio, se 20 è una parte di 80, si ha che 20 è il (20/80) x 100 di 80 o il 25% di 80.</li>
</ul>
<p>esempio: 1. Alice e Bob hanno un sacchetto di 100 monete. Alice ha 60 monete, mentre Bob ha 40 monete. Qual è la percentuale di monete di Alice rispetto a Bob? Soluzione: - La percentuale di monete di Alice rispetto a Bob: (60/40) x 100 = 150%. - Quindi, Alice ha il 150% delle monete di Bob.</p>
<ol start="2" type="1">
<li>Alice, Bob, Claudia e Daniele hanno una torta. Alice ha 2 fette, Bob ha 3 fette, Claudia ha 4 fette e Daniele ha 1 fetta. Qual è la percentuale di fette di Alice rispetto a Bob? Soluzione:</li>
</ol>
<ul>
<li>La percentuale di fette di Alice rispetto a Bob: (2/3) x 100 = 66,67%. Qual è la percentuale di torta che ha Alice? Soluuzione:</li>
<li>La percentuale di torta che ha Alice: (2/10) x 100 = 20%.</li>
</ul>
</section>
<section id="algoritmi-di-ripartizione-equitativa" class="level3">
<h3 class="anchored" data-anchor-id="algoritmi-di-ripartizione-equitativa">Algoritmi di Ripartizione Equitativa</h3>
<p>Un problema tipico di ripartizione equa può essere formulato come segue: Alice, Bruno, Carla e Davide hanno una torta. La torta è divisa in 4 parti non necessariamente uguali e non con la stessa farcitura e/o copertura. Ognuno dei 4 partecipanti ha una sua preferenza per ognuna delle quattro parti. Le preferenze sono riassunte nella seguente tabella:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Partecipante</th>
<th>porzione 1</th>
<th>porzione 2</th>
<th>porzione 3</th>
<th>porzione 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alice</td>
<td>10%</td>
<td>50%</td>
<td>30%</td>
<td>10%</td>
</tr>
<tr class="even">
<td>Bruno</td>
<td>30%</td>
<td>30%</td>
<td>10%</td>
<td>30%</td>
</tr>
<tr class="odd">
<td>Carla</td>
<td>40%</td>
<td>20%</td>
<td>20%</td>
<td>20%</td>
</tr>
<tr class="even">
<td>Davide</td>
<td>25%</td>
<td>25%</td>
<td>25%</td>
<td>25%</td>
</tr>
</tbody>
</table>
<p>La domanda che ci si pone è: Quale porzione di torta considererebbe equa ogni giocatore? È importante ricordare che un algoritmo di ripartizione equa si basa sulle assunzioni del paragrafo 3.5.3. Pertanto, ogni giocatore ha espresso la propria preferenza senza conoscere le preferenze degli altri partecipanti. La soluzione, in questo caso, è illustrata nella tabella seguente, dove è evidenziata la porzione assegnata a ciascun giocatore, rispettando le preferenze manifestate.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Partecipante</th>
<th>porzione 1</th>
<th>porzione 2</th>
<th>porzione 3</th>
<th>porzione 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alice</td>
<td>10%</td>
<td><strong>50%</strong></td>
<td>30%</td>
<td>10%</td>
</tr>
<tr class="even">
<td>Bruno</td>
<td>30%</td>
<td>30%</td>
<td>10%</td>
<td><strong>30%</strong></td>
</tr>
<tr class="odd">
<td>Carla</td>
<td><strong>40%</strong></td>
<td>20%</td>
<td>20%</td>
<td>20%</td>
</tr>
<tr class="even">
<td>Davide</td>
<td>25%</td>
<td>25%</td>
<td><strong>25%</strong></td>
<td>25%</td>
</tr>
</tbody>
</table>
<p>L’implementazione dell’algorimo usato per ottenere la soluzione è riportata nella prossima sezione</p>
<div id="cell-70" class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> divisione_equa(preferenze):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. **Inizializzazione** : Converti il dizionario delle preferenze in una lista di tuple per una gestione più semplice</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    partecipanti <span class="op">=</span> <span class="bu">list</span>(preferenze.keys())</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    valori_preferenze <span class="op">=</span> <span class="bu">list</span>(preferenze.values())</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Numero di partecipanti e porzioni</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    num_partecipanti <span class="op">=</span> <span class="bu">len</span>(partecipanti)</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    num_porzioni <span class="op">=</span> <span class="bu">len</span>(valori_preferenze[<span class="dv">0</span>])</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inizializza la lista di allocazione</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    allocazione <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> num_partecipanti</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    porzioni_usate <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> num_porzioni</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. **Funzione `trova_preferenza_massima`** : Funzione per trovare il partecipante con la preferenza più alta per una data porzione</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> trova_preferenza_massima(porzione):</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>        preferenza_massima <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>        indice_partecipante <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_partecipanti):</span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> valori_preferenze[i][porzione] <span class="op">&gt;</span> preferenza_massima <span class="kw">and</span> allocazione[i] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>                preferenza_massima <span class="op">=</span> valori_preferenze[i][porzione]</span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>                indice_partecipante <span class="op">=</span> i</span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> indice_partecipante</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. **Assegnazione delle Porzioni** : Assegna le porzioni ai partecipanti</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> porzione <span class="kw">in</span> <span class="bu">range</span>(num_porzioni):</span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>        indice_partecipante <span class="op">=</span> trova_preferenza_massima(porzione)</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>        allocazione[indice_partecipante] <span class="op">=</span> porzione</span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>        porzioni_usate[porzione] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. **Creazione del Risultato** : Crea un dizionario di risultato per mappare i partecipanti alle loro porzioni allocate</span></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>    risultato <span class="op">=</span> {partecipanti[i]: <span class="ss">f"porzione </span><span class="sc">{</span>allocazione[i] <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_partecipanti)}</span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> risultato</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. **Esecuzione del Codice**: Esegui il codice con le preferenze fornite</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Preferenze dei partecipanti</span></span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>preferenze <span class="op">=</span> {</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Alice'</span>: [<span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">30</span>, <span class="dv">10</span>],  <span class="co"># Preferenze per le porzioni 1, 2, 3, e 4</span></span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Bruno'</span>: [<span class="dv">30</span>, <span class="dv">30</span>, <span class="dv">10</span>, <span class="dv">30</span>],</span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Carla'</span>: [<span class="dv">40</span>, <span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">20</span>],</span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Davide'</span>: [<span class="dv">25</span>, <span class="dv">25</span>, <span class="dv">25</span>, <span class="dv">25</span>]</span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Trova la divisione equa delle porzioni</span></span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>allocazione <span class="op">=</span> divisione_equa(preferenze)</span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Stampa il risultato</span></span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Una divisione equa delle porzioni è la seguente:"</span>)</span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> partecipante, porzione <span class="kw">in</span> allocazione.items():</span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>partecipante<span class="sc">}</span><span class="ss"> riceve </span><span class="sc">{</span>porzione<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Una divisione equa delle porzioni è la seguente:
Alice riceve porzione 2
Bruno riceve porzione 4
Carla riceve porzione 1
Davide riceve porzione 3</code></pre>
</div>
</div>
<p>Il semplice codice Python proposto implementa un algoritmpo di divisione equa nel seguente modo:</p>
<ol type="1">
<li><strong>Inizializzazione</strong>:
<ul>
<li>Convertiamo il dizionario delle preferenze in una lista di tuple per una gestione più semplice.</li>
<li>Otteniamo i nomi dei partecipanti e le loro preferenze.</li>
<li>Inizializziamo le liste <code>allocazione</code> e <code>porzioni_usate</code> per tenere traccia delle porzioni assegnate e delle porzioni già utilizzate.</li>
</ul></li>
<li><strong>Funzione <code>trova_preferenza_massima</code></strong>:
<ul>
<li>Questa funzione trova il partecipante con la preferenza più alta per una data porzione che non ha ancora ricevuto una porzione.</li>
<li>Scorre tutti i partecipanti e confronta le loro preferenze per la porzione corrente, restituendo l’indice del partecipante con la preferenza massima.</li>
</ul></li>
<li><strong>Assegnazione delle Porzioni</strong>:
<ul>
<li>Per ogni porzione, troviamo il partecipante con la preferenza più alta utilizzando la funzione <code>trova_preferenza_massima</code>.</li>
<li>Assegniamo la porzione a quel partecipante e segniamo la porzione come utilizzata.</li>
</ul></li>
<li><strong>Creazione del Risultato</strong>:
<ul>
<li>Creiamo un dizionario <code>risultato</code> che mappa i partecipanti alle loro porzioni assegnate.</li>
<li>Restituiamo il dizionario <code>risultato</code>.</li>
</ul></li>
<li><strong>Esecuzione del Codice</strong>:
<ul>
<li>Definiamo le preferenze dei partecipanti.</li>
<li>Chiamiamo la funzione <code>divisione_equa</code> per ottenere la divisione delle porzioni.</li>
<li>Stampiamo il risultato.</li>
</ul></li>
</ol>
<p>Evidentemente, l’algoritmo proposto non è l’unica soluzione possibile e può dare origine a situazioni di iniquità o di conflitti. Ad esempio se le preferenze dei partecipanti sono:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Partecipante</th>
<th>porzione 1</th>
<th>porzione 2</th>
<th>porzione 3</th>
<th>porzione 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alice</td>
<td>10%</td>
<td>50%</td>
<td>30%</td>
<td>10%</td>
</tr>
<tr class="even">
<td>Bruno</td>
<td>30%</td>
<td>30%</td>
<td>10%</td>
<td>30%</td>
</tr>
<tr class="odd">
<td>Carla</td>
<td>20%</td>
<td>40%</td>
<td>20%</td>
<td>20%</td>
</tr>
<tr class="even">
<td>Davide</td>
<td>25%</td>
<td>25%</td>
<td>25%</td>
<td>25%</td>
</tr>
</tbody>
</table>
<p>Si noti il conflitto tra Alice e Carla per la porzione 2. La soluzione a cui arriva l’algoritmo visto è:</p>
<div id="cell-72" class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>preferenze <span class="op">=</span> {</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Alice'</span>: [<span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">30</span>, <span class="dv">10</span>],  <span class="co"># Preferenze per le porzioni 1, 2, 3, e 4</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Bruno'</span>: [<span class="dv">30</span>, <span class="dv">30</span>, <span class="dv">10</span>, <span class="dv">30</span>],</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Carla'</span>: [<span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">20</span>, <span class="dv">20</span>],</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Davide'</span>: [<span class="dv">25</span>, <span class="dv">25</span>, <span class="dv">25</span>, <span class="dv">25</span>]</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Trova la divisione equa delle porzioni</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>allocazione <span class="op">=</span> divisione_equa(preferenze)</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Stampa il risultato</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Una divisione equa delle porzioni è la seguente:"</span>)</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> partecipante, porzione <span class="kw">in</span> allocazione.items():</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>partecipante<span class="sc">}</span><span class="ss"> riceve </span><span class="sc">{</span>porzione<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Una divisione equa delle porzioni è la seguente:
Alice riceve porzione 2
Bruno riceve porzione 1
Carla riceve porzione 4
Davide riceve porzione 3</code></pre>
</div>
</div>
<p>In questo caso, Carla riceve una porzione per la quale ha espresso un interesse minore e potrebbe invidiare Alice, che ha ottenuto proprio la porzione che lei avrebbe preferito. Tuttavia, non ci si può fare niente. La soluzione proposta è la migliore possibile date le preferenze espresse e i beni indivisibili disponibili.</p>
<p><strong>Valore soggettivo di un bene</strong></p>
<p>Prima di trattare l’argomento dell’invidia, c’è un altro aspetto interessante da approfondire: il valore soggettivo del bene. Ad esempio, nella suddivisione esaminata, se la torta costa 18 €, quale sarebbe il valore economico di ogni porzione di torta per ciascun partecipante?</p>
<p>Tememdo conto che le preferenze sono le seguenti:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>Partecipante</th>
<th>porzione 1</th>
<th>porzione 2</th>
<th>porzione 3</th>
<th>porzione 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alice</td>
<td>10%</td>
<td>50%</td>
<td>30%</td>
<td>10%</td>
</tr>
<tr class="even">
<td>Bruno</td>
<td>30%</td>
<td>30%</td>
<td>10%</td>
<td>30%</td>
</tr>
<tr class="odd">
<td>Carla</td>
<td>40%</td>
<td>20%</td>
<td>20%</td>
<td>20%</td>
</tr>
<tr class="even">
<td>Davide</td>
<td>25%</td>
<td>25%</td>
<td>25%</td>
<td>25%</td>
</tr>
</tbody>
</table>
<p>Alice ha il 50% di prefernenze per la porzione 2 quindi per lei la porzione 2 vale il 50% di 18€ = 9€ e così via. La tabella dei valori delle singole perzioni per ogni partecipante è la seguente:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Partecipante</th>
<th>porzione 1</th>
<th>porzione 2</th>
<th>porzione 3</th>
<th>porzione 4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Alice</td>
<td>1,80€</td>
<td>9,00€</td>
<td>5,40€</td>
<td>1,80€</td>
</tr>
<tr class="even">
<td>Bruno</td>
<td>5,40€</td>
<td>5,40€</td>
<td>1,80€</td>
<td>5,40€</td>
</tr>
<tr class="odd">
<td>Carla</td>
<td>7,20€</td>
<td>3,60€</td>
<td>3,60€</td>
<td>3,60€</td>
</tr>
<tr class="even">
<td>Davide</td>
<td>4,50€</td>
<td>4,50€</td>
<td>4,50€</td>
<td>4,50€</td>
</tr>
</tbody>
</table>
<p>Vediamo un altro esempio di calcolo del valore soggettivo di un bene. Alice vede una torta che costa 18€ di cui una metà al cioccolato e l’altra al pistacchio. Alice ama il cioccolato e non ama il pistacchio. Alice valuta la porzione al cioccolato al 90% e la porzione al pistacchio al 10%. Quindi Alice valuta la metà al cioccolato al 90% di 18€ = 16,20€ e la metà al pistacchio al 10% di 18€ = 1,80€.</p>
<p>In generale, il valore soggettivo di un bene può essere influenzato da una varietà di fattori, che riflettono le percezioni individuali e le circostanze specifiche. Ecco alcuni degli aspetti principali che possono influenzare il valore soggettivo:</p>
<ul>
<li><em>Scarsità</em>: Un bene raro o difficile da reperire tende ad avere un valore soggettivo più elevato1. Domanda: La popolarità o la desiderabilità di un bene possono aumentarne il valore percepito1.</li>
<li><em>Preferenze personali</em>: Gli interessi, i gusti e le preferenze individuali giocano un ruolo significativo nel determinare il valore di un bene per una persona1.</li>
<li><em>Significato culturale</em>: Il valore di un bene può essere influenzato dal suo significato o dalla sua importanza in una determinata cultura.</li>
<li><em>Circostanze situazionali</em>: Eventi specifici o situazioni particolari possono alterare il valore di un bene. Ad esempio, l’acqua potrebbe avere un valore molto più alto in un deserto rispetto a una città2.</li>
<li><em>Affinità personale</em>: Il legame emotivo o la storia personale con un bene possono aumentarne il valore per un individuo2.</li>
<li><em>Incertezza e mancanza di conoscenza</em>: A volte le persone possono valutare l’importanza di un bene in modo non conforme alla sua reale importanza a causa dell’incertezza o della mancanza di informazioni.</li>
</ul>
<p>Questi fattori dimostrano che il valore di un bene non è fisso o intrinseco, ma è piuttosto determinato dalle percezioni e dalle circostanze individuali. La teoria del valore soggettivo sostiene che il valore di un bene dipende dall’ambiente e dalle persone che lo percepiscono, piuttosto che dai costi di produzione o dal lavoro necessario per crearlo1.</p>
<p><strong>Mitigazione dell’invidia</strong></p>
<p>Come anticipato, è necessario approfondire il problema della divisione equa senza invidia. Immaginiamo due amici, Alice e Bruno, che devono dividersi una serie di oggetti di valore in modo che nessuno dei due si senta invidioso dell’altro. Ad esempio, supponiamo che Alice e Bruno debbano dividersi i seguenti beni con le rispettive valutazioni:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Oggetto</th>
<th>Alice</th>
<th>Bruno</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>orologio</td>
<td>4</td>
<td>2</td>
</tr>
<tr class="even">
<td>libro</td>
<td>2</td>
<td>3</td>
</tr>
<tr class="odd">
<td>penna</td>
<td>2</td>
<td>3</td>
</tr>
<tr class="even">
<td>quadro</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Nwl seguito si porpone una implementazione dell’algoritmo envy free in Python:</p>
<div id="cell-74" class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> allocazione_senza_invidia(beni, valutazioni): <span class="co"># 1. **Definizione della Funzione**</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Algoritmo di Envy-Free per la divisione di beni indivisibili tra due persone.</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="co">    beni: lista di beni da dividere</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="co">    valutazioni: dizionario con le valutazioni dei beni per ciascun partecipante</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. **Inizializzazione delle Assegnazioni**:</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    assegnazione <span class="op">=</span> {<span class="st">'Alice'</span>: [], <span class="st">'Bob'</span>: []}</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    valori_totali <span class="op">=</span> {<span class="st">'Alice'</span>: <span class="dv">0</span>, <span class="st">'Bob'</span>: <span class="dv">0</span>}</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. **Ordinamento dei Beni**: Ordina gli oggetti in base alla somma delle valutazioni</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    beni_ordinati <span class="op">=</span> <span class="bu">sorted</span>(beni, key<span class="op">=</span><span class="kw">lambda</span> x: valutazioni[<span class="st">'Alice'</span>][x] <span class="op">+</span> valutazioni[<span class="st">'Bob'</span>][x], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. **Assegnazione dei Beni**: Assegna gli oggetti in modo da bilanciare i valori totali</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bene <span class="kw">in</span> beni_ordinati:</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> valori_totali[<span class="st">'Alice'</span>] <span class="op">&lt;=</span> valori_totali[<span class="st">'Bob'</span>]:</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>            assegnazione[<span class="st">'Alice'</span>].append(bene)</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>            valori_totali[<span class="st">'Alice'</span>] <span class="op">+=</span> valutazioni[<span class="st">'Alice'</span>][bene]</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>            assegnazione[<span class="st">'Bob'</span>].append(bene)</span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>            valori_totali[<span class="st">'Bob'</span>] <span class="op">+=</span> valutazioni[<span class="st">'Bob'</span>][bene]</span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 5. **Verifica e Correzione delle Invidie**: Verifica e corregge eventuali invidie</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> bene <span class="kw">in</span> beni_ordinati:</span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> valutazioni[<span class="st">'Alice'</span>][bene] <span class="op">&gt;</span> valutazioni[<span class="st">'Bob'</span>][bene] <span class="kw">and</span> bene <span class="kw">in</span> assegnazione[<span class="st">'Bob'</span>]:</span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> valori_totali[<span class="st">'Alice'</span>] <span class="op">&lt;</span> valori_totali[<span class="st">'Bob'</span>]:</span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>                assegnazione[<span class="st">'Bob'</span>].remove(bene)</span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>                assegnazione[<span class="st">'Alice'</span>].append(bene)</span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>                valori_totali[<span class="st">'Alice'</span>] <span class="op">+=</span> valutazioni[<span class="st">'Alice'</span>][bene]</span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>                valori_totali[<span class="st">'Bob'</span>] <span class="op">-=</span> valutazioni[<span class="st">'Bob'</span>][bene]</span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> valutazioni[<span class="st">'Bob'</span>][bene] <span class="op">&gt;</span> valutazioni[<span class="st">'Alice'</span>][bene] <span class="kw">and</span> bene <span class="kw">in</span> assegnazione[<span class="st">'Alice'</span>]:</span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> valori_totali[<span class="st">'Bob'</span>] <span class="op">&lt;</span> valori_totali[<span class="st">'Alice'</span>]:</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>                assegnazione[<span class="st">'Alice'</span>].remove(bene)</span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>                assegnazione[<span class="st">'Bob'</span>].append(bene)</span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>                valori_totali[<span class="st">'Bob'</span>] <span class="op">+=</span> valutazioni[<span class="st">'Bob'</span>][bene]</span>
<span id="cb53-37"><a href="#cb53-37" aria-hidden="true" tabindex="-1"></a>                valori_totali[<span class="st">'Alice'</span>] <span class="op">-=</span> valutazioni[<span class="st">'Alice'</span>][bene]</span>
<span id="cb53-38"><a href="#cb53-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-39"><a href="#cb53-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> assegnazione <span class="co"># 6. **Ritorno delle Assegnazioni**:</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Il funzionamento del codice è il seguente:</p>
<ol type="1">
<li><strong>Definizione della Funzione</strong>: <code>python     def allocazione_senza_invidia(beni, valutazioni):</code>
<ul>
<li>Definisce una funzione chiamata <code>allocazione_senza_invidia</code> che prende due parametri: <code>beni</code> (lista di beni da dividere) e <code>valutazioni</code> (dizionario con le valutazioni dei beni per ciascun partecipante).</li>
</ul></li>
<li><strong>Inizializzazione delle Assegnazioni</strong>: <code>python     assegnazione = {'Alice': [], 'Bob': []}     valori_totali = {'Alice': 0, 'Bob': 0}</code>
<ul>
<li>Inizializza due dizionari: <code>assegnazione</code> per tenere traccia dei beni assegnati a ciascun partecipante e <code>valori_totali</code> per tenere traccia del valore totale dei beni assegnati a ciascun partecipante.</li>
</ul></li>
<li><strong>Ordinamento dei Beni</strong>: <code>python     beni_ordinati = sorted(beni, key=lambda x: valutazioni['Alice'][x] + valutazioni['Bob'][x], reverse=True)</code>
<ul>
<li>Ordina i beni in base alla somma delle valutazioni di Alice e Bob, in ordine decrescente.</li>
</ul></li>
<li><strong>Assegnazione dei Beni</strong>: <code>python     for bene in beni_ordinati:         if valori_totali['Alice'] &lt;= valori_totali['Bob']:             assegnazione['Alice'].append(bene)             valori_totali['Alice'] += valutazioni['Alice'][bene]         else:             assegnazione['Bob'].append(bene)             valori_totali['Bob'] += valutazioni['Bob'][bene]</code>
<ul>
<li>Assegna i beni in modo da bilanciare i valori totali tra Alice e Bob. Se il valore totale di Alice è minore o uguale a quello di Bob, il bene viene assegnato ad Alice, altrimenti a Bob.</li>
</ul></li>
<li><strong>Verifica e Correzione delle Invidie</strong>: <code>python     for bene in beni_ordinati:         if valutazioni['Alice'][bene] &gt; valutazioni['Bob'][bene] and bene in assegnazione['Bob']:             if valori_totali['Alice'] &lt; valori_totali['Bob']:                 assegnazione['Bob'].remove(bene)                 assegnazione['Alice'].append(bene)                 valori_totali['Alice'] += valutazioni['Alice'][bene]                 valori_totali['Bob'] -= valutazioni['Bob'][bene]         elif valutazioni['Bob'][bene] &gt; valutazioni['Alice'][bene] and bene in assegnazione['Alice']:             if valori_totali['Bob'] &lt; valori_totali['Alice']:                 assegnazione['Alice'].remove(bene)                 assegnazione['Bob'].append(bene)                 valori_totali['Bob'] += valutazioni['Bob'][bene]                 valori_totali['Alice'] -= valutazioni['Alice'][bene]</code>
<ul>
<li>Verifica se ci sono invidie e corregge le assegnazioni di conseguenza. Se Alice valuta un bene più di Bob e il bene è assegnato a Bob, viene riassegnato ad Alice se il valore totale di Alice è inferiore a quello di Bob, e viceversa.</li>
</ul></li>
<li><strong>Ritorno delle Assegnazioni</strong>: <code>python     return assegnazione</code>
<ul>
<li>Ritorna il dizionario delle assegnazioni finali.</li>
</ul></li>
</ol>
<p><strong>Caso d’Uso Reale</strong></p>
<p>Divisione di una serie di oggetti di valore tra Alice e Bruno, in modo che nessuno dei due si senta invidioso dell’altro. Ad esempio, supponiamo che Alice e Bruno debbano dividersi i seguenti beni con le rispettive valutazioni personali:</p>
<div id="cell-76" class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>beni <span class="op">=</span> [<span class="st">'orologio'</span>, <span class="st">'libro'</span>, <span class="st">'penna'</span>]</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>valutazioni <span class="op">=</span> {</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Alice'</span>: {<span class="st">'orologio'</span>: <span class="dv">10</span>, <span class="st">'libro'</span>: <span class="dv">5</span>, <span class="st">'penna'</span>: <span class="dv">1</span>},</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Bob'</span>: {<span class="st">'orologio'</span>: <span class="dv">8</span>, <span class="st">'libro'</span>: <span class="dv">7</span>, <span class="st">'penna'</span>: <span class="dv">2</span>}</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Utilizzando la funzione <code>allocazione_senza_invidia</code>, possiamo ottenere una divisione equa:</p>
<div id="cell-78" class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>assegnazione <span class="op">=</span> allocazione_senza_invidia(beni, valutazioni)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(assegnazione)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>{'Alice': ['orologio'], 'Bob': ['libro', 'penna']}</code></pre>
</div>
</div>
<p>In questo caso, Alice riceve l’orologio, mentre Bob riceve il libro e la penna, garantendo che nessuno dei due si senta invidioso dell’altro.</p>
</section>
<section id="gli-algoritmi-di-divisione-equa-in-letteratura" class="level3">
<h3 class="anchored" data-anchor-id="gli-algoritmi-di-divisione-equa-in-letteratura">Gli algoritmi di divisione equa in letteratura</h3>
<p>Gli algoritmi di ripartizione equa sono un insieme di metodi utilizzati per distribuire risorse limitate tra più utenti o gruppi in modo equo e imparziale. Questi algoritmi mirano a garantire che ogni utente o gruppo riceva una quota equa delle risorse, tenendo conto di fattori come le esigenze individuali, le priorità e le limitazioni. Esistono diversi tipi di algoritmi di ripartizione equa, tra questi si citano:</p>
<p><strong>1. Metodi per la Divisione Equa tra Due Partecipanti</strong> - <strong>Adjusted Winner (AW)</strong>: Algoritmo per la divisione equa di oggetti tra due partecipanti. - Citazione: Brams, S. J., &amp; Taylor, A. D. (1996). <em>Fair Division: From Cake-Cutting to Dispute Resolution</em>. Cambridge University Press.</p>
<ul>
<li><strong>Divide and Choose</strong>: Metodo classico per la divisione equa tra due partecipanti.
<ul>
<li>Citazione: Steinhaus, H. (1948). <em>The problem of fair division</em>. Econometrica, 16(1), 101-104.</li>
</ul></li>
<li><strong>Last Diminisher</strong>: Estensione del metodo Divide and Choose per più partecipanti.
<ul>
<li>Citazione: Steinhaus, H. (1948). <em>The problem of fair division</em>. Econometrica, 16(1), 101-104.</li>
</ul></li>
</ul>
<p><strong>Metodi per la Divisione Equa tra Tre O Più Partecipanti</strong> - <strong>Algoritmo di Selfridge-Conway</strong>: Metodo per la divisione equa di una torta tra tre partecipanti. - Citazione: Robertson, J., &amp; Webb, W. (1998). <em>Cake-cutting algorithms: Be fair if you can</em>. AK Peters/CRC Press.</p>
<ul>
<li><strong>Algoritmo di Dubins-Spanier</strong>: Metodo per la divisione equa di una risorsa continua tra n partecipanti.
<ul>
<li>Citazione: Dubins, L. E., &amp; Spanier, E. H. (1961). <em>How to cut a cake fairly</em>. The American Mathematical Monthly, 68(1), 1-17.</li>
</ul></li>
<li><strong>Algoritmo di Stromquist</strong>: Metodo per la divisione envy-free tra tre partecipanti usando un numero finito di tagli.
<ul>
<li>Citazione: Stromquist, W. (1980). <em>How to cut a cake fairly</em>. The American Mathematical Monthly, 87(8), 640-644.</li>
</ul></li>
<li><strong>Algoritmo di Austin</strong>: Metodo per la divisione envy-free tra quattro o più partecipanti.
<ul>
<li>Citazione: Austin, A. K. (1982). <em>Sharing a cake</em>. The Mathematical Gazette, 66(437), 212-215.</li>
</ul></li>
<li><strong>Algoritmo di Brams-Taylor-Zwicker</strong>: Metodo per la divisione equa tra più di tre partecipanti.
<ul>
<li>Citazione: Brams, S. J., Taylor, A. D., &amp; Zwicker, W. S. (1997). <em>A moving-knife solution to the four-person envy-free cake-division problem</em>. Proceedings of the American Mathematical Society, 125(2), 547-554.</li>
</ul></li>
<li><strong>Algoritmo di Brams-Taylor per n partecipanti</strong>: Metodo per la divisione envy-free tra n partecipanti.
<ul>
<li>Citazione: Brams, S. J., &amp; Taylor, A. D. (1995). <em>An envy-free cake division protocol</em>. The American Mathematical Monthly, 102(1), 9-18.</li>
</ul></li>
</ul>
<p><strong>Metodi di Allocazione Proporzionale</strong> - <strong>Proportional Allocation</strong>: Metodi per allocare risorse in modo proporzionale alle richieste o ai diritti delle parti. - Citazione: Young, H. P. (1994). <em>Equity: In Theory and Practice</em>. Princeton University Press.</p>
<ul>
<li><strong>Maximin Share Allocation</strong>: Concetto di equità per l’allocazione di beni indivisibili.
<ul>
<li>Citazione: Budish, E. (2011). <em>The combinatorial assignment problem: Approximate competitive equilibrium from equal incomes</em>. Journal of Political Economy, 119(6), 1061-1103.</li>
</ul></li>
<li><strong>Competitive Equilibrium from Equal Incomes (CEEI)</strong>: Meccanismo per l’allocazione equa di risorse divisibili.
<ul>
<li>Citazione: Varian, H. R. (1974). <em>Equity, envy, and efficiency</em>. Journal of Economic Theory, 9(1), 63-91.</li>
</ul></li>
</ul>
<p><strong>Metodi di Assegnazione Casuale</strong> - <strong>Random Priority (RP)</strong>: Meccanismo di assegnazione casuale utilizzato in vari contesti, come l’assegnazione di dormitori universitari. - Citazione: Abdulkadiroğlu, A., &amp; Sönmez, T. (1998). <em>Random serial dictatorship and the core from random endowments in house allocation problems</em>. Econometrica, 66(3), 689-701.</p>
<ul>
<li><strong>Probabilistic Serial (PS)</strong>: Meccanismo di assegnazione con garanzie di efficienza ordinale.
<ul>
<li>Citazione: Bogomolnaia, A., &amp; Moulin, H. (2001). <em>A new solution to the random assignment problem</em>. Journal of Economic Theory, 100(2), 295-328.</li>
</ul></li>
</ul>
<p><strong>Metodi Vari</strong> - <strong>Undercut Procedure</strong>: Metodo per la divisione equa di beni indivisibili. - Citazione: Brams, S. J., &amp; Taylor, A. D. (1999). <em>The Win-Win Solution: Guaranteeing Fair Shares to Everybody</em>. W. W. Norton &amp; Company.</p>
<ul>
<li><strong>Picking Sequence Protocols</strong>: Metodi di divisione basati su sequenze di scelte.
<ul>
<li>Citazione: Bouveret, S., &amp; Lang, J. (2011). <em>A general elicitation-free protocol for allocating indivisible goods</em>. In <em>Twenty-Second International Joint Conference on Artificial Intelligence</em>.</li>
</ul></li>
<li><strong>Algoritmo di Robertson-Webb</strong>: Framework per misurare la complessità degli algoritmi di cake-cutting.
<ul>
<li>Citazione: Robertson, J., &amp; Webb, W. (1998). <em>Cake-cutting algorithms: Be fair if you can</em>. AK Peters/CRC Press.</li>
</ul></li>
</ul>
<p>Per chi vuole provare ad applicare gli algoritmi equitativi in casi reali su una piattaforma online si segnala l’interessante sito: <a href="http://www.spliddit.org/"><strong>Spliddit Algorithms</strong></a>: Suite di algoritmi equitativi implementati sulla piattaforma web Spliddit (Goldman, J., &amp; Procaccia, A. D. (2014). <em>Spliddit: Unleashing fair division algorithms</em>. ACM SIGecom Exchanges, 13(2), 41-46).</p>
<div id="cell-80" class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> adjusted_winner(items, alice_values, bob_values, max_iterations<span class="op">=</span><span class="dv">1000</span>):</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(items)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    alice_items <span class="op">=</span> []</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    bob_items <span class="op">=</span> []</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fase 1: Assegnazione iniziale</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> alice_values[i] <span class="op">&gt;=</span> bob_values[i]:</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>            alice_items.append(items[i])</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>            bob_items.append(items[i])</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fase 2: Calcolo dei punteggi</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>    alice_score <span class="op">=</span> <span class="bu">sum</span>(alice_values[items.index(item)] <span class="cf">for</span> item <span class="kw">in</span> alice_items)</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    bob_score <span class="op">=</span> <span class="bu">sum</span>(bob_values[items.index(item)] <span class="cf">for</span> item <span class="kw">in</span> bob_items)</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fase 3: Aggiustamento</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>    iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">abs</span>(alice_score <span class="op">-</span> bob_score) <span class="op">&gt;</span> <span class="fl">0.001</span> <span class="kw">and</span> iterations <span class="op">&lt;</span> max_iterations:</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> alice_score <span class="op">&gt;</span> bob_score:</span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a>            item_to_transfer <span class="op">=</span> <span class="bu">max</span>(alice_items, key<span class="op">=</span><span class="kw">lambda</span> x: bob_values[items.index(x)] <span class="op">/</span> alice_values[items.index(x)])</span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a>            alice_items.remove(item_to_transfer)</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a>            bob_items.append(item_to_transfer)</span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a>            alice_score <span class="op">-=</span> alice_values[items.index(item_to_transfer)]</span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a>            bob_score <span class="op">+=</span> bob_values[items.index(item_to_transfer)]</span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a>            item_to_transfer <span class="op">=</span> <span class="bu">max</span>(bob_items, key<span class="op">=</span><span class="kw">lambda</span> x: alice_values[items.index(x)] <span class="op">/</span> bob_values[items.index(x)])</span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a>            bob_items.remove(item_to_transfer)</span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>            alice_items.append(item_to_transfer)</span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a>            bob_score <span class="op">-=</span> bob_values[items.index(item_to_transfer)]</span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a>            alice_score <span class="op">+=</span> alice_values[items.index(item_to_transfer)]</span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a>        iterations <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> alice_items, bob_items, alice_score, bob_score, iterations</span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Esempio di utilizzo</span></span>
<span id="cb57-39"><a href="#cb57-39" aria-hidden="true" tabindex="-1"></a>items <span class="op">=</span> [<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>, <span class="st">'D'</span>]</span>
<span id="cb57-40"><a href="#cb57-40" aria-hidden="true" tabindex="-1"></a>alice_values <span class="op">=</span> [<span class="dv">30</span>, <span class="dv">25</span>, <span class="dv">35</span>, <span class="dv">10</span>]</span>
<span id="cb57-41"><a href="#cb57-41" aria-hidden="true" tabindex="-1"></a>bob_values <span class="op">=</span> [<span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">25</span>, <span class="dv">25</span>]</span>
<span id="cb57-42"><a href="#cb57-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-43"><a href="#cb57-43" aria-hidden="true" tabindex="-1"></a>alice_final, bob_final, alice_final_score, bob_final_score, iterations_final <span class="op">=</span> adjusted_winner(items, alice_values, bob_values)</span>
<span id="cb57-44"><a href="#cb57-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Iterazioni necessarie:"</span>, iterations_final)</span>
<span id="cb57-45"><a href="#cb57-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Alice riceve:"</span>, alice_final)</span>
<span id="cb57-46"><a href="#cb57-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Bob riceve:"</span>, bob_final)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Iterazioni necessarie: 1000
Alice riceve: ['A', 'C']
Bob riceve: ['B', 'D']</code></pre>
</div>
</div>
</section>
</section>
<section id="algoritmi-predittivi" class="level2">
<h2 class="anchored" data-anchor-id="algoritmi-predittivi">Algoritmi Predittivi</h2>
<p>Gli algoritmi di predizione sono usati per creare modelli basati sull’ apprendedimento dei dati misurati o prodotti in un certo dominio applicativo al fine di fare previsioni su eventi futuri. Questi algoritmi possono essere classificati in diverse categorie in base al tipo di apprendimento, al tipo di output, e alle tecniche utilizzate:</p>
<p><strong>Classificazione Basata sul Tipo di Apprendimento:</strong> 1. <strong>Apprendimento Supervisionato</strong>: Gli algoritmi di apprendimento supervisionato richiedono un set di dati etichettato per l’addestramento. Utilizzano queste etichette per apprendere una funzione che mappa gli input agli output desiderati. Esempi includono la regressione lineare, gli alberi decisionali e le reti neurali¹. 2. <strong>Apprendimento Non Supervisionato</strong>: Questi algoritmi scoprono pattern nascosti o strutture nei dati non etichettati. Tecniche comuni sono la clusterizzazione e la riduzione della dimensionalità¹. 3. <strong>Apprendimento Semi-supervisionato e Rinforzato</strong>: Combinano elementi dei primi due tipi, utilizzando un piccolo set di dati etichettati insieme a una grande quantità di dati non etichettati, o apprendendo attraverso il rinforzo da un ambiente¹.</p>
<p><strong>Classificazione Basata sul Tipo di Output:</strong> 1. <strong>Classificazione</strong>: Quando l’output è una categoria, come “spam” o “non spam” in un filtro di posta elettronica, si parla di classificazione. Gli algoritmi di classificazione assegnano un’etichetta discreta a un’istanza di input¹. 2. <strong>Regressione</strong>: Se l’output è un valore continuo, come il prezzo di una casa, si utilizza la regressione. Gli algoritmi di regressione prevedono un valore numerico basato sugli input¹. 3. <strong>Ranking</strong>: Alcuni algoritmi ordinano gli elementi in base alla probabilità di appartenenza a una certa categoria o valore¹.</p>
<p><strong>Classificazione Basata sulle Tecniche Utilizzate:</strong> 1. <strong>Alberi Decisionali</strong>: Suddividono i dati in modo gerarchico basandosi su attributi specifici. Sono semplici da interpretare ma possono soffrire di overfitting². 2. <strong>Random Forest</strong>: Una collezione di alberi decisionali che riduce il rischio di overfitting e gestisce meglio le variabili non correlate². 3. <strong>Support Vector Machine (SVM)</strong>: Trovano il miglior iperpiano che separa i dati in classi. Sono efficaci in spazi ad alta dimensionalità². 4. <strong>K-Nearest Neighbors (K-NN)</strong>: Classificano i nuovi dati in base alla classe più comune tra i vicini più prossimi. Sono semplici da implementare ma computazionalmente costosi². 5. <strong>Reti Neurali</strong>: Sono modelli ispirati al funzionamento del cervello umano e possono catturare relazioni complesse nei dati¹.</p>
<p>Ogni algoritmo ha i suoi vantaggi e svantaggi, e la scelta dipende da vari fattori come la dimensione e la natura del dataset, la velocità richiesta, la trasparenza del modello e la capacità di gestire dati non lineari o mancanti. Ad esempio, gli alberi decisionali sono facili da interpretare ma possono soffrire di overfitting, mentre le SVM sono efficaci con dataset di piccole dimensioni ma meno efficienti con dataset molto grandi².</p>
<p>L’agente deve imparare a riconoscere alcune configurazioni del suo percepito sulla base di un esperienza fatta su casi detti di training e deve essere in grado di riconoscere un nuovo percepito mai visto prima.</p>
<p>Il percepito dell’agente è composto da dati, caratteristiche, che possono essere di tipo continuo (es. temperatura) o categoriali (es. colore rosso). I dati categoriali possono essere ordinabili (es. scarso, insufficiente, …) o non ordinabili (es. sesso)</p>
<p>All’agente può essere chiesto di predire un dato continuo, nel qual caso si tratta di predizione o regressione, oppure può essere chiesto di predire un dato categoriale, nel qual caso si tratta di classificazione.</p>
<p>Il processo di predizione segue il seguente flusso:</p>
<ol type="1">
<li><strong>Definizione del Problema</strong>
<ul>
<li>Identificare il tipo di problema (classificazione, regressione, clustering)</li>
</ul></li>
<li><strong>Raccolta dei Dati</strong>
<ul>
<li>Ottenere dati rilevanti e di qualità</li>
</ul></li>
<li><strong>Pre-elaborazione dei Dati</strong>
<ul>
<li>Pulizia dei dati</li>
<li>Gestione dei valori mancanti</li>
<li>Normalizzazione</li>
<li>Riduzione della dimensionalità</li>
</ul></li>
<li><strong>Divisione dei Dati</strong>
<ul>
<li>Creare set di addestramento e di test</li>
</ul></li>
<li><strong>Scelta dell’Algoritmo</strong>
<ul>
<li>Selezionare l’algoritmo adatto al problema</li>
</ul></li>
<li><strong>Addestramento del Modello</strong>
<ul>
<li>Imparare dai dati di addestramento</li>
</ul></li>
<li><strong>Valutazione del Modello</strong>
<ul>
<li>Testare il modello con il set di test</li>
</ul></li>
<li><strong>Ottimizzazione</strong>
<ul>
<li>Regolare i parametri per migliorare le prestazioni</li>
</ul></li>
<li><strong>Deployment</strong>
<ul>
<li>Implementare il modello in produzione</li>
</ul></li>
<li><strong>Monitoraggio e Manutenzione</strong>
<ul>
<li>Aggiornare e ottimizzare il modello nel tempo</li>
</ul></li>
</ol>
<p>Nei prossimi paragrafi si presenterà una descrizione di ognuno di questi passi con un esempio concreto.</p>
<section id="definizione-del-problema" class="level3">
<h3 class="anchored" data-anchor-id="definizione-del-problema">Definizione del Problema</h3>
<p>Questp è il primo passo nel processo di predizione nell’intelligenza artificiale. Questa fase richiede una comprensione chiara e precisa dell’obiettivo che si desidera raggiungere con l’algoritmo di predizione. Che si tratti di prevedere il comportamento del consumatore, di diagnosticare malattie o di identificare frodi, è fondamentale stabilire parametri chiari e misurabili. La definizione del problema guida tutte le fasi successive, dalla raccolta dei dati alla scelta dell’algoritmo più adatto, assicurando che l’intero processo sia allineato con l’obiettivo finale. Un’accurata definizione del problema è la base per un modello predittivo efficace e funzionale.</p>
<p><strong>esempio pratico</strong>:</p>
<p>Un esempio pratico di definizione del problema nel contesto del processo di predizione potrebbe essere il seguente scenario nel settore della vendita al dettaglio:</p>
<p><strong>Scenario</strong>: Un’azienda di e-commerce ha notato un aumento del tasso di abbandono del carrello da parte dei clienti durante il processo di checkout.</p>
<p><strong>Definizione del Problema</strong>: - <strong>Obiettivo</strong>: Ridurre il tasso di abbandono del carrello e aumentare il tasso di conversione delle vendite. - <strong>Dati Necessari</strong>: Dati di navigazione del sito web, transazioni completate e abbandonate, feedback dei clienti, dati demografici e comportamentali degli utenti. - <strong>Ipotesi</strong>: Si ipotizza che l’abbandono del carrello possa essere dovuto a fattori quali costi di spedizione inaspettati, complessità del processo di checkout, mancanza di opzioni di pagamento, o problemi tecnici del sito. - <strong>Metodologia</strong>: Utilizzare algoritmi di machine learning per analizzare i pattern di abbandono e identificare i punti critici nel processo di checkout. - <strong>Soluzione Attesa</strong>: Implementare miglioramenti mirati nel processo di checkout basati sui risultati dell’analisi predittiva, come la semplificazione delle procedure, l’aggiunta di più opzioni di pagamento, o la trasparenza dei costi di spedizione.</p>
<p>In questo esempio, la definizione del problema è ben strutturata e orientata all’obiettivo di migliorare l’esperienza dell’utente e ottimizzare il processo di vendita. L’analisi predittiva aiuterà l’azienda a comprendere le cause dell’abbandono del carrello e a formulare interventi efficaci per risolvere il problema.</p>
</section>
<section id="raccolta-dei-dati" class="level3">
<h3 class="anchored" data-anchor-id="raccolta-dei-dati">Raccolta dei Dati</h3>
<p>Si tratta di acquisire informazioni rilevanti per il problema da risolvere. Questo processo non si limita alla mera acquisizione di dati grezzi; è una pratica strategica che trasforma questi dati in insights preziosi, capaci di guidare decisioni informate. I dati possono essere raccolti da fonti interne come database aziendali, o esterne come social media, sensori IoT (Internet of Things), o registri pubblici. La raccolta deve essere sistematica e organizzata, assicurando che i dati siano accurati, completi e aggiornati. È fondamentale anche considerare la privacy e la sicurezza dei dati durante la raccolta e l’elaborazione.</p>
<p><strong>Esempio Pratico</strong>: Un ospedale vuole sviluppare un sistema di predizione per identificare i pazienti a rischio di riammissione entro 30 giorni dalla dimissione. La raccolta dei dati inizia con l’identificazione delle informazioni necessarie, che includono dati demografici dei pazienti, diagnosi, trattamenti ricevuti, durata del soggiorno ospedaliero e dati storici sulle riammissioni. Questi dati vengono poi raccolti da cartelle cliniche elettroniche, registri ospedalieri e interviste con il personale sanitario. Una volta raccolti, i dati sono puliti e preparati per l’analisi, rimuovendo eventuali errori o duplicazioni e assicurando che siano in un formato utilizzabile per l’addestramento dell’algoritmo di predizione. Questo processo permette all’ospedale di costruire un modello predittivo che può aiutare a migliorare la qualità delle cure e ridurre i costi associati alle riammissioni non necessarie.</p>
</section>
<section id="pre-elaborazione-dei-dati" class="level3">
<h3 class="anchored" data-anchor-id="pre-elaborazione-dei-dati">Pre-elaborazione dei Dati</h3>
<p>Si prepara il dataset per garantire che l’algoritmo di machine learning funzioni in modo ottimale. Questo passo include diverse attività chiave:</p>
<ul>
<li><p><strong>Pulizia dei dati</strong>: correzione o rimozione di dati errati, corrotti, duplicati o non pertinenti. La pulizia assicura che il modello non apprenda da informazioni fuorvianti o irrilevanti.</p></li>
<li><p><strong>Gestione dei valori mancanti</strong>: I dati incompleti sono comuni in molti dataset. La gestione dei valori mancanti può includere tecniche come l’imputazione, dove i valori mancanti sono sostituiti con stime, o l’eliminazione delle righe o colonne con dati mancanti.</p></li>
<li><p><strong>Normalizzazione</strong>: scalatura dei dati in modo che attributi con ampi intervalli di valori non dominino quelli con intervalli più stretti. La normalizzazione è essenziale per algoritmi che sono sensibili alle scale dei dati, come la regressione lineare o le reti neurali.</p></li>
<li><p><strong>Riduzione della dimensionalità</strong>: Tecniche come l’Analisi delle Componenti Principali (PCA) sono utilizzate per ridurre il numero di variabili nel dataset, mantenendo solo quelle più informative. Questo non solo semplifica il modello, ma può anche migliorare le prestazioni riducendo il rischio di overfitting.</p></li>
</ul>
<p><strong>Esempio Pratico</strong>: Immaginiamo di avere un dataset di immagini per un sistema di riconoscimento facciale. La pulizia dei dati potrebbe comportare la rimozione di immagini sfocate o non riconoscibili. Per gestire i valori mancanti, potremmo utilizzare tecniche di imputazione per completare le caratteristiche facciali parzialmente occluse. La normalizzazione potrebbe essere applicata per assicurare che le variazioni di luminosità siano tutte uguali in modo da non influenzino il riconoscimento. Infine, si procede a uniformare il formato file e le dimensioni. Ad esempio, formato file jpg e dimensioni 128x128 pizel.</p>
</section>
<section id="divisione-dei-dati" class="level3">
<h3 class="anchored" data-anchor-id="divisione-dei-dati">Divisione dei Dati</h3>
<p>Si separa il dataset in due o più gruppi per diversi scopi: addestramento, validazione e test. Questa divisione serve per avere dati per valutare l’efficacia e la generalizzabilità del modello predittivo. Il set di addestramento è utilizzato per insegnare all’algoritmo a riconoscere i pattern nei dati. Il set di validazione, quando presente, aiuta a ottimizzare i parametri del modello e a prevenire l’overfitting. Infine, il set di test serve a valutare le prestazioni del modello su dati non visti durante l’addestramento, fornendo una stima dell’errore di generalizzazione.</p>
<p>La proporzione della divisione può variare, ma una suddivisione comune è 70% per l’addestramento, 15% per la validazione e 15% per il test. È importante che la divisione dei dati sia rappresentativa dell’intero dataset, quindi tecniche come il campionamento stratificato possono essere utilizzate per mantenere la stessa distribuzione delle classi in ciascun set.</p>
<p><strong>Esempio Pratico</strong>: Un’azienda di telecomunicazioni vuole prevedere quali clienti potrebbero lasciare l’azienda (churn). Il dataset include variabili come l’uso dei servizi, la durata del contratto, e la soddisfazione del cliente. Dopo la pre-elaborazione, il dataset di 1000 clienti viene diviso in 700 per l’addestramento, 150 per la validazione e 150 per il test. Questa divisione permette all’azienda di addestrare il modello sul set di addestramento, ottimizzarlo sul set di validazione e infine valutare la sua capacità di prevedere il churn sul set di test.</p>
<p>Il <strong>training set</strong>, il <strong>validation set</strong> e il <strong>test set</strong> sono tre sottoinsiemi di dati utilizzati nel processo di machine learning per sviluppare e valutare modelli predittivi. Ecco a cosa servono:</p>
<ul>
<li><p><strong>Training Set</strong>: È il sottoinsieme di dati utilizzato per addestrare il modello. Il modello apprende a riconoscere i pattern e le relazioni tra i dati in modo che possa fare previsioni o prendere decisioni. Tipicamente, è il più grande dei tre set e fornisce la base su cui il modello costruisce la sua comprensione del problema.</p></li>
<li><p><strong>Validation Set</strong>: Viene utilizzato per fornire una valutazione imparziale delle prestazioni del modello durante la fase di addestramento. Questo set è cruciale per il tuning dei parametri del modello, come la scelta del numero di strati in una rete neurale o il valore di regolarizzazione in una regressione. Aiuta a prevenire l’overfitting, che si verifica quando un modello è troppo complesso e si adatta troppo bene ai dati di addestramento, perdendo la capacità di generalizzare su nuovi dati.</p></li>
<li><p><strong>Test Set</strong>: Dopo che il modello è stato addestrato e validato, il test set viene utilizzato per valutare le prestazioni finali del modello. Questo set non è mai stato visto dal modello durante l’addestramento e simula dati del mondo reale su cui il modello dovrà operare. Fornisce una misura oggettiva di quanto bene il modello possa aspettarsi di esibirsi in pratica.</p></li>
</ul>
<p><strong>Esempio Pratico</strong>: Immaginiamo di voler studiare il problema della previsione dei prezzi delle case basato su caratteristiche come la posizione, la dimensione e l’anno di costruzione. Il training set potrebbe includere migliaia di esempi di case vendute negli ultimi anni. Il validation set potrebbe essere usato per regolare i parametri del modello, come la complessità del modello stesso. Infine, il test set, che consiste in dati recenti di vendite di case, verrebbe utilizzato per valutare quanto accuratamente il modello può prevedere i prezzi delle case in condizioni attuali di mercato.</p>
</section>
<section id="scelta-dell-algoritmo" class="level3">
<h3 class="anchored" data-anchor-id="scelta-dell-algoritmo">Scelta dell’ algoritmo</h3>
<p>La scelta dell’algoritmo determina l’approccio con cui il modello analizzerà i dati e farà previsioni. La selezione dell’algoritmo dipende da vari fattori, tra cui il tipo di problema (classificazione, regressione, clustering), la natura dei dati, la dimensione del dataset e le risorse computazionali disponibili. Ad esempio, per problemi di classificazione, algoritmi come le reti neurali, le macchine a vettori di supporto (SVM) e gli alberi decisionali sono spesso utilizzati. Per la regressione, si possono considerare algoritmi come la regressione lineare, la regressione polinomiale o le reti neurali. È importante anche considerare la complessità dell’algoritmo: algoritmi più complessi possono offrire maggiore accuratezza, ma richiedono più tempo e risorse per l’addestramento.</p>
<p><strong>Esempio Pratico</strong>: Nell’ esempio della predizione del prezzo delle case introdotto nel precedente paragrafo, se si dispone di un dataset con caratteristiche come la dimensione della casa, il numero di stanze, la posizione, ecc., si potrebbe scegliere un algoritmo di regressione lineare per iniziare, poiché è semplice e offre una buona interpretabilità. Tuttavia, se i dati mostrano relazioni non lineari, si potrebbe passare a un algoritmo più complesso come una rete neurale per migliorare la precisione delle previsioni.</p>
</section>
<section id="addestramento-del-modello" class="level3">
<h3 class="anchored" data-anchor-id="addestramento-del-modello">Addestramento del modello</h3>
<p>L’addestramento di un modello di machine learning è un processo iterativo che consiste nell’esporre un algoritmo a un ampio dataset di apprendimento, con l’obiettivo di insegnargli a riconoscere pattern e a fare predizioni accurate su nuovi dati. La qualità e l’efficacia di un modello dipendono fortemente dalla scelta dell’algoritmo, dalla qualità dei dati e dalle tecniche di addestramento utilizzate.</p>
<p><strong>Modalità di apprendimento</strong> Esistono diverse modalità di apprendimento:</p>
<ul>
<li><strong>Apprendimento supervisionato</strong>: Il modello viene addestrato su un dataset etichettato, dove ogni esempio è associato a una risposta corretta. L’obiettivo è insegnare al modello a mappare nuovi input alle loro rispettive etichette.</li>
<li><strong>Apprendimento non supervisionato</strong>: Il modello lavora con dati non etichettati, cercando di scoprire strutture nascoste nei dati, come gruppi di dati simili (clustering).</li>
<li><strong>Apprendimento semi-supervisionato</strong>: Combina elementi dei due approcci precedenti, utilizzando sia dati etichettati che non etichettati.</li>
</ul>
<p><strong>Hardware e software</strong></p>
<p>L’addestramento di modelli complessi richiede risorse computazionali significative. Le GPU e le TPU sono hardware specializzati che accelerano i calcoli necessari per l’addestramento di reti neurali profonde. Inoltre, sono necessari software specifici per definire le architetture delle reti neurali e gestire il processo di addestramento.</p>
<p><strong>Overfitting e underfitting</strong> Durante l’addestramento, è fondamentale evitare due problemi comuni: l’overfitting e l’underfitting.</p>
<p><strong>Overfitting</strong>: Si verifica quando il modello si adatta troppo ai dati di addestramento, perdendo la capacità di generalizzare a nuovi dati. In questo caso, il modello memorizza i dettagli specifici dei dati di addestramento invece di apprendere le caratteristiche generali. <strong>Underfitting</strong>: Si verifica quando il modello è troppo semplice per catturare la complessità dei dati. In questo caso, il modello non è in grado di apprendere le relazioni significative tra le variabili.</p>
<p><strong>Implicazioni etiche</strong></p>
<p>L’addestramento di modelli di machine learning solleva importanti questioni etiche. È fondamentale utilizzare dataset rappresentativi e bilanciati per evitare bias e discriminazioni. Inoltre, è necessario considerare le potenziali conseguenze negative dell’utilizzo di modelli in contesti reali, come la privacy e la sicurezza dei dati.</p>
</section>
<section id="valutazione-del-modello" class="level3">
<h3 class="anchored" data-anchor-id="valutazione-del-modello">Valutazione del modello</h3>
<p>La valutazione del modello è una fase cruciale nel processo di sviluppo di un modello di machine learning, poiché consente di misurare la capacità del modello addestrato di generalizzare a nuovi dati, ovvero di fare predizioni accurate su esempi che non ha mai visto durante l’addestramento.</p>
<p><strong>Metriche di valutazione</strong></p>
<p>Le metriche di valutazione variano a seconda del tipo di problema. Nei <strong>problemi di classificazione</strong>, ad esempio, si utilizzano metriche come:</p>
<ul>
<li><strong>Accuratezza</strong>: misura la percentuale di casi classificati correttamente.</li>
<li><strong>Precisione</strong>: misura la percentuale di veri positivi (cioè quei casi che effettivamente appartengono alla classe positiva) tra i casi classificati come positivi.</li>
<li><strong>Richiamo</strong>: misura la percentuale di veri positivi tra tutti i casi positivi reali.</li>
<li><strong>F1-score</strong>: misura la media armonica tra precisione e richiamo.</li>
<li><strong>Curva ROC</strong> (Receiver Operating Characteristic) con l’area sotto la curva (AUC): misura la capacità del modello di distinguere correttamente tra le classi.</li>
</ul>
<p>Nei <strong>problemi di regressione</strong>, invece, si utilizzano metriche come:</p>
<ul>
<li><strong>Errore quadratico medio (MSE)</strong>: misura la differenza media quadratica tra i valori predetti dal modello e i valori reali.</li>
<li><strong>Coefficiente di determinazione (R²)</strong>: misura la percentuale di variazione dei valori predetti rispetto ai valori reali.</li>
</ul>
<p>Spero che queste correzioni siano utili! Hai altre domande o c’è qualcos’altro su cui posso aiutarti? 😊 <strong>Analisi dei risultati</strong></p>
<p>L’analisi dei risultati della valutazione permette di identificare eventuali problemi come l’overfitting o l’underfitting. L’overfitting si verifica quando il modello si adatta troppo ai dati di addestramento, perdendo la capacità di generalizzare a nuovi dati. L’underfitting si verifica quando il modello è troppo semplice e non riesce a catturare la complessità dei dati.</p>
<p><strong>Esempio pratico</strong>: Consideriamo un modello di machine learning addestrato per predire la probabilità di ricidività di un reo in base ai dati raccolti su di lui. Dopo l’addestramento, il modello viene valutato su un dataset di test che contiene informazioni su nuovi reati. Utilizzando la Cross-validation, calcolando metriche come l’accuratezza e il richiamo, possiamo valutare l’affidabilità delle predizioni del modello. Un’alta accuratezza indica che il modello è generalmente corretto nelle sue previsioni, mentre un alto richiamo indica che il modello è bravo a identificare i reati che effettivamente si sono verificati.</p>
</section>
<section id="ottimizzazione-degli-iperparametri" class="level3">
<h3 class="anchored" data-anchor-id="ottimizzazione-degli-iperparametri">Ottimizzazione degli iperparametri</h3>
<p>L’<strong>ottimizzazione degli iperparametri</strong> è un processo iterativo che consiste nel regolare i parametri esterni al modello che non vengono appresi durante l’addestramento, ma che influenzano significativamente le sue prestazioni. Esempi di iperparametri includono il tasso di apprendimento, la profondità di un albero decisionale o il numero di neuroni in una rete neurale.</p>
<p>L’obiettivo dell’ottimizzazione è individuare la combinazione di iperparametri che massimizza le prestazioni del modello su un dataset di valutazione indipendente. Per raggiungere questo obiettivo, si utilizzano diverse tecniche, tra cui:</p>
<ul>
<li><strong>Ricerca a griglia:</strong> Esplora sistematicamente tutte le possibili combinazioni di iperparametri all’interno di un intervallo specificato.</li>
<li><strong>Ricerca casuale:</strong> Seleziona casualmente combinazioni di iperparametri, potendo essere più efficiente della ricerca a griglia in spazi di ricerca ampi.</li>
<li><strong>Ottimizzazione bayesiana:</strong> Utilizza modelli probabilistici per guidare la ricerca verso le regioni dello spazio degli iperparametri più promettenti.</li>
</ul>
<p>Per valutare l’efficacia delle diverse combinazioni di iperparametri, si ricorre alla <strong>validazione incrociata</strong>. Questa tecnica consiste nel suddividere il dataset in più parti, addestrando il modello su una parte e valutandolo sulle altre. Ripetendo questo processo multiple volte, si ottiene una stima più robusta delle prestazioni del modello.</p>
<p>Tecniche come l’<strong>early stopping</strong> possono essere utilizzate per migliorare ulteriormente il processo di ottimizzazione. L’early stopping consiste nell’interrompere l’addestramento quando le prestazioni del modello sul dataset di convalida iniziano a peggiorare, evitando così l’overfitting.</p>
<p><strong>Esempio pratico:</strong> Consideriamo un modello di rete neurale convoluzionale (CNN) addestrato per classificare immagini di cani e gatti. Per ottimizzare le prestazioni del modello, potremmo variare i seguenti iperparametri: il numero di strati convoluzionali, il numero di filtri per strato, il tasso di apprendimento e la funzione di attivazione. Utilizzando la ricerca a griglia e la validazione incrociata, possiamo identificare la combinazione di iperparametri che porta alle migliori prestazioni. Inoltre, possiamo utilizzare l’early stopping per evitare di addestrare eccessivamente il modello.</p>
</section>
<section id="deployment" class="level3">
<h3 class="anchored" data-anchor-id="deployment">Deployment</h3>
<p>Il deployment è la fase finale del processo di predizione, in cui il modello addestrato e ottimizzato viene messo in produzione per essere utilizzato in applicazioni reali. Questa fase implica la preparazione del modello per l’integrazione con sistemi esistenti, garantendo che sia scalabile, affidabile e sicuro. Il deployment può avvenire su diverse piattaforme, come server locali, cloud o dispositivi edge (dispositivi periferici che elaborano i dati vicino alla fonte, riducendo la latenza e il carico sui server centrali), a seconda delle esigenze dell’applicazione. È importante notare che l’hardware necessario per il deployment è diverso da quello utilizzato per l’addestramento. Durante l’addestramento, sono necessarie risorse computazionali elevate, come GPU o TPU, per gestire i complessi calcoli e l’ottimizzazione dei parametri del modello. Tuttavia, una volta che il modello è addestrato, il deployment richiede meno potenza computazionale, poiché il modello deve solo eseguire previsioni basate sui dati in ingresso. Questo permette di utilizzare hardware meno potente e più economico per il deployment, riducendo i costi operativi.</p>
<p><strong>Sfide del deployment:</strong> * <strong>Scalabilità:</strong> Il sistema di deployment deve essere in grado di gestire un aumento del carico di lavoro e di scalare in modo elastico per soddisfare le esigenze dell’applicazione. * <strong>Affidabilità:</strong> Il modello deve essere disponibile e funzionante in modo continuo, minimizzando i tempi di fermo e garantendo la qualità delle previsioni. * <strong>Sicurezza:</strong> È fondamentale proteggere il modello e i dati sensibili da accessi non autorizzati e attacchi informatici.</p>
<p><strong>esempio pratico</strong>: Un esempio pratico di deployment è l’implementazione di un modello di raccomandazione per un sito di e-commerce. Supponiamo di avere un modello che suggerisce prodotti agli utenti basato sul loro comportamento di navigazione e acquisto. Dopo aver addestrato e ottimizzato il modello utilizzando hardware potente come GPU, il passo successivo è integrarlo con il sistema del sito web. Questo può comportare la creazione di API (Application Programming Interfaces, interfacce che permettono a diverse applicazioni di comunicare tra loro) che permettono al sito di inviare dati al modello e ricevere raccomandazioni in tempo reale. Una volta implementato, il modello può analizzare i dati degli utenti e fornire suggerimenti personalizzati, migliorando l’esperienza dell’utente e potenzialmente aumentando le vendite. Per garantire prestazioni elevate, il modello può essere deployato su un server cloud scalabile, come <strong>AWS</strong> (Amazon Web Services) o <strong>GCP</strong> (Google Cloud Platform).Monitorando le prestazioni del modello, è possibile fare aggiustamenti e aggiornamenti per mantenere alta la qualità delle raccomandazioni.</p>
</section>
<section id="monitoraggio-e-manutenzione" class="level3">
<h3 class="anchored" data-anchor-id="monitoraggio-e-manutenzione">Monitoraggio e manutenzione</h3>
<p>Il monitoraggio e la manutenzione sono attività cruciali nel ciclo di vita di un modello di predizione, volte a garantire che il modello rimanga accurato e affidabile nel tempo. Dopo il deployment, è essenziale monitorare continuamente le prestazioni del modello per rilevare eventuali degradi dovuti a cambiamenti nei dati o nel contesto operativo. Questo può includere il monitoraggio di indicatori di degrado come:</p>
<ol type="1">
<li><p><strong>Aumento dell’errore di previsione</strong>: Se il modello inizia a fare più errori nelle previsioni rispetto a prima, potrebbe essere un segnale di degrado. Questo può essere misurato attraverso metriche come l’errore quadratico medio (MSE) per i modelli di regressione o l’accuratezza per i modelli di classificazione.</p></li>
<li><p><strong>Diminuzione dell’accuratezza</strong>: Un calo nell’accuratezza complessiva del modello indica che le previsioni non sono più affidabili come in passato.</p></li>
<li><p><strong>Aumento dei falsi positivi/negativi</strong>: Per i modelli di classificazione, un aumento dei falsi positivi (previsioni errate di eventi positivi) o dei falsi negativi (previsioni errate di eventi negativi) può indicare che il modello non sta più funzionando correttamente.</p></li>
<li><p><strong>Cambiamenti nelle distribuzioni dei dati</strong>: Se i dati in ingresso cambiano significativamente rispetto ai dati su cui il modello è stato addestrato, il modello potrebbe non essere più in grado di generalizzare correttamente. Questo può essere monitorato attraverso tecniche di drift detection.</p></li>
<li><p><strong>Aumento del tempo di risposta</strong>: Se il modello impiega più tempo per fare previsioni, potrebbe essere un segnale che qualcosa non va, come un sovraccarico computazionale o inefficienze nel codice.</p></li>
</ol>
<p>La manutenzione del modello può comportare aggiornamenti periodici, riaddestramento con nuovi dati e ottimizzazioni per adattarsi a nuove condizioni. Inoltre, è importante implementare sistemi di allerta per notificare tempestivamente eventuali problemi. La manutenzione preventiva e correttiva aiuta a mantenere il modello efficiente e a evitare errori significativi che potrebbero influenzare le decisioni basate sulle sue previsioni.</p>
<p><strong>Esempio pratico</strong>: Un esempio pratico di monitoraggio e manutenzione è l’uso di un modello di rilevamento delle frodi in una banca. Dopo il deployment, il modello analizza le transazioni in tempo reale per identificare attività sospette. Il team di data science monitora costantemente le prestazioni del modello, verificando che mantenga un alto tasso di rilevamento delle frodi e un basso tasso di falsi positivi. Se il modello inizia a mostrare segni di degrado, come un aumento dei falsi positivi, il team può riaddestrarlo utilizzando dati più recenti o aggiustare i parametri per migliorare la sua accuratezza. Questo processo continuo garantisce che il modello rimanga efficace nel proteggere la banca dalle frodi.</p>
<p><strong>Esempio di algoritmo predittivo in Python:</strong></p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LogisticRegression</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Dati storici dei casi (caratteristiche e risultati)</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.array([[<span class="dv">25</span>, <span class="dv">1</span>], [<span class="dv">45</span>, <span class="dv">0</span>], [<span class="dv">35</span>, <span class="dv">1</span>], [<span class="dv">50</span>, <span class="dv">0</span>]])  <span class="co"># Età e tipo di crimine</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>])  <span class="co"># Risultato del caso (1 = colpevole, 0 = innocente)</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Addestramento del modello predittivo</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> LogisticRegression()</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>model.fit(X, y)</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Previsione di un nuovo caso</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>new_case <span class="op">=</span> np.array([[<span class="dv">30</span>, <span class="dv">1</span>]])  <span class="co"># Nuovo caso: 30 anni, tipo di crimine 1</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>prediction <span class="op">=</span> model.predict(new_case)</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Previsione del nuovo caso: </span><span class="sc">{</span><span class="st">'colpevole'</span> <span class="cf">if</span> prediction[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">'innocente'</span><span class="sc">}</span><span class="ss">."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In questo capitolo, abbiamo esplorato vari algoritmi utilizzati nell’intelligenza artificiale, con esempi pratici applicati alla giurisprudenza. Questi algoritmi sono strumenti potenti che possono aiutare a migliorare l’efficienza e l’equità nel contesto legale.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./1 elementi di Python.html" class="pagination-link" aria-label="Elementi di Python">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">Elementi di Python</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./3 machine learning.html" class="pagination-link" aria-label="Machine learning">
        <span class="nav-page-text"><span class="chapter-title">Machine learning</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Laboratorio di Intelligenza Artificiale (1e) scritto da Luciano Capitanio.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This book was built with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>




</body></html>