[
  {
    "objectID": "0 introduzione.html",
    "href": "0 introduzione.html",
    "title": "1  Introduzione",
    "section": "",
    "text": "Touring vs Searle: Un’Analisi del Pensiero Computazionale e della Coscienza\nAlan Turing e John Searle sono due figure chiave nella filosofia della mente e nello studio dell’AI. Sebbene entrambi abbiano contribuito significativamente al campo, le loro teorie e approcci si differenziano notevolmente. Turing, con il suo famoso “Test di Turing”, si concentrava sulla capacità delle macchine di simulare il comportamento umano, mentre Searle, con il suo “Argomento della Stanza Cinese”, sfidava la nozione che una macchina potesse effettivamente comprendere o essere cosciente. In questo capitolo esploreremo le differenze fondamentali tra i due, analizzando le loro posizioni sul pensiero computazionale e la coscienza.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#touring-vs-searle-unanalisi-del-pensiero-computazionale-e-della-coscienza",
    "href": "0 introduzione.html#touring-vs-searle-unanalisi-del-pensiero-computazionale-e-della-coscienza",
    "title": "1  Introduzione",
    "section": "",
    "text": "Alan Turing e il Test di Turing\n\n\n\nimmagine generata da DALL-E del Test di Touring\n\n\nAlan Turing, matematico britannico e pioniere dell’informatica, è noto per aver proposto quello che oggi è conosciuto come il “Test di Turing” nel suo articolo del 1950 “Computing Machinery and Intelligence”. L’idea di base del test è semplice: una macchina può essere considerata “intelligente” se un essere umano, interagendo con essa attraverso una tastiera e uno schermo, non riesce a distinguere tra le risposte della macchina e quelle di un altro essere umano. Il test non richiede che la macchina pensi o capisca nel senso umano del termine, ma solo che simuli il comportamento umano in modo convincente.\nPer Turing, la domanda “Le macchine possono pensare?” è mal posta. Egli suggerisce che dovremmo piuttosto chiedere se le macchine possano esibire comportamenti che noi interpretiamo come pensiero. L’enfasi, quindi, è sulla simulazione dell’intelligenza piuttosto che sull’esperienza cosciente.\n\n\nJohn Searle e l’Argomento della Stanza Cinese\n\n\n\nimmagine generata da DALL-E della stanza cinese di Searle\n\n\nJohn Searle, filosofo statunitense, ha formulato nel 1980 l’ormai famoso “Argomento della Stanza Cinese” come risposta critica al Test di Turing e alle nozioni di “intelligenza artificiale forte”. Searle distingue tra intelligenza artificiale “debole”, che descrive sistemi che simulano l’intelligenza, e intelligenza artificiale “forte”, che sostiene che una macchina può avere una mente, una coscienza e una comprensione reale del mondo.\nNel suo esperimento mentale, Searle immagina una persona che non conosce il cinese chiusa in una stanza con una serie di istruzioni per manipolare simboli cinesi (input) e fornire risposte (output) in modo che chi osserva dall’esterno creda che la persona capisca il cinese. Tuttavia, sostiene Searle, la persona non comprende affatto il cinese; sta semplicemente seguendo delle regole per manipolare simboli. L’argomento di Searle dimostra che una macchina potrebbe eseguire compiti simili a quelli di una mente cosciente, ma senza effettivamente comprendere il significato di ciò che sta facendo.\n\n\nSimulazione vs. Comprensione\nLa differenza principale tra Turing e Searle risiede nel modo in cui concepiscono l’intelligenza e la coscienza. Per Turing, l’intelligenza è essenzialmente una questione di comportamento osservabile: se una macchina può agire in modo che un osservatore la confonda con un essere umano, allora quella macchina è, in un certo senso, “intelligente”. Non importa se la macchina capisce realmente o meno ciò che sta facendo; ciò che conta è che sembri farlo.\nSearle, d’altra parte, sostiene che il comportamento esterno non è sufficiente per definire l’intelligenza o la comprensione. Anche se una macchina può sembrare intelligente, essa manca di una qualità essenziale: la comprensione interna o la coscienza. Secondo Searle, seguire delle regole o manipolare simboli non equivale a comprendere il significato di quei simboli. L’intelligenza artificiale “forte”, quindi, sarebbe un’illusione: le macchine possono simulare l’intelligenza, ma non possono mai possedere una coscienza o una vera comprensione.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#prospettive-sul-futuro-dellintelligenza-artificiale",
    "href": "0 introduzione.html#prospettive-sul-futuro-dellintelligenza-artificiale",
    "title": "1  Introduzione",
    "section": "Prospettive sul Futuro dell’Intelligenza Artificiale",
    "text": "Prospettive sul Futuro dell’Intelligenza Artificiale\nIl dibattito tra Turing e Searle ha implicazioni profonde per il futuro dell’intelligenza artificiale e per la filosofia della mente. Le visioni di Turing hanno alimentato lo sviluppo di AI sempre più sofisticate, capaci di eseguire compiti complessi come la traduzione automatica, il riconoscimento delle immagini e la diagnosi medica. Tuttavia, gli argomenti di Searle ci ricordano che anche le macchine più avanzate potrebbero non “capire” veramente cosa stanno facendo, sollevando interrogativi su cosa significhi davvero “pensare” e se la coscienza possa mai emergere da un sistema puramente computazionale.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#alan-turing-pioniere-dellinformatica",
    "href": "0 introduzione.html#alan-turing-pioniere-dellinformatica",
    "title": "1  Introduzione",
    "section": "Alan Turing: Pioniere dell’Informatica",
    "text": "Alan Turing: Pioniere dell’Informatica\nBiografia\nAlan Mathison Turing nacque il 23 giugno 1912 a Londra, Regno Unito. Fu un matematico, logico e crittografo britannico, riconosciuto come uno dei fondatori dell’informatica moderna. Durante la Seconda Guerra Mondiale, lavorò presso Bletchley Park, il centro di crittoanalisi britannico, dove contribuì in modo decisivo alla decrittazione del codice Enigma, utilizzato dalle forze tedesche. Questo lavoro ha accelerato la fine del conflitto, salvando probabilmente milioni di vite.\nTuring morì tragicamente l’8 giugno 1954 a Wilmslow, Regno Unito, in circostanze sospette, che furono ufficialmente dichiarate come suicidio. La sua morte sollevò interrogativi sulla discriminazione di cui fu vittima a causa della sua omosessualità, che all’epoca era illegale nel Regno Unito.\nContributi e Onorificenze\nTuring è celebre per il Modello di Turing, un concetto teorico che ha gettato le basi per i computer programmabili. Nel suo celebre articolo del 1936, “On Computable Numbers”, Turing introdusse la nozione di “Macchina di Turing”, una macchina teorica che potesse eseguire calcoli seguendo una serie di istruzioni codificate. Questo concetto ha fondato la teoria dell’informatica.\nOltre ai suoi contributi nel campo della logica e della computazione, il suo Test di Turing (1950) è un punto di riferimento nello studio dell’intelligenza artificiale. Il test pone la questione se una macchina possa essere considerata intelligente se non è possibile distinguerla da un essere umano durante una conversazione.\nRiconoscimenti Postumi\nNonostante la sua vita sia stata segnata da ingiustizie legali, Turing ha ricevuto numerosi riconoscimenti postumi. Nel 2009, il governo britannico, sotto il primo ministro Gordon Brown, emise scuse ufficiali per il trattamento che Turing aveva subito. Nel 2013, la Regina Elisabetta II concesse a Turing la grazia reale postuma. In suo onore, la Medaglia Turing, istituita nel 1966 dall’Association for Computing Machinery (ACM), è uno dei premi più prestigiosi nel campo dell’informatica.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#john-searle-filosofia-della-mente-e-coscienza",
    "href": "0 introduzione.html#john-searle-filosofia-della-mente-e-coscienza",
    "title": "1  Introduzione",
    "section": "John Searle: Filosofia della Mente e Coscienza",
    "text": "John Searle: Filosofia della Mente e Coscienza\nBiografia\nJohn Rogers Searle nacque il 31 luglio 1932 a Denver, Colorado, Stati Uniti. Filosofo contemporaneo di grande rilievo, Searle si è concentrato principalmente su questioni relative alla filosofia del linguaggio, alla coscienza e alla filosofia della mente. Ha conseguito il dottorato presso l’Università di Oxford, e ha insegnato per la maggior parte della sua carriera accademica all’Università della California, Berkeley.\nSearle ha scritto numerosi testi fondamentali, e il suo pensiero si è sviluppato all’interno della tradizione della filosofia analitica. Oltre al suo celebre “Argomento della Stanza Cinese”, ha sviluppato una teoria della coscienza basata sul realismo biologico, sostenendo che la coscienza sia un fenomeno biologico emergente dai processi del cervello.\nContributi Filosofici e Opere Chiave\nSearle è conosciuto soprattutto per il suo contributo alla filosofia del linguaggio e alla filosofia della mente. Nei primi anni della sua carriera, ha lavorato sulla teoria degli atti linguistici, che esamina come il linguaggio sia utilizzato per eseguire azioni, ad esempio promettere, ordinare o chiedere.\nTuttavia, la sua opera più conosciuta è senza dubbio il suo “Argomento della Stanza Cinese”, pubblicato per la prima volta nel 1980. In questo esperimento mentale, Searle sostiene che, sebbene una macchina possa eseguire compiti che simulano la comprensione del linguaggio, essa non possiede una comprensione reale dei significati o delle intenzioni dietro le parole. Questo argomento critica l’idea dell’intelligenza artificiale forte, che sostiene che le macchine possano pensare o essere coscienti come gli esseri umani.\nOnorificenze e Premi\nSearle ha ricevuto numerosi riconoscimenti durante la sua carriera accademica. Nel 2004, ha ricevuto il National Humanities Medal dal presidente degli Stati Uniti George W. Bush per il suo contributo alla filosofia. Nel 2006 è stato premiato con il Premio Mind and Brain per i suoi studi innovativi sulla mente e la coscienza.\nOltre a questi premi, Searle è membro di diverse accademie internazionali, inclusa l’American Academy of Arts and Sciences, e ha ricevuto numerose lauree honoris causa da università di tutto il mondo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#conclusione",
    "href": "0 introduzione.html#conclusione",
    "title": "1  Introduzione",
    "section": "Conclusione",
    "text": "Conclusione\nIn sintesi, mentre Turing e Searle condividono un interesse comune per la natura dell’intelligenza e della mente, le loro posizioni sono radicalmente diverse. Turing vede l’intelligenza come qualcosa che può essere simulato attraverso il comportamento, mentre Searle insiste che senza comprensione interna, ciò che viene prodotto è una mera simulazione priva di coscienza. Questo dibattito continua a influenzare il campo dell’intelligenza artificiale, sfidando filosofi, scienziati e ingegneri a esplorare cosa significhi davvero essere intelligenti e consapevoli. Si noti che il test di Touring è anche all’origine dell’onnipresente “CAPTCHA” (Completely Automated Public Turing test to tell Computers and Humans Apart) che è una forma di test di Turing inverso utilizzato per distinguere gli esseri umani dai bot nei contesti online.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html",
    "href": "1 elementi di Python.html",
    "title": "2  Elementi di Python",
    "section": "",
    "text": "2.1 Sintassi e Concetti di Base\nLa sintassi di Python è progettata per essere intuitiva e di facile lettura. Un programma Python è costituito da linee di codice che vengono eseguite sequenzialmente. Ogni linea di codice esprime una singola operazione o istruzione. Esploriamo alcuni concetti di base attraverso esempi pratici nel contesto della giurisprudenza:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html#sintassi-e-concetti-di-base",
    "href": "1 elementi di Python.html#sintassi-e-concetti-di-base",
    "title": "2  Elementi di Python",
    "section": "",
    "text": "2.1.1 Assegnazione di Variabili**\nIn Python, l’assegnazione di un valore a una variabile è semplice e diretta:\n** Assegnazione di variabili **\nfascicolo = \"2024/12345\"\nnomeGiudice = \"Giudice Rossi\"\ncasoChiuso = False\nIn questo esempio, abbiamo assegnato una stringa (\"2024/12345\") a fascicolo, una stringa (\"Giudice Rossi\") a nomeGiudice, e un valore booleano (False) a casoChiuso, indicando che il caso non è ancora chiuso.\n\n\n2.1.2 Operazioni Aritmetiche\nPython supporta tutte le principali operazioni aritmetiche; possiamo applicarle anche a contesti legali, come il calcolo delle pene o delle ammende.\nCalcolo di una sanzione basata sui giorni di ritardo\ngiorniRitardo = 10\nsanzioneGiornaliera = 50\n\nsanzioneTotale = giorniRitardo * sanzioneGiornaliera  # Sanzione totale: 500€\nprint(f\"La sanzione totale è di {sanzioneTotale} euro.\")\nOutput:\nLa sanzione totale è di 500 euro.\n\n\n2.1.3 Controllo del Flusso (Condizioni e Cicli)\n\n2.1.3.1 Lo Statement if\nLo statement if in Python è una struttura di controllo che consente di eseguire blocchi di codice condizionatamente, in base al risultato di una condizione booleana (vero o falso). La sintassi di base è la seguente:\nif condizione:\n    # codice da eseguire se la condizione è vera\nComponenti dello statement if\n\nCondizione: È un’espressione che restituisce un valore booleano. Se la condizione è vera (True), il blocco di codice indentato successivo verrà eseguito.\nBlocco di Codice: Il codice all’interno del blocco deve essere indentato. L’indentazione è fondamentale in Python e indica quali istruzioni appartengono al blocco if.\n\nEsempio di Base\nx = 10\n\nif x &gt; 5:\n    print(\"x è maggiore di 5\")\nOutput:\nx è maggiore di 5\nIn questo esempio, poiché x è effettivamente maggiore di 5, verrà stampato “x è maggiore di 5”.\nVarianti dello Statement if\n\nif-else: Consente di eseguire un blocco di codice alternativo se la condizione è falsa.\nif x &gt; 5:\n    print(\"x è maggiore di 5\")\nelse:\n    print(\"x non è maggiore di 5\")\nOutput: x è maggiore di 5\nif-elif-else: Permette di controllare più condizioni in sequenza.\nif x &gt; 10:\n    print(\"x è maggiore di 10\")\nelif x &gt; 5:\n    print(\"x è maggiore di 5 ma minore o uguale a 10\")\nelse:\n    print(\"x è minore o uguale a 5\")\nOutput: x è maggiore di 5 ma minore o uguale a 10\n\nOperatori di Confronto\nPuoi usare vari operatori di confronto all’interno delle condizioni, tra cui:\n\n==: uguale\n!=: diverso\n&gt;: maggiore\n&lt;: minore\n&gt;=: maggiore o uguale\n&lt;=: minore o uguale\n\nEsempi di Condizioni Complesse\nPuoi anche combinare condizioni usando gli operatori logici:\n\nand: restituisce True se entrambe le condizioni sono vere.\nor: restituisce True se almeno una delle condizioni è vera.\nnot: inverte il valore della condizione.\n\nif x &gt; 5 and x &lt; 15:\n    print(\"x è compreso tra 5 e 15\")\nOutput:\nx è compreso tra 5 e 15\nIn sintesi, lo statement if è una delle basi della logica di programmazione in Python, permettendo di prendere decisioni e controllare il flusso del programma. Python utilizza l’indentazione per definire blocchi di codice, rendendo il codice pulito e leggibile.\n\n\n2.1.3.2 I cicli\nfor\n# Iterare su una lista di testimoni\nwitnesses = [\"Testimone A\", \"Testimone B\", \"Testimone C\"]\n\nfor witness in witnesses:\n    print(f\"Interrogare {witness}\")\nOutput:\nInterrogare Testimone A\nInterrogare Testimone B\nInterrogare Testimone C\nwhile\n# Ciclo while per contare all'indietro da 5 a 1\nn = 5\nwhile n &gt; 0:\n    print(n)\n    n -= 1\nOutput:\n5\n4\n3\n2\n1\n\n\n\n2.1.4 Gestione delle Eccezioni\nPython permette di gestire gli errori e le eccezioni in modo elegante usando i blocchi try e except.\ntry:\n    # Tentativo di apertura di un file di sentenze\n    with open(\"sentenze.txt\", \"r\") as file:\n        content = file.read()\nexcept FileNotFoundError:\n    print(\"Errore: Il file delle sentenze non è stato trovato.\")\nOutput:\nErrore: Il file delle sentenze non è stato trovato.\nl’ istruzione try ammette anche una estensione chiamata finally che viene eseguita alla fine della try per garantire la consistenza delle operazioni svolte nel blocco try. Ad esempio, il precedente blocco try potrebbe avere una finally per chiudere il file alla fine del blocco:\ntry:\n    f = open('data.txt', 'r')\n    contenuto = f.read()\nexcept FileNotFoundError:\n    print(\"Errore: Il file delle sentenze non è stato trovato.\")\nfinally:\n    f.close()  # Il blocco finally garantisce che il file venga chiuso\nOutput:\nErrore: Il file delle sentenze non è stato trovato.\n\n\n2.1.5 Stampe a Video\nLa funzione print in Python è utilizzata per stampare messaggi a video, rendendo facile il debug e la visualizzazione dei risultati.\n# Stampa di informazioni su un caso legale\nfascicolo = \"2024/12345\"\nnomeGiudice = \"Mario Rossi\"\ncasoChiuso = False\n\nprint(f\"Numero del caso: {fascicolo}\")\nprint(f\"Nome del giudice: {nomeGiudice}\")\nprint(f\"Il caso è chiuso? {'Sì' if casoChiuso else 'No'}\")\nOutput:\nNumero del caso: 2024/12345\nNome del giudice: Mario Rossi\nIl caso è chiuso? No\n\n\n2.1.6 Lettura e Scrittura di File\nPython fornisce metodi semplici per leggere e scrivere file, essenziali per la gestione dei dati legali.\nScrittura di un file testuale\n# Scrittura di una sentenza in un file\nsentenza = \"Il caso è chiuso. La sentenza è di 5 anni di reclusione.\"\nwith open(\"sentenza.txt\", \"w\") as file:\n    file.write(sentenza)\nLettura di un file\n\n# Lettura di una sentenza da un file\ntry:\n    with open(\"sentenza.txt\", \"r\") as file:\n        content = file.read()\n        print(\"Contenuto del file:\")\n        print(content)\nexcept FileNotFoundError:\n    print(\"Errore: Il file delle sentenze non è stato trovato.\")\nOutput:\nContenuto del file:\nIl caso è chiuso. La sentenza è di 5 anni di reclusione.\nIn questo paragrafo, abbiamo esplorato alcuni dei concetti di base della sintassi di Python, inclusi l’assegnazione di variabili, le operazioni aritmetiche, le condizioni, i cicli, le funzioni, la gestione delle eccezioni, le stampe a video e la lettura e scrittura di file, applicandoli a contesti giuridici. Questi concetti costituiscono la base della programmazione in Python e ti preparano per affrontare problemi più complessi nei capitoli successivi.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html#strutture-dati",
    "href": "1 elementi di Python.html#strutture-dati",
    "title": "2  Elementi di Python",
    "section": "2.2 Strutture Dati",
    "text": "2.2 Strutture Dati\nLe strutture dati sono elementi fondamentali per qualsiasi linguaggio di programmazione, e Python offre una serie di strutture dati integrate che rendono la gestione dei dati semplice ed efficiente. Esploriamo alcune delle strutture dati principali e le loro funzionalità attraverso esempi pratici nel contesto della giurisprudenza.\n\n2.2.1 Liste\nLe liste sono collezioni ordinate di elementi che possono essere modificati. Possono contenere elementi di qualsiasi tipo, inclusi numeri, stringhe e altre liste.\n# Creare una lista di leggi applicabili\nleggi = [\"Art. 1 - Reati contro la persona\", \"Art. 2 - Reati contro il patrimonio\"]\n\n# Aggiungere una nuova legge\nleggi.append(\"Art. 3 - Reati contro l'ambiente\")\n\n# Rimuovere una legge\nleggi.remove(\"Art. 2 - Reati contro il patrimonio\")\n\n# Accedere a una legge\nprint(leggi[1])  # Stampa: \"Art. 3 - Reati contro l'ambiente\"\nprint(\"................................\")\n# Iterare su una lista di leggi\nfor legge in leggi:\n    print(legge)\nOutput:\nArt. 3 - Reati contro l'ambiente\n................................\nArt. 1 - Reati contro la persona\nArt. 3 - Reati contro l'ambiente\n\n\n2.2.2 Dizionari\nI dizionari sono collezioni di coppie chiave-valore che permettono un accesso rapido ai dati. Le chiavi devono essere uniche e immutabili.\n# Creare un dizionario per un caso legale\nfascicolo = {\"numero\": \"2024/12345\", \"giudice\": \"Giudice Rossi\", \"stato\": \"aperto\"}\n\n# Aggiungere o aggiornare un elemento\nfascicolo[\"stato\"] = \"chiuso\"\n\n# Rimuovere un elemento\ndel fascicolo[\"giudice\"]\n\n# Accedere a un valore\nprint(fascicolo[\"numero\"])  # Stampa: \"2024/12345\"\n\n# Iterare su un dizionario\nfor chiave, valore in fascicolo.items():\n    print(f\"{chiave}: {valore}\")\nOutput:\n2024/12345\nnumero: 2024/12345\nstato: chiuso\n\n\n2.2.3 Set o insiemi\nI set sono collezioni di elementi unici, utili per operazioni matematiche insiemistiche come l’unione e l’intersezione.\n# Creare un set di articoli violati\narticoliViolati = {\"Art. 1\", \"Art. 3\"}\n\n# Aggiungere un articolo violato\narticoliViolati.add(\"Art. 5\")\n\n# Rimuovere un articolo violato\narticoliViolati.remove(\"Art. 1\")\n\n# Operazioni sui set\narticoliAggiuntivi = {\"Art. 2\", \"Art. 4\", \"Art. 5\"}\nrisultatoUnione = articoliViolati.union(articoliAggiuntivi)  # Unione\nrisultatoIntersezione = articoliViolati.intersection(articoliAggiuntivi)  # Intersezione\n\nprint(risultatoUnione)  # Stampa: {'Art. 2', 'Art. 3', 'Art. 4', 'Art. 5'}\nprint(risultatoIntersezione)  # Stampa: {'Art. 5'}\nOutput:\n{'Art. 4', 'Art. 3', 'Art. 5', 'Art. 2'}\n{'Art. 5'}\n\n\n2.2.4 Set o insiemi\nI set sono collezioni di elementi unici, utili per operazioni matematiche insiemistiche come l’unione e l’intersezione.\n# Creare un set di articoli violati\narticoliViolati = {\"Art. 1\", \"Art. 3\"}\n\n# Aggiungere un articolo violato\narticoliViolati.add(\"Art. 5\")\n\n# Rimuovere un articolo violato\narticoliViolati.remove(\"Art. 1\")\n\n# Operazioni sui set\narticoliAggiuntivi = {\"Art. 2\", \"Art. 4\", \"Art. 5\"}\nrisultatoUnione = articoliViolati.union(articoliAggiuntivi)  # Unione\nrisultatoIntersezione = articoliViolati.intersection(articoliAggiuntivi)  # Intersezione\n\nprint(risultatoUnione)  # Stampa: {'Art. 2', 'Art. 3', 'Art. 4', 'Art. 5'}\nprint(risultatoIntersezione)  # Stampa: {'Art. 5'}\nOutput:\n{'Art. 4', 'Art. 3', 'Art. 5', 'Art. 2'}\n{'Art. 5'}\n\n\n2.2.5 Tuple\nLe tuple sono simili alle liste ma sono immutabili. Una volta create, non possono essere modificate. L’immutabilità delle tuple offre diversi vantaggi, tra cui la sicurezza dei dati e l’ottimizzazione delle prestazioni. Quando un dato non deve essere modificato, l’utilizzo delle tuple assicura che il dato rimanga costante durante l’esecuzione del programma, riducendo il rischio di errori accidentali. Inoltre, le tuple possono essere utilizzate come chiavi nei dizionari, poiché sono immutabili.\n# Creare una tupla per le coordinate di un luogo del crimine\ncoordinateScenaCrimine = (45.4642, 9.1900)\n\n# Accedere a un elemento\nprint(coordinateScenaCrimine[0])  # Stampa: 45.4642\nOutput:\n45.4642\n# Le tuple non possono essere modificate\ncoordinateScenaCrimine[0] = 45.5000  # Questo genererà un errore\nOutput:\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-6-b4ce3edf64a6&gt; in &lt;cell line: 2&gt;()\n      1 # Le tuple non possono essere modificate\n----&gt; 2 coordinateScenaCrimine[0] = 45.5000  # Questo genererà un errore\n\nTypeError: 'tuple' object does not support item assignment",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html#funzioni-e-moduli",
    "href": "1 elementi di Python.html#funzioni-e-moduli",
    "title": "2  Elementi di Python",
    "section": "2.3 Funzioni e Moduli",
    "text": "2.3 Funzioni e Moduli\n\n2.3.1 Definire e usare le funzioni\nLe funzioni permettono di organizzare il codice in blocchi riutilizzabili, mentre i moduli permettono di suddividere il codice in file separati che possono essere importati e utilizzati in altri programmi. Sia le funzioni che i moduli consentono di organizzare il codice sviluppato in blocchi omogeni facilitando il riuso e lo scambio di codice sorgente. Ad esempio, se abbiamo scritto un blocco di codice che riolve un problema applicativo come il calcolo degli anni di detenzione per un determinato reato possiamo inserire questo blocco di istruzioni python in una funzione dal nome calcoloDurataPena. Mentre, se abbiamo definito un certo numero di funzioni utili nell’ambito penalistico possiamo definire un modulo denominato calcolipenale.py e importarlo ogniqualvolta ne abbiamo bisogno\n\n# Funzione per calcolare la durata di una pena basata sulla gravità del crimine\ndef calcoloDurataPena(crime_severity):\n    if crime_severity == \"grave\":\n        return 10\n    elif crime_severity == \"moderato\":\n        return 5\n    else:\n        return 1\n\nanni = calcoloDurataPena(\"grave\")\nprint(f\"La durata della pena è di {anni} anni.\")\nOutput:\nLa durata della pena è di 10 anni.\n\n\n2.3.2 Creare e importare moduli personalizzati\nÈ possibile creare moduli personalizzati per organizzare meglio il codice. Ad esempio, se si desidera separare le funzioni di calcolo in ambito penalistico in un modulo separato:\nCreare un modulo (calcolipenale.py)\n# calcolipenale.py\ndef calcoloDurataPena(crime_severity):\n    if crime_severity == \"grave\":\n        return 10\n    elif crime_severity == \"moderato\":\n        return 5\n    else:\n        return 1\n\ndef calcolaSanzione(sanzioneBase, giorniRitardo, mora=50):\n    return sanzioneBase + giorniRitardo * mora\nImportare e usare il modulo python\n# script_principale.py\nimport calcolipenale\n\nanni = calcolipenale.calcoloDurataPena(\"grave\")\nsanzione = calcolipenale.calcolaSanzione(550,10,10)\n\nprint(f\"La durata della pena è di 10 anni.\")\nprint(f\"La multa totale è di 650 euro.\")\nOutput:\nLa durata della pena è di {anni} anni.\nLa multa totale è di {sanzione} euro.\n\n\n2.3.3 Importare moduli\nLa possibilità di creare e importare moduli di codice è una caratteristica di molti linguaggi di programmazione che consente:\n\nRiutilizzo del Codice: L’importazione dei moduli consente di riutilizzare il codice esistente, evitando la duplicazione e rendendo più facile la manutenzione del software.\nOrganizzazione: I moduli permettono di organizzare il codice in file separati, facilitando la comprensione e la navigazione nel progetto.\nAstrazione: Utilizzando moduli, si possono nascondere dettagli complessi dietro interfacce più semplici, migliorando la leggibilità e la chiarezza del codice.\nEcosistema Ricco: Python ha un vasto ecosistema di moduli e librerie che coprono un’ampia gamma di funzionalità, dal trattamento dei dati al web development, permettendo agli sviluppatori di concentrarsi su ciò che è importante per il loro progetto.\n\nIn particolare, in Python in ambito IA i moduli consentono di:\n\nLibrerie Specializzate: l’importazione di moduli come NumPy, Pandas, TensorFlow e PyTorch è essenziale per operazioni matematiche complesse, manipolazione dei dati e costruzione di modelli di machine learning.\nFacilità di Sperimentazione: Le librerie consentono di sperimentare rapidamente con algoritmi di IA senza dover scrivere tutto da zero, accelerando il processo di sviluppo e ricerca.\nSupporto per il Calcolo Distribuito: Alcuni moduli permettono di sfruttare il calcolo distribuito, fondamentale per addestrare modelli di IA su grandi quantità di dati.\nStandardizzazione: Utilizzando librerie consolidate, i ricercatori e gli sviluppatori possono garantire che le loro implementazioni siano compatibili con gli standard del settore, facilitando la condivisione e la riproducibilità dei risultati.\n\nIn sintesi, l’importazione di moduli in Python è cruciale per lo sviluppo efficace e efficiente, specialmente nell’ambito dell’intelligenza artificiale, dove la complessità e la varietà degli strumenti richiesti sono elevate.\n# esempio di importazione di una libreria standard\nimport math\n\n# Calcolare la distanza tra due punti (coordinate di due luoghi del crimine)\ndef calculate_distance(coord1, coord2):\n    return math.sqrt((coord2[0] - coord1[0])**2 + (coord2[1] - coord1[1])**2)\n\ndistance = calculate_distance((45.4642, 9.1900), (45.5000, 9.2100))\nprint(f\"La distanza tra i due luoghi del crimine è di {distance} unità.\")\nOutput:\nLa distanza tra i due luoghi del crimine è di 0.04100780413531289 unità.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html#gli-oggetti",
    "href": "1 elementi di Python.html#gli-oggetti",
    "title": "2  Elementi di Python",
    "section": "2.4 Gli oggetti",
    "text": "2.4 Gli oggetti\nIn Python, gli oggetti sono entità fondamentali che rappresentano sia i dati che le funzioni. Ogni cosa in Python è un oggetto, inclusi numeri, stringhe, liste, funzioni e persino le stesse classi. Gli oggetti hanno proprietà, chiamate attributi, e comportamenti, definiti dai metodi. Gli oggetti possono essere utilizzati per modellare situazioni reali, come il trattamento di fascicoli giuridici, dove un oggetto può rappresentare un singolo caso legale, contenente informazioni sul giudice, le parti coinvolte e lo stato del procedimento. La programmazione orientata agli oggetti (OOP) consente di organizzare il codice in modo più modulare e riutilizzabile, facilitando la gestione di progetti complessi e favorendo la collaborazione tra sviluppatori. Nei prossimi esempi, vedremo come creare e gestire oggetti in Python, e come questi possano essere applicati a contesti giuridici concreti.\n\n2.4.1 Creazione di una classe\nUna classe è un modello per creare oggetti. Può essere paragonata a una struttura o un modello da cui vengono creati singoli oggetti.\nclass Fascicolo:\n    def __init__(self, numero, giudice, chiuso):\n        self.numero = numero          # Attributo che contiene il numero del fascicolo\n        self.giudice = giudice        # Attributo che contiene il nome del giudice\n        self.chiuso = chiuso          # Attributo che indica se il fascicolo è chiuso (True o False)\nIn questo esempio, la classe Fascicolo ha tre attributi: numero, giudice e chiuso. Questi vengono definiti quando viene creato un nuovo oggetto della classe.\n\n\n2.4.2 Creazione di un oggetto\nPer creare un oggetto da una classe, si usa la classe come una funzione. Gli oggetti creati da una classe sono chiamati istanze della classe.\n# Creiamo un nuovo fascicolo\nfascicolo_1 = Fascicolo(\"2024/12345\", \"Giudice Rossi\", False)\n\n# Accesso agli attributi dell'oggetto\nprint(f\"Numero del fascicolo: {fascicolo_1.numero}\")\nprint(f\"Giudice: {fascicolo_1.giudice}\")\nprint(f\"Il fascicolo è chiuso? {fascicolo_1.chiuso}\")\nOutput:\nNumero del fascicolo: 2024/12345\nGiudice: Giudice Rossi\nIl fascicolo è chiuso? False\nQui abbiamo creato un oggetto fascicolo_1 con i valori specificati. Abbiamo poi stampato i valori dei suoi attributi.\n\n\n2.4.3 Aggiunta di un metodo alla classe\nI metodi sono funzioni definite all’interno di una classe e possono operare sugli attributi dell’oggetto.\nclass Fascicolo:\n    def __init__(self, numero, giudice, chiuso):\n        self.numero = numero\n        self.giudice = giudice\n        self.chiuso = chiuso\n\n    # Metodo per chiudere il fascicolo\n    def chiudi_fascicolo(self):\n        self.chiuso = True\n        print(f\"Il fascicolo {self.numero} è stato chiuso.\")\n\n# Creiamo un altro fascicolo\nfascicolo_2 = Fascicolo(\"2024/67890\", \"Giudice Bianchi\", False)\n\n# Chiudiamo il fascicolo\nfascicolo_2.chiudi_fascicolo()\nOutput:\nIl fascicolo 2024/67890 è stato chiuso.\nIn questo esempio, abbiamo aggiunto un metodo chiamato chiudi_fascicolo che modifica l’attributo chiuso di un fascicolo e stampa un messaggio.\n\n\n2.4.4 Utilizzo di più oggetti\nPossiamo creare più istanze della classe Fascicolo per rappresentare diversi fascicoli.\nfascicolo_3 = Fascicolo(\"2024/54321\", \"Giudice Verdi\", False)\nfascicolo_4 = Fascicolo(\"2024/98765\", \"Giudice Neri\", True)\n\nprint(f\"Fascicolo 3 - Giudice: {fascicolo_3.giudice}, Chiuso: {fascicolo_3.chiuso}\")\nprint(f\"Fascicolo 4 - Giudice: {fascicolo_4.giudice}, Chiuso: {fascicolo_4.chiuso}\")\nOutput:\nFascicolo 3 - Giudice: Giudice Verdi, Chiuso: False\nFascicolo 4 - Giudice: Giudice Neri, Chiuso: True\n\n\n2.4.5 Ereditarietà tra classi\nL’ereditarietà consente di creare una nuova classe che eredita attributi e metodi da un’altra classe. Vediamo come creare una classe FascicoloPenale che eredita dalla classe Fascicolo.\nclass FascicoloPenale(Fascicolo):\n    def __init__(self, numero, giudice, chiuso, reato):\n        super().__init__(numero, giudice, chiuso)  # Chiamata al costruttore della classe genitore\n        self.reato = reato  # Attributo specifico del fascicolo penale\n\n# Creiamo un fascicolo penale\nfascicolo_penale = FascicoloPenale(\"2024/11111\", \"Giudice Gialli\", False, \"Frode\")\n\nprint(f\"Fascicolo Penale - Numero: {fascicolo_penale.numero}, Reato: {fascicolo_penale.reato}\")\nOutput:\nFascicolo Penale - Numero: 2024/11111, Reato: Frode\nIn questo caso, FascicoloPenale eredita attributi e metodi dalla classe Fascicolo e aggiunge un nuovo attributo chiamato reato.\nGli oggetti in Python offrono una grande flessibilità nel modellare e organizzare il codice. Con la programmazione orientata agli oggetti, puoi creare classi che rappresentano concetti del mondo reale, semplificando la gestione di dati complessi. Con l’uso di attributi, metodi e ereditarietà, diventa possibile creare programmi modulari e riutilizzabili per affrontare problemi sempre più complessi.\nIn questo capitolo, abbiamo esplorato le principali strutture dati di Python, tra cui liste, dizionari, set e tuple, e le funzionalità principali come le funzioni e i moduli, applicandole a contesti giuridici. Queste strutture dati e funzionalità sono fondamentali per scrivere programmi efficienti e ben organizzati e saranno essenziali per affrontare i compiti di intelligenza artificiale nei capitoli successivi.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "2 algoritmi.html",
    "href": "2 algoritmi.html",
    "title": "3  Algoritmi",
    "section": "",
    "text": "3.1 Inferenza Logica\nL’inferenza logica è un processo fondamentale nel campo della logica, della matematica e della filosofia, utilizzato per derivare conclusioni a partire da premesse o informazioni date. Questo processo può essere visto come un mezzo per scoprire nuove verità o per confermare la validità di affermazioni esistenti. L’inferenza logica si suddivide principalmente in due categorie: deduttiva e induttiva.\nL’inferenza deduttiva è quella in cui la conclusione deriva necessariamente dalle premesse; se le premesse sono vere, la conclusione non può che essere vera. Un classico esempio di inferenza deduttiva è il sillogismo: “Tutti gli uomini sono mortali; Socrate è un uomo; quindi, Socrate è mortale.” In questo caso, la verità delle premesse garantisce la verità della conclusione.\nL’inferenza induttiva, invece, opera diversamente: partendo da osservazioni specifiche o da una serie di dati, arriva a conclusioni più generali, che non sono necessariamente certe ma probabili. Ad esempio, se si osserva che il sole è sorto ogni giorno, si potrebbe inferire che il sole sorgerà anche domani. Questa forma di inferenza è molto utilizzata nella scienza, dove gli scienziati formulano ipotesi basate su dati osservati e sperimentali.\nUn altro tipo di inferenza logica è l’abduzione, che implica la formazione della migliore spiegazione possibile data un insieme di osservazioni. Questo tipo di inferenza è spesso utilizzato nella diagnosi medica, nella ricerca scientifica e nelle indagini criminali, dove si cerca di spiegare i dati osservati nel modo più coerente possibile.\nL’inferenza logica è strettamente legata al concetto di validità e di correttezza degli argomenti. Un’argomentazione è valida se la sua struttura logica è tale che, qualora le premesse siano vere, anche la conclusione deve essere vera. Tuttavia, un’argomentazione può essere valida senza essere corretta; per essere corretta, deve avere anche premesse vere. Ad esempio, l’argomentazione “Tutti gli unicorni sono verdi; io possiedo un unicorno; quindi, il mio unicorno è verde” è valida dal punto di vista logico, ma non è corretta perché le premesse non sono vere.\nL’inferenza logica è alla base di molti sistemi di intelligenza artificiale e di calcolo automatico, dove gli algoritmi vengono progettati per inferire nuove informazioni a partire da dati iniziali. Nei sistemi esperti, per esempio, vengono utilizzate regole di inferenza per simulare il processo decisionale umano. In conclusione, l’inferenza logica è uno strumento potente e versatile che permea molte aree del pensiero umano e della tecnologia, consentendo di avanzare nella conoscenza e nella comprensione del mondo che ci circonda. L’inferenza logica è una tecnica fondamentale dell’intelligenza artificiale che utilizza le regole logiche per derivare nuove informazioni da quelle esistenti. Nella giurisprudenza, l’inferenza logica può essere utilizzata per analizzare le leggi e determinare le conseguenze logiche delle azioni legali.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algoritmi</span>"
    ]
  },
  {
    "objectID": "2 algoritmi.html#inferenza-logica",
    "href": "2 algoritmi.html#inferenza-logica",
    "title": "3  Algoritmi",
    "section": "",
    "text": "definizione Treccani: inferenza logica sinonimo di «argomentazione logica» utilizzato per designare il processo di deduzione di una formula A, detta conclusione, a partire da una o più formule, dette premesse. Secondo A. De Morgan, una inferenza è la «produzione di una proposizione come conseguenza necessaria di una o più proposizioni».\n\n\n\n\n\n\n\n\nI sistemi esperti - Negli anni ’80, l’inferenza logica è stata fondamentale nello sviluppo dei sistemi esperti, strumenti avanzati di intelligenza artificiale progettati per risolvere problemi complessi emulando il ragionamento umano. Due noti prodotti commerciali di quel periodo sono stati MYCIN, un sistema esperto per la diagnosi di infezioni del sangue, e XCON, utilizzato per configurare sistemi di computer VAX di Digital Equipment Corporation. MYCIN e XCON sfruttavano regole di inferenza per elaborare informazioni e fornire raccomandazioni o soluzioni, dimostrando l’efficacia dell’inferenza logica in applicazioni pratiche e commerciali &gt; - “Rule-based Expert Systems : The MYCIN Experiments of the Stanford Heuristic Programming Project”, edited by Bruce G. Buchanan, Edward H. Shortliffe (AddisonWesley, 1984) - “RI: an Expert in the Computer Systems Domain”\n\n\n3.1.1 Proposizioni Logiche\nLe proposizioni logiche sono dichiarazioni atomiche che possono essere valutate come vere o false. Le proposizioni possono essere combinate utilizzando operatori logici come AND, OR, NOT, IMPLIES, che permettono di costruire regole complesse rappresentate da formule logiche.\nEcco alcuni esempi di proposizioni logiche:\np: “Il sole è luminoso” (Vero) q: “La Luna è fatta di formaggio” (Falso) r: “Se piove, allora la strada sarà bagnata” (Condizionale)\n\n\n3.1.2 Calcolo delle Proposizioni Logiche\nLe proposizioni logiche possono essere manipolate utilizzando vari operatori logici che eseguono operazioni specifiche:\nCongiunzione (AND - ∧): L’operatore AND restituisce vero solo quando entrambe le proposizioni coinvolte sono vere. Ad esempio, se abbiamo due proposizioni p e q, p ∧ q è vero solo se entrambe p e q sono vere. La cosidetta tabella di verità riportata qui sotto consente di vedere come funziona l’operatore AD.\n\nTavola della verità per la congiunzione\n\n\np\nq\np ∧ q\n\n\n\n\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\n\n\nTrue\nTrue\nTrue\n\n\n\nDisgiunzione (OR - ∨): L’operatore OR restituisce vero se almeno una delle due proposizioni coinvolte è vera. Ad esempio, p ∨ q è vero se p è vero oppure se q è vero oppure se entrambi sono veri. La tabella di verità riportata qui sotto consente di vedere come funziona l’operatore OR.\n\nTavola della verità per la disgiunzione\n\n\np\nq\np ∨ q\n\n\n\n\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nTrue\nTrue\nTrue\n\n\n\nNegazione (NOT - ¬): L’operatore NOT cambia il valore di verità di una proposizione. Ad esempio, ¬p è vero se p è falso e viceversa.\n\nTavola della verità per la negazione\n\n\np\n¬p\n\n\n\n\nFalse\nTrue\n\n\nTrue\nFalse\n\n\n\nImplicazione (→): L’implicazione è un’operazione logica che collega due proposizioni e stabilisce una relazione di condizionalità. Si rappresenta con il simbolo “→” e si legge come “se… allora”. In un’implicazione del tipo “p → q”, la proposizione p è chiamata l’antecedente e la proposizione q è il conseguente. L’implicazione è falsa solo nel caso in cui l’antecedente è vero e il conseguente è falso. In tutti gli altri casi, l’implicazione è considerata vera. Poiché questa operazione è alla base di molti algoritmi di inferenza, è importante capire come funziona. La tabella di verità riportata qui sotto consente di vedere come funziona l’operatore implicazione.\n\nTavola della verità per l’implicazione\n\n\np\nq\np → q\n\n\n\n\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nTrue\nTrue\nTrue\n\n\n\nEsempio di Implicazione: supponiamo di avere le seguenti proposizioni: - p: Il sole splende. - q: Faccio una passeggiata. - L’implicazione che possiamo formulare è: “Se il sole splende, allora faccio una passeggiata”, che si scrive come “p → q”. Dalla tabella della verità, possiamo vedere che in tre dei quattro casi l’implicazione “p → q” è vera. L’unico caso in cui l’implicazione è falsa è quando il sole splende (p è vero) ma non faccio una passeggiata (q è falso).\nQuindi, in base alla logica dell’implicazione, se il sole splende, sto effettivamente facendo una passeggiata o potrei anche non farla (ad eccezione del caso in cui il sole splenda e io non faccia una passeggiata, in cui l’implicazione è falsa).\nImplicazione Bilaterale (↔︎): L’implicazione bilaterale è un’operazione logica che stabilisce che due proposizioni sono equivalenti, cioè che entrambe le proposizioni hanno lo stesso valore di verità. Si rappresenta con il simbolo “↔︎” e si legge come “se e solo se”. L’implicazione bilaterale è vera solo quando le proposizioni hanno lo stesso valore di verità, sia entrambe vere che entrambe false.\n\nTavola della verità per l’implicazione bilaterale\n\n\np\nq\np ↔︎ q\n\n\n\n\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\n\n\nTrue\nTrue\nTrue\n\n\n\nL’implicazione bilaterale, anche conosciuta come “se e solo se”, è un importante concetto logico che stabilisce che due proposizioni sono logicamente equivalenti, cioè entrambe sono vere o entrambe sono false contemporaneamente.\nEsempio di Implicazione Bilaterale: supponiamo di avere le seguenti proposizioni:\n\np: Oggi è venerdì.\nq: Domani è sabato.\n\nL’implicazione bilaterale tra p e q può essere scritta come p ↔︎ q, che si legge come “Oggi è venerdì se e solo se domani è sabato”.\nDalla tabella di verità, possiamo notare che l’implicazione bilaterale “Oggi è venerdì se e solo se domani è sabato” è vera solo nei casi in cui entrambe le proposizioni sono vere (primo e ultimo caso) o entrambe sono false. Se c’è una discrepanza nelle verità delle proposizioni, l’implicazione bilaterale diventa falsa (secondo e terzo caso).\nQuindi, nel nostro esempio, l’affermazione “Oggi è venerdì se e solo se domani è sabato” è vera solo quando entrambe le proposizioni sono vere o entrambe sono false, evidenziando l’equivalenza logica tra le due proposizioni nel contesto dell’implicazione bilaterale.\n\n\n3.1.3 Basi della Conoscenza\nLa base della conoscenza in un agente a inferenza logica è costituita da proposizioni logiche, che sono affermazioni dichiarative che possono essere vere o false. Le proposizioni possono essere atomiche o composte e sono spesso rappresentate utilizzando variabili proposizionali. Queste variabili assumono valori di verità (vero o falso) e vengono combinate tramite operatori logici per formare regole logiche complesse. La base della conoscenza in un sistema logico definisce le relazioni tra le proposizioni e fornisce le fondamenta per il ragionamento e l’inferenza. Un agente a inferenza logica usa la Base della Conoscenza per giungere a conclusioni circa il mondo che la circonda; Per fare ciò ha bisogno di regole di implicazione logica (⊨): Se α ⊨ β, ovvero se α implica logicamente β, in ogni mondo dove α è vera allora β è vera. È diversa dall’implicazione perché non è un connettivo logico ma una relazione che dice che se α è vera allora β è vera e basta!\n\n\n3.1.4 Sistemi basati sulla conoscenza\nI sistemi basati sulla conoscenza sono strumenti informatici progettati per emulare il processo decisionale umano attraverso l’utilizzo di una base di conoscenza strutturata. Questi sistemi raccolgono, organizzano e utilizzano informazioni specifiche di un dominio per risolvere problemi complessi che richiedono competenza specialistica. Una componente fondamentale è la base di conoscenza, che contiene fatti, regole ed euristiche rappresentative del sapere umano in un determinato campo. Il motore di inferenza è l’altro elemento chiave: applica regole logiche ai dati presenti nella base di conoscenza per dedurre nuove informazioni o prendere decisioni informate.\n\n\n\nProcesso di creazione e gestione di un sistema basato sulla conoscenza\n\n\nIl processo di creazione di un sistema esperto basato sull’inferenza logica inizia con l’acquisizione della conoscenza, dove gli esperti del dominio collaborano per estrarre informazioni e regole rilevanti. Queste conoscenze vengono poi formalizzate nella rappresentazione della conoscenza, utilizzando strutture come regole if-then, ontologie o reti semantiche, che alimentano la base di conoscenza. Il motore di inferenza viene sviluppato per applicare queste regole logiche ai dati forniti, deducendo nuove informazioni o prendendo decisioni informate. La gestione del sistema include l’aggiornamento continuo della base di conoscenza per riflettere nuove scoperte o cambiamenti nel dominio, nonché la verifica e la validazione del sistema per garantirne l’accuratezza e l’affidabilità. Gli utenti interagiscono con il sistema attraverso un’interfaccia che facilita l’inserimento dei dati e la visualizzazione dei risultati, permettendo anche il feedback per miglioramenti futuri.\nQuesti sistemi trovano applicazione in vari settori, come la medicina, l’ingegneria, la finanza e l’assistenza clienti. Ad esempio, in ambito medico, un sistema basato sulla conoscenza può aiutare nella diagnosi di malattie analizzando sintomi e storie cliniche dei pazienti. L’efficacia di tali sistemi dipende dalla qualità e dall’aggiornamento costante della base di conoscenza, nonché dalla capacità del motore di inferenza di elaborare correttamente le informazioni.\nUn vantaggio significativo dei sistemi basati sulla conoscenza è la possibilità di conservare e diffondere l’esperienza di esperti, rendendola accessibile a un pubblico più ampio e contribuendo alla standardizzazione delle pratiche. Tuttavia, la creazione e la manutenzione di una base di conoscenza richiedono notevoli risorse e competenze. Con l’avanzamento dell’intelligenza artificiale e dell’apprendimento automatico, questi sistemi continuano a evolversi, integrando nuove tecniche per migliorare l’efficienza, l’accuratezza e la capacità di apprendimento autonomo nelle loro applicazioni.\n\n\n3.1.5 Semplice Sistema Esperto in ambito penale\nIn questo paragrafo, useremo la libreria SymPy in Python per creare un semplice sistema esperto basato sull’inferenza logica nell’ambito del diritto penale. Questo sistema aiuterà a determinare se determinati comportamenti costituiscono un reato, in base ai fatti noti e alle norme applicabili. Si noti che la libreria SymPy è stata sviluppata per consentire il calcolo simbolico in Python. In questo caso useremo le funzionalità di calcolo simbolico per la rappresentazione della conoscenza, usando le funzionalità di calcolo logico, e per l’inferenza logica.\n \n(click-ando su questo pulsante aprirete il quaderno all’interno di COLAB di Google dove potrete eseguire il quaderno online senza bisogno di avere un ambiente Python sulla vostra macchina.)\n\n3.1.5.1 Introduzione\nIl diritto penale si basa su norme che definiscono quali comportamenti sono considerati reati e quali elementi devono essere presenti affinché un’azione sia punibile. Un sistema esperto in questo contesto può aiutare a:\n\nValutare se un’azione specifica costituisce un reato.\nIdentificare gli elementi costitutivi del reato.\nFornire una base logica per decisioni legali.\n\nUtilizzeremo SymPy per modellare proposizioni logiche, regole legali e per effettuare inferenze.\n\n\n\n3.1.5.2 Installazione di SymPy\nAssicurati di avere SymPy installato:\npip install sympy\nSe stai utilizzando questo notebook in un ambiente in cui SymPy non è installato, esegui la seguente cella:\n\n!pip install sympy\n\n\n\n3.1.5.3 Concetti di Base nel Diritto Penale\nPrima di iniziare, definiamo alcuni concetti chiave:\n\nFatti: Eventi o azioni specifiche accadute.\nReati: Comportamenti definiti come illeciti dalla legge penale.\nElementi Costitutivi del Reato: Condizioni che devono essere soddisfatte perché un comportamento sia considerato un reato (ad esempio, azione, intenzione, nesso causale).\nRegole Legali: Norme che stabiliscono le condizioni in cui un comportamento è punibile.\n\n\n\n\n3.1.5.4 Modellazione con SymPy\nPasso 1: Importare i Moduli Necessari\nImportiamo i moduli necessari da SymPy per lavorare con la logica proposizionale.\n\nfrom sympy import symbols\nfrom sympy.logic.boolalg import And, Or, Not, Implies, Equivalent\nfrom sympy.logic.inference import satisfiable\n\nPasso 2: Definire le Proposizioni Logiche\nDefiniamo le variabili che rappresentano i fatti e gli elementi costitutivi del reato.\n\n# Fatti\nAzione, Intenzione, NessoCausale = symbols('Azione Intenzione NessoCausale')\n\n# Reato\nOmicidio = symbols('Omicidio')\n\nPasso 3: Definire le Regole che discendono dal Codice Penale\nAd esempio, secondo il codice penale, l’omicidio richiede:\n\nAzione: Causare la morte di una persona.\nIntenzione: Volontà di causare la morte (dolo).\nNesso Causale: La morte è conseguenza dell’azione.\n\nDefiniamo la regola:\n\n# Regola: Se c'è Azione, Intenzione e Nesso Causale, allora si configura l'Omicidio\nregola_omicidio = Implies(And(Azione, Intenzione, NessoCausale), Omicidio)\n\nPasso 4: Definire i Fatti Noti\nSupponiamo di avere i seguenti fatti:\n\nUna persona ha compiuto un’azione che ha causato la morte di un’altra.\nAveva l’intenzione di causare la morte.\nEsiste un nesso causale tra l’azione e la morte.\n\n\n# Fatti noti\nfatto1 = Azione  # L'azione di causare la morte\nfatto2 = Intenzione  # Intenzione di causare la morte\nfatto3 = NessoCausale  # La morte è conseguenza dell'azione\n\nPasso 5: Creare la Base di Conoscenza\nCombiniamo fatti e regole:\n\n# Base di conoscenza\nbase_conoscenza = And(fatto1, fatto2, fatto3, regola_omicidio)\n\nPasso 6: Inferenza Logica\nVerifichiamo se, sulla base dei fatti e delle regole, possiamo concludere che si tratta di omicidio.\n\n# Verifichiamo se Omicidio è deducibile\nipotesi = And(base_conoscenza, Not(Omicidio))\nrisultato = satisfiable(ipotesi)\n\nif not risultato:\n    print(\"Si configura il reato di omicidio.\")\nelse:\n    print(\"Non possiamo concludere che si tratti di omicidio.\")\n\nSi configura il reato di omicidio.\n\n\nOutput atteso:\nSi configura il reato di omicidio.\n\n\n3.1.5.5 Espansione del Sistema\nCaso con Mancanza di Intenzione\nSupponiamo che l’intenzione non sia presente (ad esempio, si tratta di omicidio colposo).\n\n# Fatti noti senza Intenzione\nfatto1 = Azione\nfatto2 = Not(Intenzione)  # Mancanza di intenzione\nfatto3 = NessoCausale\n\n# Base di conoscenza aggiornata\nbase_conoscenza = And(fatto1, fatto2, fatto3, regola_omicidio)\n\nInferenza per Omicidio\n\n# Inferenza\nipotesi = And(base_conoscenza, Not(Omicidio))\nrisultato = satisfiable(ipotesi)\n\nif not risultato:\n    print(\"Si configura il reato di omicidio.\")\nelse:\n    print(\"Non possiamo concludere che si tratti di omicidio.\")\n\nNon possiamo concludere che si tratti di omicidio.\n\n\nOutput atteso:\nNon possiamo concludere che si tratti di omicidio.\n\n3.1.5.5.1 Aggiunta di Altre Regole\nAggiungiamo la regola per l’omicidio colposo:\n\n# Definizione del reato di Omicidio Colposo\nOmicidioColposo = symbols('OmicidioColposo')\n\n# Regola per Omicidio Colposo: Azione e Nesso Causale senza Intenzione\nregola_omicidio_colposo = Implies(And(Azione, Not(Intenzione), NessoCausale), OmicidioColposo)\n\n# Aggiorniamo la base di conoscenza\nbase_conoscenza = And(fatto1, fatto2, fatto3, regola_omicidio, regola_omicidio_colposo)\n\nInferenza per Omicidio Colposo\n\n# Verifichiamo se si configura l'Omicidio Colposo\nipotesi = And(base_conoscenza, Not(OmicidioColposo))\nrisultato = satisfiable(ipotesi)\n\nif not risultato:\n    print(\"Si configura il reato di omicidio colposo.\")\nelse:\n    print(\"Non possiamo concludere che si tratti di omicidio colposo.\")\n\nSi configura il reato di omicidio colposo.\n\n\nOutput atteso:\nSi configura il reato di omicidio colposo.\n\n\n\n3.1.5.6 Conclusione\nAbbiamo visto come utilizzare SymPy per modellare un semplice sistema esperto nel campo del diritto penale. Questo esempio illustra come le regole legali e i fatti possono essere formalizzati utilizzando la logica proposizionale, permettendo al sistema di effettuare inferenze logiche.\nRicorda che questo è un modello semplificato e che il diritto penale è complesso e richiede una comprensione approfondita per essere modellato accuratamente. Questo sistema può essere un punto di partenza per sviluppi più avanzati e per esplorare l’intersezione tra intelligenza artificiale e diritto.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algoritmi</span>"
    ]
  },
  {
    "objectID": "2 algoritmi.html#inferenza-probabilistica",
    "href": "2 algoritmi.html#inferenza-probabilistica",
    "title": "3  Algoritmi",
    "section": "3.2 Inferenza Probabilistica",
    "text": "3.2 Inferenza Probabilistica\nL’inferenza probabilistica utilizza la teoria delle probabilità per fare previsioni o inferenze basate su dati incompleti o incerti. Questo tipo di inferenza è particolarmente utile in tutti i contesti dove le informazioni possono essere incomplete o incerte.\nL’agente artificiale in situazioni di incertezza affronta la sfida di prendere decisioni razionali quando non si dispone di informazioni complete o quando le informazioni disponibili sono soggette a variabilità. In tali contesti, l’agente deve essere in grado di gestire e interpretare l’incertezza in modo efficace per agire in modo intelligente e adattivo.\nL’incertezza può derivare da diversi fattori, come la natura incompleta delle informazioni, la presenza di rumore nei dati, l’aleatorietà degli eventi o la complessità dei problemi da affrontare. Gli agenti artificiali, dotati di capacità di ragionamento probabilistico e di inferenza, sono in grado di valutare le conseguenze di diverse azioni in base alle probabilità associate agli eventi futuri e agli esiti attesi.\nL’inferenza probabilistica è una tecnica utilizzata nell’ambito dell’Intelligenza Artificiale per prendere decisioni o formulare previsioni basate su informazioni incerte o parziali. In pratica, ciò significa che invece di avere risposte binarie (vero o falso), lavoriamo con probabilità, cioè con il grado di certezza o incertezza riguardo a una determinata affermazione o evento.\nEsempio in un contesto legale\nImmagina un caso giuridico in cui una persona è accusata di un crimine. Nel sistema giuridico, la giuria deve prendere una decisione sulla colpevolezza o innocenza dell’imputato. Tuttavia, spesso non abbiamo prove definitive o testimonianze che garantiscono una certezza assoluta. In questo contesto, l’inferenza probabilistica può essere applicata. Invece di dire semplicemente “colpevole” o “innocente,” i giurati possono assegnare una probabilità alla colpevolezza dell’imputato. Ad esempio, potrebbero dire che ci sono il 70% di probabilità che l’imputato sia colpevole e il 30% di probabilità che sia innocente. Infine, una soglia sulla probabilità di colpevolezza potrebbe dare origine alla sentenza.\nEsempio in un generico contesto di diagnosi\nNel caso di una diagnosi ( in qualunque settore) è necessario prendere una decisione con conoscenza incerta. Si è in una situazione di incertezza in quanto la lista di situazioni e cause da descrivere non può essere esaustiva (praticamente infinita per la mancanza di conoscenza universale). Non si può usare la logica del primo ordine per gestire la diagnosi perché: - è impossibile elencare l’insieme praticamente infinito di antecedenti e conseguenti per evitare eccezioni - è impossibile avere una conoscenza metodologica completa - è impossibile avere una conoscenza applicativa completa - L’agente non potrà mai agire con una piena consapevolezza di verità e correttezza, avrà solo un grado di credenza sulla bontà delle azioni da intraprendere e dei risultati.\n\n3.2.1 Inferenza probabilistica e La teoria delle probabilità\nCosa è l’ inferenza probabilistica? È un processo di ragionamento che utilizza le probabilità per prendere decisioni o formulare previsioni in situazioni in cui le informazioni sono incomplete o incerte. L’inferenza probabilistica è fondamentale in vari campi, come la statistica, l’apprendimento automatico, la medicina, la finanza e molti altri. L’inferenza probabilistica è basata sulla teoria delle probabilità, che ci consente di quantificare la probabilità di eventi futuri o incerti. Utilizzando le probabilità, possiamo prendere decisioni informate e prevedere risultati basati sui dati disponibili.\nIl calcolo delle probabilità è una branca della matematica che si occupa di misurare e analizzare la probabilità di eventi casuali. La probabilità è una misura numerica che descrive la possibilità che un evento specifico accada.\n\n“Il concetto di probabilità è il più importante della scienza moderna, soprattutto perché nessuno ha la più pallida idea del suo significato.” (Bertrand Russel)\n\nLa teoria della probabilità assume la stessa assunzione ontologica della logica: - i fatti del mondo sono: veri o falsi (con una certa probabilità) - Ogni possibile situazione in cui si trova il nostro agente è un mondo µ; Esempio: nel caso del gioco del Lotto, per la singola estrazione ci possono essere 90 mondi, uno per ogni numero che può essere estratto. - Ogni mondo µ è un insieme di fatti: - fatti veri (V) - fatti falsi (F) - fatti incerti (I)\nTale teoria può essere formulata in diversi modi a seconda del tipo di assunzioni iniziali che si utilizzano. In questo testo si utilizza la teoria della probabilità basata sui cosiddetti assiomi di Kolmogorov e per questo detta Teoria Assiomatica della Probabilità.\nGli assiomi di Kolmogorov costituiscono la base matematica della teoria delle probabilità, formulata dal matematico russo Andrey Kolmogorov nel suo lavoro “Grundbegriffe der Wahrscheinlichkeitsrechnung” nel 1933.\nEcco una descrizione dei tre assiomi di Kolmogorov:\n\nPrimo Assioma (Non-negatività):  La probabilità di un evento è sempre un numero reale non negativo: P(A)≥0 per ogni evento A. Per rappresentare la probabilità di un certo mondo si usa il simbolo P(µ), 0 &lt;= P(µ) &lt;= 1\n\nP(µ) = 0 significa che il mondo µ non ha nessuna possibilità di verificarsi. Ad esempio la probabilità che al lotto venga estratto il numero 0 (zero)\nP(µ) = 1 significa che il mondo µ è certo. Ad esempio la probabilità che il risultato di una estrazione sia minore o uguale a 90 è 1 Più è «grande» P(µ) è più è verosimile che si verifichi il mondo µ.\n\nSecondo Assioma (Normalizzazione):  La somma delle probabilità di tutti gli eventi possibili nello spazio campione è uguale a 1: P(S) = 1, dove S rappresenta lo spazio campione. Ad esempio, la somma delle probabilità di estrazione di tutti i numeri del lotto è pari a 1\nTerzo Assioma (Additività):  Se A1, A2, A3, … sono eventi mutuamente esclusivi (cioè non possono accadere simultaneamente), allora la probabilità dell’unione di questi eventi è uguale alla somma delle loro probabilità individuarie: P(A1 ∪ A2 ∪ A3 ∪ …) = P(A1) + P(A2) + P(A3) + … Ad esempio, la probabilità di estrarre un numero pari al lotto è pari alla somma delle probabilità di estrarre i numeri pari da 2 a 90. ​\n\nGli assiomi di Kolmogorov forniscono un fondamento rigoroso per definire le probabilità e garantiscono che le probabilità siano consistenti e soddisfino le proprietà chiave della teoria delle probabilità. Questi assiomi sono essenziali per lo studio formale della probabilità e vengono utilizzati per sviluppare e applicare concetti probabilistici in varie discipline, inclusi statistica, teoria dei giochi, intelligenza artificiale e molti altri campi scientifici.\n\n3.2.1.1 Cacolo della probabilità incondizionata o a priori\ncalcolo della probabilità di estrazione di un numero x al lotto Usando i tre assiomi di Kolmogorov :\nsi può calcolare la probabilità di estrazione di un numero x al lotto. - Dal primo assionmato si ha che P(x) &gt;= 0. - Dal secondo assioma si ha che la somma di tutti i P(x), con x che va da 1 a 90, è pari a 1. - Dal terzo si evince che essendo le probabilità di estrazione di un numero x uguale a quella di estrarre un numero y, con x diverso da y, si ha che la probabilità di estrarre un numero x è pari a 1/90.\ncalcolo della probabilità del risultato x nel lancio di un dado Nel lancio di un dado a 6 facce:\nla probabilità P(n) di ottenere il numero n è P(n) = 1/6 perché all’esito del lancio tutte le facce del dado hanno uguale probabilità.\ncalcolo della probabilità del risultato nel lancio di due dadi : Nell’esito del lancio di due dadi, dobbiamo considerare che i mondi possibili ed equiprobabili sono 6x6=36 e quindi la probabilità di uno di questi mondi è 1/36.\ncalcolo della probabilità del risultato x come somma dei valori nel lancio di due dadi : Nell’esito del lancio di due dadi, se vogliamo calcolare la probabilità che esca un certo valore x come somma dei valori dei due dadi dobbaimo considerare che i valori possibili di x [2,12] non sono equiprobabili. Infatti, per esempio, la probabilità di ottenere 2 è 1/36, mentre la probabilità di ottenere 7 è 6/36. Per calcolare la probabilità del valore x è sufficiente contare quanti sono i mondi in cui il valore x si ottiene come somma dei valori dei due dadi e poi dividere per il numero totale di mondi possibili. I possibili risultati del lancio di due dadi sono 36 :\n\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n2\n3\n4\n5\n6\n7\n8\n\n\n3\n4\n5\n6\n7\n8\n9\n\n\n4\n5\n6\n7\n8\n9\n10\n\n\n5\n6\n7\n8\n9\n10\n11\n\n\n6\n7\n8\n9\n10\n11\n12\n\n\n\nLa probabilità di ottenere 2 è data dal numero di esiti favorevoli al risultato 2, in questo caso è solo uno, diviso il numero totale di esiti possibili, in questo caso 36. La possibilità di ottenere 3 è data dal numero di esiti favorevoli al risultato 3, in questo caso sono 2, diviso il numero totale di esiti possibili, in questo caso 36. … P(2)=1/36, P(3)=2/36, P(4)=3/36, P(5)=4/36, P(6)=5/36, P(7)=6/36, P(8)=5/36, P(9)=4/36, P(10)=3/36, P(11)=2/36, P(12)=1/36\n\n\n3.2.1.2 Variabili aleatorie\nUna variabile aleatoria nel calcolo delle probabilità è una variabile che può assumere uno dei possibili valori in un certo dominio: - La variabile lancio nel lancio di un dado può assumere uno dei valori nel dominio {1,2,3,4,5,6} - La variabile sentenza nel processo penale può assumere uno dei valori nel dominio {«Non luogo a procedere», «Proscioglimento», «Condanna»} - La variabile diagnosi in campo medico può assumere uno dei valori nel dominio {«Malattia», «Non malattia»}.\nNell’inferenza probsbilistica si è interessati alla probabilità che una certa variabile aleatoria assuma un certo valore. Ad esempio, in un determinato processo penale si potrebbe avere:\n\nP(sentenza = «Non luogo a procedere») = 0,1\nP(sentenza = «Proscioglimento») = 0,1\nP(sentenza = «Condanna») = 0,8\n\nO, in breve, rappresentando l’insieme dei possibili risultati come un vettore: P(sentenza) = {0.1, 0.1, 0.8}\nPer codificare la variabile aleatoria “sentenza” in Python, si può utilizzare ad esempio la struttura dati dizionario che mappa i possibili esiti (“Non luogo a procedere”, “Proscioglimento”, “Condanna”) ai rispettivi valori numerici di probabilità. Ecco un esempio di come si potrebbe codificare la variabile aleatoria “sentenza” in Python utilizzando un dizionario:\n\n# Definizione della variabile aleatoria sentenza con i suoi possibili valori\nsentenza = {\n    \"Non luogo a procedere\": 0.128, # probabilità del 12.8% di non luogo a procedere\n    \"Proscioglimento\": 0.548,       # probabilità del 54.8% di proscioglimento\n    \"Condanna\": 0.324               # probabilità del 32.4% di condanna\n}\nsomma = 0\nfor esito, probabilita in sentenza.items():\n    print(f\"La probabilità di '{esito}' è: {probabilita}\")\n    somma = somma + probabilita\nprint(\" la somma delle probabilità è pari a \", somma)\n\nLa probabilità di 'Non luogo a procedere' è: 0.128\nLa probabilità di 'Proscioglimento' è: 0.548\nLa probabilità di 'Condanna' è: 0.324\n la somma delle probabilità è pari a  1.0\n\n\n\n\n3.2.1.3 Distribuzioni di probabilità\nle distribuzioni di probabilità sono funzioni che descrivono la probabilità di ogni possibile valore di una variabile aleatoria. Ad esempio, la distribuzione di probabilità della variabile aleatoria “sentenza” nel processo penale può essere rappresentata come segue: P(sentenza) = {0.1, 0.1, 0.8}. Nel seguito vedremo alcune distribuzioni di probabilità notevoli.\n\n\n3.2.1.4 Probabilità congiunta\nLa probabilità congiunta è la probabilità che due eventi si verifichino contemporaneamente. Ad esempio, la probabilità che un processo penale porti a una condanna e che il condannato sia colpevole è data dalla probabilità congiunta di questi due eventi. Oppure, in ambito medico, la probabilità che un paziente abbia una certa patologia e che il test diagnostico sia positivo è data dalla probabilità congiunta di questi due eventi. Oppure, in ambito metereologico, la probabilità che sia nuvolo e che piova è la probabilità congiunta di questi due eventi:\n\n\n\nRight\nLeft\nDefault\nCenter\n\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\nprobabilità che sia nuvoloso:\n\n\n\n\nnuvoloso\n¬nuvoloso\n\n\n\n\nP(n)\n0,7\n0,3\n\n\n\nprobabilità che piova:\n\n\n\n\npiove\n¬piove\n\n\n\n\nP(p)\n0,2\n0,8\n\n\n\nprobabilità che sia nuvoloso e piova: | P(p,n) | nuvoloso | ¬nuvoloso | | :-: | :-: | :-: | | piove | 0,55 | 0,05 | | ¬piove | 0,15 | 0,25 |\n3.2.1.5 Indipendenza delle variabili aleatorie L’indipendenza di due eventi indica che il verificarsi di uno non influenza il verificarsi dell’altro. Ad esempio: Lancio di due dadi. Il lancio del primo non influenza il secondo; Il contrario, la dipendenza, indica che il verificarsi di uno influenza il verificarsi dell’altro. Nel caso in cui due variabili aleatorie siano indipendenti si ha la seguente proprietà:\nP(a “∧” b)=P(a)*P(b)\n3.2.1.6 Negazione La negazione di un evento è l’evento che si verifica quando l’evento originale non si verifica. Ad esempio, la negazione dell’evento “piove” è “non piove”.\nimage.png Se la probabilità che un evento è α, la probabilità che l’evento non si verifichi è 1 - α.\nP(A) = α, allora P(¬A) = 1 - α\n3.2.1.7 Inclusione P(a ∨ b) = P(a) + P(b) - P(a ∧ b).\nLa probabilità che si verifichi l’evento a o l’evento b è uguale alla somma delle probabilità dei due eventi meno la probabilità congiunta. Si noti che se gli eventi sono incompatibili la probabilità congiunta è nulla! image-2.png\n3.2.1.8 Marginalizzazione La marginalizzazione è una tecnica utilizzata per calcolare la probabilità di un evento dato un insieme di eventi. Ad esempio, la probabilità che un processo penale porti a una condanna dato che il condannato è colpevole è data dalla marginalizzazione della probabilità congiunta di questi due eventi.\nP(a) = P(a, b) + P(a, ¬b).\nLa probabilità che si verifichi b è disgiunta dalla probabilità che si verifichi ¬b. Quindi, quando si verifica a si ha b oppure ¬b ma non entrambi quindi se sommo le probabilità P(a, b) + P(a, ¬b) ottengo P(a)\n3.2.1.9 probabilità condizionata La probabilità condizionata è la probabilità che un evento si verifichi dato che un altro evento si è verificato. Ad esempio, la probabilità che un processo penale porti a una condanna dato che il sottoposto a giudizio è colpevole è data dalla probabilità condizionata di questi due eventi.\nE’ possibile fare inferenze a proposito della probabilità di una proposizione ignota A, data la prova B, calcolando P(A/B) (probabilità di A dato che tutto ciò che sappiamo è B) (inferenza probabilistica)\nUn’interrogazione ad un sistema di ragionamento probabilistico chiederà di calcolare il valore di una particolare probabilità condizionata.\nFin qui abbiamo visto casi in cui il singolo evento non era condizionato da altro evento: - Prima estrazione del lotto; - Lancio di uno o due dati Cosa succede alla probabilità quando l’avverarsi di una proposizione è condizionata all’avverarsi di un’altra proposizione?\nP(a|b) = probabilità dell’evento a dato che noi sappiamo che l’evento b si è verificato. Oppure, “ la probabilità di a dato b” Possiamo chiederci: - Qual’è la probabilità che vinca la “ Roma” se ha vinto la “ Lazio”?, P(Roma/Lazio). - Qual’è la probabilità che arrivi il “38” se è arrivato il “52”?”, P(“38”/”52”). La formula per calcolare la probabilità condizionata di a dato b è la seguente:\nP(a/b) =(𝑃(𝑎 “∧” 𝑏) )/(𝑃(𝑏)); “siamo interessati agli eventi dove a e b sono vere, ma solo nei mondi dove b è vera!” P(a “∧” b)=P(b)P(a/b) P(a “∧” b)=P(b)P(a/b)\nEsercizio 1:Qual è la probabilità che ottenga una somma pari 9 lanciando due dadi se il primo dado è 6, P(9/6)? La risposta si ottiene direttamente dalla for,mula della probabilità condizionata e da quella della probabilità congiunta: p(9/6) = P(9 ∧ 6) / P(6) = 1/36 / 1/6 = 1/6 La proposizione a = «somma=9» si verifica con i seguenti lanci:\na = {(6,3),(5,4),(4,5),(3,6)}  P(a) = 4/36\nLa proposizione b = «primo dado=6» si verifica con i seguenti lanci:\nb = {(6,1),(6,2),(6,3),(6,4),(6,5),(6,6)}  P(b) = 6/36\na “∧” b = {(6,3)}  P(a “∧” b) = 1/36\nP(a/b) =(𝑃(𝑎 “∧” 𝑏) )/(𝑃(𝑏))= (1/36)/(6/36)=1/6\n\n1 2 3 4 5 6 1 2 3 4 5 6 7 2 3 4 5 6 7 8 3 4 5 6 7 8 9 4 5 6 7 8 9 10 5 6 7 8 9 10 11 6 7 8 9 10 11 12 Ovvero, per risolvere l’esercizio dobbiamo osservare l’ ultima riga della tabella realtiva al lancio del primo dado con risultato 6. i casi favorevoli sono solo 1, mentre i casi possibili sono 6. Quindi la probabilità è 1/6.\n\n3.2.1.10 Condizionamento P(a) = P(a | b)P(b) + P(a | ¬b)P(¬b).\nIl condizionamento discende immediatamente dalla marginalizzazione. La probabilità che si verifichi a è data dalla marginalizzazione della probabilità congiunta di questi due eventi. La probabilità che si verifichi b è disgiunta dalla probabilità che si verifichi ¬b. Quindi, quando si verifica a si ha b oppure ¬b ma non entrambi quindi se sommo le probabilità P(a, b) + P(a, ¬b) ottengo P(a).\nEcco due esempi di applicazioni della formula di condizionamento in Python, uno nel campo medico e uno nel campo giuridico penale:\nCampo medico Supponiamo di avere le seguenti informazioni:\nLa probabilità che una persona sviluppi un certo effetto collaterale a seguito di un farmaco è P(Effetto collaterale) = 0.2. Si sa che se una persona sviluppa l’effetto collaterale, la probabilità che abbia assunto il farmaco è P(Farmaco|Effetto collaterale) = 0.9. D’altra parte, se una persona non mostra l’effetto collaterale, la probabilità che abbia comunque assunto il farmaco è P(Farmaco|¬Effetto collaterale) = 0.1. In questo caso, il condizionamento riguarda la probabilità di assunzione del farmaco date le informazioni sull’effetto collaterale senza coinvolgere il teorema di Bayes.\nQuindi, la probabilità di assunzione del farmaco è P(Farmaco) = P(Farmaco|Effetto collaterale)P(Effetto collaterale) + P(Farmaco|¬Effetto collaterale)P(¬Effetto collaterale). la codifica in Python è la seguente:\n#definizioni delle probaibilità P_effetto_collaterale = 0.2 P_farmaco_effetto_collaterale = 0.9 P_farmaco_non_effetto_collaterale = 0.1 P_farmaco = P_farmaco_effetto_collaterale * P_effetto_collaterale + P_farmaco_non_effetto_collaterale * (1 - P_effetto_collaterale) print(f”La probabilità che una pesona abbia assunto il farmaco è : {P_farmaco}“) La probabilità che una pesona abbia assunto il farmaco è : 0.26 Campo Giuridico Penale:\nImmaginiamo di avere le seguenti informazioni in un contesto giuridico penale:\nP(Condanna con prove schiaccianti) = 0.95 P(Condanna senza prove schiaccianti) = 0.2 P(Prove schiaccianti) = 0.3 Utilizziamo la formula di condizionamento per calcolare la probabilità di condanna: P(Condanna)=P(Condanna con prove schiaccianti)P(Prove schiaccianti)+P(Condanna senza prove schiaccianti)(1-P(Prove schiaccianti)) La codifica in Python è la seguente:\nprob_condanna_prove_schiaccianti = 0.95 prob_condanna_no_prove_schiaccianti = 0.2 prob_prove_schiaccianti = 0.3 prob_condanna = prob_condanna_prove_schiaccianti * prob_prove_schiaccianti + prob_condanna_no_prove_schiaccianti * (1 - prob_prove_schiaccianti) print(f”La probabilità che un imputato sia colpevole dato che ci sono prove schiaccianti è: {prob_condanna} La probabilità che un imputato sia colpevole dato che ci sono prove schiaccianti è: 0.42499999999999993 Questi due esempi illustrano come la formula di condizionamento possa essere applicata in contesti medici e giuridici penali per calcolare probabilità condizionate basate su informazioni specifiche relative agli eventi considerati.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algoritmi</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Laboratorio di Intelligenza Artificiale",
    "section": "",
    "text": "Prefazione\nBozza del testo Labopratorio di Intelligenza Artificiale",
    "crumbs": [
      "Prefazione"
    ]
  }
]