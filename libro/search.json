[
  {
    "objectID": "0 introduzione.html",
    "href": "0 introduzione.html",
    "title": "1  Introduzione",
    "section": "",
    "text": "Touring vs Searle: Un’Analisi del Pensiero Computazionale e della Coscienza\nAlan Turing e John Searle sono due figure chiave nella filosofia della mente e nello studio dell’AI. Sebbene entrambi abbiano contribuito significativamente al campo, le loro teorie e approcci si differenziano notevolmente. Turing, con il suo famoso “Test di Turing”, si concentrava sulla capacità delle macchine di simulare il comportamento umano, mentre Searle, con il suo “Argomento della Stanza Cinese”, sfidava la nozione che una macchina potesse effettivamente comprendere o essere cosciente. In questo capitolo esploreremo le differenze fondamentali tra i due, analizzando le loro posizioni sul pensiero computazionale e la coscienza.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#touring-vs-searle-unanalisi-del-pensiero-computazionale-e-della-coscienza",
    "href": "0 introduzione.html#touring-vs-searle-unanalisi-del-pensiero-computazionale-e-della-coscienza",
    "title": "1  Introduzione",
    "section": "",
    "text": "Alan Turing e il Test di Turing\n\n\n\nimmagine generata da DALL-E del Test di Touring\n\n\nAlan Turing, matematico britannico e pioniere dell’informatica, è noto per aver proposto quello che oggi è conosciuto come il “Test di Turing” nel suo articolo del 1950 “Computing Machinery and Intelligence”. L’idea di base del test è semplice: una macchina può essere considerata “intelligente” se un essere umano, interagendo con essa attraverso una tastiera e uno schermo, non riesce a distinguere tra le risposte della macchina e quelle di un altro essere umano. Il test non richiede che la macchina pensi o capisca nel senso umano del termine, ma solo che simuli il comportamento umano in modo convincente.\nPer Turing, la domanda “Le macchine possono pensare?” è mal posta. Egli suggerisce che dovremmo piuttosto chiedere se le macchine possano esibire comportamenti che noi interpretiamo come pensiero. L’enfasi, quindi, è sulla simulazione dell’intelligenza piuttosto che sull’esperienza cosciente.\n\n\nJohn Searle e l’Argomento della Stanza Cinese\n\n\n\nimmagine generata da DALL-E della stanza cinese di Searle\n\n\nJohn Searle, filosofo statunitense, ha formulato nel 1980 l’ormai famoso “Argomento della Stanza Cinese” come risposta critica al Test di Turing e alle nozioni di “intelligenza artificiale forte”. Searle distingue tra intelligenza artificiale “debole”, che descrive sistemi che simulano l’intelligenza, e intelligenza artificiale “forte”, che sostiene che una macchina può avere una mente, una coscienza e una comprensione reale del mondo.\nNel suo esperimento mentale, Searle immagina una persona che non conosce il cinese chiusa in una stanza con una serie di istruzioni per manipolare simboli cinesi (input) e fornire risposte (output) in modo che chi osserva dall’esterno creda che la persona capisca il cinese. Tuttavia, sostiene Searle, la persona non comprende affatto il cinese; sta semplicemente seguendo delle regole per manipolare simboli. L’argomento di Searle dimostra che una macchina potrebbe eseguire compiti simili a quelli di una mente cosciente, ma senza effettivamente comprendere il significato di ciò che sta facendo.\n\n\nSimulazione vs. Comprensione\nLa differenza principale tra Turing e Searle risiede nel modo in cui concepiscono l’intelligenza e la coscienza. Per Turing, l’intelligenza è essenzialmente una questione di comportamento osservabile: se una macchina può agire in modo che un osservatore la confonda con un essere umano, allora quella macchina è, in un certo senso, “intelligente”. Non importa se la macchina capisce realmente o meno ciò che sta facendo; ciò che conta è che sembri farlo.\nSearle, d’altra parte, sostiene che il comportamento esterno non è sufficiente per definire l’intelligenza o la comprensione. Anche se una macchina può sembrare intelligente, essa manca di una qualità essenziale: la comprensione interna o la coscienza. Secondo Searle, seguire delle regole o manipolare simboli non equivale a comprendere il significato di quei simboli. L’intelligenza artificiale “forte”, quindi, sarebbe un’illusione: le macchine possono simulare l’intelligenza, ma non possono mai possedere una coscienza o una vera comprensione.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#prospettive-sul-futuro-dellintelligenza-artificiale",
    "href": "0 introduzione.html#prospettive-sul-futuro-dellintelligenza-artificiale",
    "title": "1  Introduzione",
    "section": "Prospettive sul Futuro dell’Intelligenza Artificiale",
    "text": "Prospettive sul Futuro dell’Intelligenza Artificiale\nIl dibattito tra Turing e Searle ha implicazioni profonde per il futuro dell’intelligenza artificiale e per la filosofia della mente. Le visioni di Turing hanno alimentato lo sviluppo di AI sempre più sofisticate, capaci di eseguire compiti complessi come la traduzione automatica, il riconoscimento delle immagini e la diagnosi medica. Tuttavia, gli argomenti di Searle ci ricordano che anche le macchine più avanzate potrebbero non “capire” veramente cosa stanno facendo, sollevando interrogativi su cosa significhi davvero “pensare” e se la coscienza possa mai emergere da un sistema puramente computazionale.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#alan-turing-pioniere-dellinformatica",
    "href": "0 introduzione.html#alan-turing-pioniere-dellinformatica",
    "title": "1  Introduzione",
    "section": "Alan Turing: Pioniere dell’Informatica",
    "text": "Alan Turing: Pioniere dell’Informatica\nBiografia\nAlan Mathison Turing nacque il 23 giugno 1912 a Londra, Regno Unito. Fu un matematico, logico e crittografo britannico, riconosciuto come uno dei fondatori dell’informatica moderna. Durante la Seconda Guerra Mondiale, lavorò presso Bletchley Park, il centro di crittoanalisi britannico, dove contribuì in modo decisivo alla decrittazione del codice Enigma, utilizzato dalle forze tedesche. Questo lavoro ha accelerato la fine del conflitto, salvando probabilmente milioni di vite.\nTuring morì tragicamente l’8 giugno 1954 a Wilmslow, Regno Unito, in circostanze sospette, che furono ufficialmente dichiarate come suicidio. La sua morte sollevò interrogativi sulla discriminazione di cui fu vittima a causa della sua omosessualità, che all’epoca era illegale nel Regno Unito.\nContributi e Onorificenze\nTuring è celebre per il Modello di Turing, un concetto teorico che ha gettato le basi per i computer programmabili. Nel suo celebre articolo del 1936, “On Computable Numbers”, Turing introdusse la nozione di “Macchina di Turing”, una macchina teorica che potesse eseguire calcoli seguendo una serie di istruzioni codificate. Questo concetto ha fondato la teoria dell’informatica.\nOltre ai suoi contributi nel campo della logica e della computazione, il suo Test di Turing (1950) è un punto di riferimento nello studio dell’intelligenza artificiale. Il test pone la questione se una macchina possa essere considerata intelligente se non è possibile distinguerla da un essere umano durante una conversazione.\nRiconoscimenti Postumi\nNonostante la sua vita sia stata segnata da ingiustizie legali, Turing ha ricevuto numerosi riconoscimenti postumi. Nel 2009, il governo britannico, sotto il primo ministro Gordon Brown, emise scuse ufficiali per il trattamento che Turing aveva subito. Nel 2013, la Regina Elisabetta II concesse a Turing la grazia reale postuma. In suo onore, la Medaglia Turing, istituita nel 1966 dall’Association for Computing Machinery (ACM), è uno dei premi più prestigiosi nel campo dell’informatica.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#john-searle-filosofia-della-mente-e-coscienza",
    "href": "0 introduzione.html#john-searle-filosofia-della-mente-e-coscienza",
    "title": "1  Introduzione",
    "section": "John Searle: Filosofia della Mente e Coscienza",
    "text": "John Searle: Filosofia della Mente e Coscienza\nBiografia\nJohn Rogers Searle nacque il 31 luglio 1932 a Denver, Colorado, Stati Uniti. Filosofo contemporaneo di grande rilievo, Searle si è concentrato principalmente su questioni relative alla filosofia del linguaggio, alla coscienza e alla filosofia della mente. Ha conseguito il dottorato presso l’Università di Oxford, e ha insegnato per la maggior parte della sua carriera accademica all’Università della California, Berkeley.\nSearle ha scritto numerosi testi fondamentali, e il suo pensiero si è sviluppato all’interno della tradizione della filosofia analitica. Oltre al suo celebre “Argomento della Stanza Cinese”, ha sviluppato una teoria della coscienza basata sul realismo biologico, sostenendo che la coscienza sia un fenomeno biologico emergente dai processi del cervello.\nContributi Filosofici e Opere Chiave\nSearle è conosciuto soprattutto per il suo contributo alla filosofia del linguaggio e alla filosofia della mente. Nei primi anni della sua carriera, ha lavorato sulla teoria degli atti linguistici, che esamina come il linguaggio sia utilizzato per eseguire azioni, ad esempio promettere, ordinare o chiedere.\nTuttavia, la sua opera più conosciuta è senza dubbio il suo “Argomento della Stanza Cinese”, pubblicato per la prima volta nel 1980. In questo esperimento mentale, Searle sostiene che, sebbene una macchina possa eseguire compiti che simulano la comprensione del linguaggio, essa non possiede una comprensione reale dei significati o delle intenzioni dietro le parole. Questo argomento critica l’idea dell’intelligenza artificiale forte, che sostiene che le macchine possano pensare o essere coscienti come gli esseri umani.\nOnorificenze e Premi\nSearle ha ricevuto numerosi riconoscimenti durante la sua carriera accademica. Nel 2004, ha ricevuto il National Humanities Medal dal presidente degli Stati Uniti George W. Bush per il suo contributo alla filosofia. Nel 2006 è stato premiato con il Premio Mind and Brain per i suoi studi innovativi sulla mente e la coscienza.\nOltre a questi premi, Searle è membro di diverse accademie internazionali, inclusa l’American Academy of Arts and Sciences, e ha ricevuto numerose lauree honoris causa da università di tutto il mondo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "0 introduzione.html#conclusione",
    "href": "0 introduzione.html#conclusione",
    "title": "1  Introduzione",
    "section": "Conclusione",
    "text": "Conclusione\nIn sintesi, mentre Turing e Searle condividono un interesse comune per la natura dell’intelligenza e della mente, le loro posizioni sono radicalmente diverse. Turing vede l’intelligenza come qualcosa che può essere simulato attraverso il comportamento, mentre Searle insiste che senza comprensione interna, ciò che viene prodotto è una mera simulazione priva di coscienza. Questo dibattito continua a influenzare il campo dell’intelligenza artificiale, sfidando filosofi, scienziati e ingegneri a esplorare cosa significhi davvero essere intelligenti e consapevoli. Si noti che il test di Touring è anche all’origine dell’onnipresente “CAPTCHA” (Completely Automated Public Turing test to tell Computers and Humans Apart) che è una forma di test di Turing inverso utilizzato per distinguere gli esseri umani dai bot nei contesti online.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html",
    "href": "1 elementi di Python.html",
    "title": "2  Elementi di Python",
    "section": "",
    "text": "2.1 Sintassi e Concetti di Base\nLa sintassi di Python è progettata per essere intuitiva e di facile lettura. Un programma Python è costituito da linee di codice che vengono eseguite sequenzialmente. Ogni linea di codice esprime una singola operazione o istruzione. Esploriamo alcuni concetti di base attraverso esempi pratici nel contesto della giurisprudenza:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html#sintassi-e-concetti-di-base",
    "href": "1 elementi di Python.html#sintassi-e-concetti-di-base",
    "title": "2  Elementi di Python",
    "section": "",
    "text": "2.1.1 Assegnazione di Variabili**\nIn Python, l’assegnazione di un valore a una variabile è semplice e diretta:\n** Assegnazione di variabili **\nfascicolo = \"2024/12345\"\nnomeGiudice = \"Giudice Rossi\"\ncasoChiuso = False\nIn questo esempio, abbiamo assegnato una stringa (\"2024/12345\") a fascicolo, una stringa (\"Giudice Rossi\") a nomeGiudice, e un valore booleano (False) a casoChiuso, indicando che il caso non è ancora chiuso.\n\n\n2.1.2 Operazioni Aritmetiche\nPython supporta tutte le principali operazioni aritmetiche; possiamo applicarle anche a contesti legali, come il calcolo delle pene o delle ammende.\nCalcolo di una sanzione basata sui giorni di ritardo\ngiorniRitardo = 10\nsanzioneGiornaliera = 50\n\nsanzioneTotale = giorniRitardo * sanzioneGiornaliera  # Sanzione totale: 500€\nprint(f\"La sanzione totale è di {sanzioneTotale} euro.\")\nOutput:\nLa sanzione totale è di 500 euro.\n\n\n2.1.3 Controllo del Flusso (Condizioni e Cicli)\n\n2.1.3.1 Lo Statement if\nLo statement if in Python è una struttura di controllo che consente di eseguire blocchi di codice condizionatamente, in base al risultato di una condizione booleana (vero o falso). La sintassi di base è la seguente:\nif condizione:\n    # codice da eseguire se la condizione è vera\nComponenti dello statement if\n\nCondizione: È un’espressione che restituisce un valore booleano. Se la condizione è vera (True), il blocco di codice indentato successivo verrà eseguito.\nBlocco di Codice: Il codice all’interno del blocco deve essere indentato. L’indentazione è fondamentale in Python e indica quali istruzioni appartengono al blocco if.\n\nEsempio di Base\nx = 10\n\nif x &gt; 5:\n    print(\"x è maggiore di 5\")\nOutput:\nx è maggiore di 5\nIn questo esempio, poiché x è effettivamente maggiore di 5, verrà stampato “x è maggiore di 5”.\nVarianti dello Statement if\n\nif-else: Consente di eseguire un blocco di codice alternativo se la condizione è falsa.\nif x &gt; 5:\n    print(\"x è maggiore di 5\")\nelse:\n    print(\"x non è maggiore di 5\")\nOutput: x è maggiore di 5\nif-elif-else: Permette di controllare più condizioni in sequenza.\nif x &gt; 10:\n    print(\"x è maggiore di 10\")\nelif x &gt; 5:\n    print(\"x è maggiore di 5 ma minore o uguale a 10\")\nelse:\n    print(\"x è minore o uguale a 5\")\nOutput: x è maggiore di 5 ma minore o uguale a 10\n\nOperatori di Confronto\nPuoi usare vari operatori di confronto all’interno delle condizioni, tra cui:\n\n==: uguale\n!=: diverso\n&gt;: maggiore\n&lt;: minore\n&gt;=: maggiore o uguale\n&lt;=: minore o uguale\n\nEsempi di Condizioni Complesse\nPuoi anche combinare condizioni usando gli operatori logici:\n\nand: restituisce True se entrambe le condizioni sono vere.\nor: restituisce True se almeno una delle condizioni è vera.\nnot: inverte il valore della condizione.\n\nif x &gt; 5 and x &lt; 15:\n    print(\"x è compreso tra 5 e 15\")\nOutput:\nx è compreso tra 5 e 15\nIn sintesi, lo statement if è una delle basi della logica di programmazione in Python, permettendo di prendere decisioni e controllare il flusso del programma. Python utilizza l’indentazione per definire blocchi di codice, rendendo il codice pulito e leggibile.\n\n\n2.1.3.2 I cicli\nfor\n# Iterare su una lista di testimoni\nwitnesses = [\"Testimone A\", \"Testimone B\", \"Testimone C\"]\n\nfor witness in witnesses:\n    print(f\"Interrogare {witness}\")\nOutput:\nInterrogare Testimone A\nInterrogare Testimone B\nInterrogare Testimone C\nwhile\n# Ciclo while per contare all'indietro da 5 a 1\nn = 5\nwhile n &gt; 0:\n    print(n)\n    n -= 1\nOutput:\n5\n4\n3\n2\n1\n\n\n\n2.1.4 Gestione delle Eccezioni\nPython permette di gestire gli errori e le eccezioni in modo elegante usando i blocchi try e except.\ntry:\n    # Tentativo di apertura di un file di sentenze\n    with open(\"sentenze.txt\", \"r\") as file:\n        content = file.read()\nexcept FileNotFoundError:\n    print(\"Errore: Il file delle sentenze non è stato trovato.\")\nOutput:\nErrore: Il file delle sentenze non è stato trovato.\nl’ istruzione try ammette anche una estensione chiamata finally che viene eseguita alla fine della try per garantire la consistenza delle operazioni svolte nel blocco try. Ad esempio, il precedente blocco try potrebbe avere una finally per chiudere il file alla fine del blocco:\ntry:\n    f = open('data.txt', 'r')\n    contenuto = f.read()\nexcept FileNotFoundError:\n    print(\"Errore: Il file delle sentenze non è stato trovato.\")\nfinally:\n    f.close()  # Il blocco finally garantisce che il file venga chiuso\nOutput:\nErrore: Il file delle sentenze non è stato trovato.\n\n\n2.1.5 Stampe a Video\nLa funzione print in Python è utilizzata per stampare messaggi a video, rendendo facile il debug e la visualizzazione dei risultati.\n# Stampa di informazioni su un caso legale\nfascicolo = \"2024/12345\"\nnomeGiudice = \"Mario Rossi\"\ncasoChiuso = False\n\nprint(f\"Numero del caso: {fascicolo}\")\nprint(f\"Nome del giudice: {nomeGiudice}\")\nprint(f\"Il caso è chiuso? {'Sì' if casoChiuso else 'No'}\")\nOutput:\nNumero del caso: 2024/12345\nNome del giudice: Mario Rossi\nIl caso è chiuso? No\n\n\n2.1.6 Lettura e Scrittura di File\nPython fornisce metodi semplici per leggere e scrivere file, essenziali per la gestione dei dati legali.\nScrittura di un file testuale\n# Scrittura di una sentenza in un file\nsentenza = \"Il caso è chiuso. La sentenza è di 5 anni di reclusione.\"\nwith open(\"sentenza.txt\", \"w\") as file:\n    file.write(sentenza)\nLettura di un file\n\n# Lettura di una sentenza da un file\ntry:\n    with open(\"sentenza.txt\", \"r\") as file:\n        content = file.read()\n        print(\"Contenuto del file:\")\n        print(content)\nexcept FileNotFoundError:\n    print(\"Errore: Il file delle sentenze non è stato trovato.\")\nOutput:\nContenuto del file:\nIl caso è chiuso. La sentenza è di 5 anni di reclusione.\nIn questo paragrafo, abbiamo esplorato alcuni dei concetti di base della sintassi di Python, inclusi l’assegnazione di variabili, le operazioni aritmetiche, le condizioni, i cicli, le funzioni, la gestione delle eccezioni, le stampe a video e la lettura e scrittura di file, applicandoli a contesti giuridici. Questi concetti costituiscono la base della programmazione in Python e ti preparano per affrontare problemi più complessi nei capitoli successivi.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html#strutture-dati",
    "href": "1 elementi di Python.html#strutture-dati",
    "title": "2  Elementi di Python",
    "section": "2.2 Strutture Dati",
    "text": "2.2 Strutture Dati\nLe strutture dati sono elementi fondamentali per qualsiasi linguaggio di programmazione, e Python offre una serie di strutture dati integrate che rendono la gestione dei dati semplice ed efficiente. Esploriamo alcune delle strutture dati principali e le loro funzionalità attraverso esempi pratici nel contesto della giurisprudenza.\n\n2.2.1 Liste\nLe liste sono collezioni ordinate di elementi che possono essere modificati. Possono contenere elementi di qualsiasi tipo, inclusi numeri, stringhe e altre liste.\n# Creare una lista di leggi applicabili\nleggi = [\"Art. 1 - Reati contro la persona\", \"Art. 2 - Reati contro il patrimonio\"]\n\n# Aggiungere una nuova legge\nleggi.append(\"Art. 3 - Reati contro l'ambiente\")\n\n# Rimuovere una legge\nleggi.remove(\"Art. 2 - Reati contro il patrimonio\")\n\n# Accedere a una legge\nprint(leggi[1])  # Stampa: \"Art. 3 - Reati contro l'ambiente\"\nprint(\"................................\")\n# Iterare su una lista di leggi\nfor legge in leggi:\n    print(legge)\nOutput:\nArt. 3 - Reati contro l'ambiente\n................................\nArt. 1 - Reati contro la persona\nArt. 3 - Reati contro l'ambiente\n\n\n2.2.2 Dizionari\nI dizionari sono collezioni di coppie chiave-valore che permettono un accesso rapido ai dati. Le chiavi devono essere uniche e immutabili.\n# Creare un dizionario per un caso legale\nfascicolo = {\"numero\": \"2024/12345\", \"giudice\": \"Giudice Rossi\", \"stato\": \"aperto\"}\n\n# Aggiungere o aggiornare un elemento\nfascicolo[\"stato\"] = \"chiuso\"\n\n# Rimuovere un elemento\ndel fascicolo[\"giudice\"]\n\n# Accedere a un valore\nprint(fascicolo[\"numero\"])  # Stampa: \"2024/12345\"\n\n# Iterare su un dizionario\nfor chiave, valore in fascicolo.items():\n    print(f\"{chiave}: {valore}\")\nOutput:\n2024/12345\nnumero: 2024/12345\nstato: chiuso\n\n\n2.2.3 Set o insiemi\nI set sono collezioni di elementi unici, utili per operazioni matematiche insiemistiche come l’unione e l’intersezione.\n# Creare un set di articoli violati\narticoliViolati = {\"Art. 1\", \"Art. 3\"}\n\n# Aggiungere un articolo violato\narticoliViolati.add(\"Art. 5\")\n\n# Rimuovere un articolo violato\narticoliViolati.remove(\"Art. 1\")\n\n# Operazioni sui set\narticoliAggiuntivi = {\"Art. 2\", \"Art. 4\", \"Art. 5\"}\nrisultatoUnione = articoliViolati.union(articoliAggiuntivi)  # Unione\nrisultatoIntersezione = articoliViolati.intersection(articoliAggiuntivi)  # Intersezione\n\nprint(risultatoUnione)  # Stampa: {'Art. 2', 'Art. 3', 'Art. 4', 'Art. 5'}\nprint(risultatoIntersezione)  # Stampa: {'Art. 5'}\nOutput:\n{'Art. 4', 'Art. 3', 'Art. 5', 'Art. 2'}\n{'Art. 5'}\n\n\n2.2.4 Set o insiemi\nI set sono collezioni di elementi unici, utili per operazioni matematiche insiemistiche come l’unione e l’intersezione.\n# Creare un set di articoli violati\narticoliViolati = {\"Art. 1\", \"Art. 3\"}\n\n# Aggiungere un articolo violato\narticoliViolati.add(\"Art. 5\")\n\n# Rimuovere un articolo violato\narticoliViolati.remove(\"Art. 1\")\n\n# Operazioni sui set\narticoliAggiuntivi = {\"Art. 2\", \"Art. 4\", \"Art. 5\"}\nrisultatoUnione = articoliViolati.union(articoliAggiuntivi)  # Unione\nrisultatoIntersezione = articoliViolati.intersection(articoliAggiuntivi)  # Intersezione\n\nprint(risultatoUnione)  # Stampa: {'Art. 2', 'Art. 3', 'Art. 4', 'Art. 5'}\nprint(risultatoIntersezione)  # Stampa: {'Art. 5'}\nOutput:\n{'Art. 4', 'Art. 3', 'Art. 5', 'Art. 2'}\n{'Art. 5'}\n\n\n2.2.5 Tuple\nLe tuple sono simili alle liste ma sono immutabili. Una volta create, non possono essere modificate. L’immutabilità delle tuple offre diversi vantaggi, tra cui la sicurezza dei dati e l’ottimizzazione delle prestazioni. Quando un dato non deve essere modificato, l’utilizzo delle tuple assicura che il dato rimanga costante durante l’esecuzione del programma, riducendo il rischio di errori accidentali. Inoltre, le tuple possono essere utilizzate come chiavi nei dizionari, poiché sono immutabili.\n# Creare una tupla per le coordinate di un luogo del crimine\ncoordinateScenaCrimine = (45.4642, 9.1900)\n\n# Accedere a un elemento\nprint(coordinateScenaCrimine[0])  # Stampa: 45.4642\nOutput:\n45.4642\n# Le tuple non possono essere modificate\ncoordinateScenaCrimine[0] = 45.5000  # Questo genererà un errore\nOutput:\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-6-b4ce3edf64a6&gt; in &lt;cell line: 2&gt;()\n      1 # Le tuple non possono essere modificate\n----&gt; 2 coordinateScenaCrimine[0] = 45.5000  # Questo genererà un errore\n\nTypeError: 'tuple' object does not support item assignment",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html#funzioni-e-moduli",
    "href": "1 elementi di Python.html#funzioni-e-moduli",
    "title": "2  Elementi di Python",
    "section": "2.3 Funzioni e Moduli",
    "text": "2.3 Funzioni e Moduli\n\n2.3.1 Definire e usare le funzioni\nLe funzioni permettono di organizzare il codice in blocchi riutilizzabili, mentre i moduli permettono di suddividere il codice in file separati che possono essere importati e utilizzati in altri programmi. Sia le funzioni che i moduli consentono di organizzare il codice sviluppato in blocchi omogeni facilitando il riuso e lo scambio di codice sorgente. Ad esempio, se abbiamo scritto un blocco di codice che riolve un problema applicativo come il calcolo degli anni di detenzione per un determinato reato possiamo inserire questo blocco di istruzioni python in una funzione dal nome calcoloDurataPena. Mentre, se abbiamo definito un certo numero di funzioni utili nell’ambito penalistico possiamo definire un modulo denominato calcolipenale.py e importarlo ogniqualvolta ne abbiamo bisogno\n\n# Funzione per calcolare la durata di una pena basata sulla gravità del crimine\ndef calcoloDurataPena(crime_severity):\n    if crime_severity == \"grave\":\n        return 10\n    elif crime_severity == \"moderato\":\n        return 5\n    else:\n        return 1\n\nanni = calcoloDurataPena(\"grave\")\nprint(f\"La durata della pena è di {anni} anni.\")\nOutput:\nLa durata della pena è di 10 anni.\n\n\n2.3.2 Creare e importare moduli personalizzati\nÈ possibile creare moduli personalizzati per organizzare meglio il codice. Ad esempio, se si desidera separare le funzioni di calcolo in ambito penalistico in un modulo separato:\nCreare un modulo (calcolipenale.py)\n# calcolipenale.py\ndef calcoloDurataPena(crime_severity):\n    if crime_severity == \"grave\":\n        return 10\n    elif crime_severity == \"moderato\":\n        return 5\n    else:\n        return 1\n\ndef calcolaSanzione(sanzioneBase, giorniRitardo, mora=50):\n    return sanzioneBase + giorniRitardo * mora\nImportare e usare il modulo python\n# script_principale.py\nimport calcolipenale\n\nanni = calcolipenale.calcoloDurataPena(\"grave\")\nsanzione = calcolipenale.calcolaSanzione(550,10,10)\n\nprint(f\"La durata della pena è di 10 anni.\")\nprint(f\"La multa totale è di 650 euro.\")\nOutput:\nLa durata della pena è di {anni} anni.\nLa multa totale è di {sanzione} euro.\n\n\n2.3.3 Importare moduli\nLa possibilità di creare e importare moduli di codice è una caratteristica di molti linguaggi di programmazione che consente:\n\nRiutilizzo del Codice: L’importazione dei moduli consente di riutilizzare il codice esistente, evitando la duplicazione e rendendo più facile la manutenzione del software.\nOrganizzazione: I moduli permettono di organizzare il codice in file separati, facilitando la comprensione e la navigazione nel progetto.\nAstrazione: Utilizzando moduli, si possono nascondere dettagli complessi dietro interfacce più semplici, migliorando la leggibilità e la chiarezza del codice.\nEcosistema Ricco: Python ha un vasto ecosistema di moduli e librerie che coprono un’ampia gamma di funzionalità, dal trattamento dei dati al web development, permettendo agli sviluppatori di concentrarsi su ciò che è importante per il loro progetto.\n\nIn particolare, in Python in ambito IA i moduli consentono di:\n\nLibrerie Specializzate: l’importazione di moduli come NumPy, Pandas, TensorFlow e PyTorch è essenziale per operazioni matematiche complesse, manipolazione dei dati e costruzione di modelli di machine learning.\nFacilità di Sperimentazione: Le librerie consentono di sperimentare rapidamente con algoritmi di IA senza dover scrivere tutto da zero, accelerando il processo di sviluppo e ricerca.\nSupporto per il Calcolo Distribuito: Alcuni moduli permettono di sfruttare il calcolo distribuito, fondamentale per addestrare modelli di IA su grandi quantità di dati.\nStandardizzazione: Utilizzando librerie consolidate, i ricercatori e gli sviluppatori possono garantire che le loro implementazioni siano compatibili con gli standard del settore, facilitando la condivisione e la riproducibilità dei risultati.\n\nIn sintesi, l’importazione di moduli in Python è cruciale per lo sviluppo efficace e efficiente, specialmente nell’ambito dell’intelligenza artificiale, dove la complessità e la varietà degli strumenti richiesti sono elevate.\n# esempio di importazione di una libreria standard\nimport math\n\n# Calcolare la distanza tra due punti (coordinate di due luoghi del crimine)\ndef calculate_distance(coord1, coord2):\n    return math.sqrt((coord2[0] - coord1[0])**2 + (coord2[1] - coord1[1])**2)\n\ndistance = calculate_distance((45.4642, 9.1900), (45.5000, 9.2100))\nprint(f\"La distanza tra i due luoghi del crimine è di {distance} unità.\")\nOutput:\nLa distanza tra i due luoghi del crimine è di 0.04100780413531289 unità.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "1 elementi di Python.html#gli-oggetti",
    "href": "1 elementi di Python.html#gli-oggetti",
    "title": "2  Elementi di Python",
    "section": "2.4 Gli oggetti",
    "text": "2.4 Gli oggetti\nIn Python, gli oggetti sono entità fondamentali che rappresentano sia i dati che le funzioni. Ogni cosa in Python è un oggetto, inclusi numeri, stringhe, liste, funzioni e persino le stesse classi. Gli oggetti hanno proprietà, chiamate attributi, e comportamenti, definiti dai metodi. Gli oggetti possono essere utilizzati per modellare situazioni reali, come il trattamento di fascicoli giuridici, dove un oggetto può rappresentare un singolo caso legale, contenente informazioni sul giudice, le parti coinvolte e lo stato del procedimento. La programmazione orientata agli oggetti (OOP) consente di organizzare il codice in modo più modulare e riutilizzabile, facilitando la gestione di progetti complessi e favorendo la collaborazione tra sviluppatori. Nei prossimi esempi, vedremo come creare e gestire oggetti in Python, e come questi possano essere applicati a contesti giuridici concreti.\n\n2.4.1 Creazione di una classe\nUna classe è un modello per creare oggetti. Può essere paragonata a una struttura o un modello da cui vengono creati singoli oggetti.\nclass Fascicolo:\n    def __init__(self, numero, giudice, chiuso):\n        self.numero = numero          # Attributo che contiene il numero del fascicolo\n        self.giudice = giudice        # Attributo che contiene il nome del giudice\n        self.chiuso = chiuso          # Attributo che indica se il fascicolo è chiuso (True o False)\nIn questo esempio, la classe Fascicolo ha tre attributi: numero, giudice e chiuso. Questi vengono definiti quando viene creato un nuovo oggetto della classe.\n\n\n2.4.2 Creazione di un oggetto\nPer creare un oggetto da una classe, si usa la classe come una funzione. Gli oggetti creati da una classe sono chiamati istanze della classe.\n# Creiamo un nuovo fascicolo\nfascicolo_1 = Fascicolo(\"2024/12345\", \"Giudice Rossi\", False)\n\n# Accesso agli attributi dell'oggetto\nprint(f\"Numero del fascicolo: {fascicolo_1.numero}\")\nprint(f\"Giudice: {fascicolo_1.giudice}\")\nprint(f\"Il fascicolo è chiuso? {fascicolo_1.chiuso}\")\nOutput:\nNumero del fascicolo: 2024/12345\nGiudice: Giudice Rossi\nIl fascicolo è chiuso? False\nQui abbiamo creato un oggetto fascicolo_1 con i valori specificati. Abbiamo poi stampato i valori dei suoi attributi.\n\n\n2.4.3 Aggiunta di un metodo alla classe\nI metodi sono funzioni definite all’interno di una classe e possono operare sugli attributi dell’oggetto.\nclass Fascicolo:\n    def __init__(self, numero, giudice, chiuso):\n        self.numero = numero\n        self.giudice = giudice\n        self.chiuso = chiuso\n\n    # Metodo per chiudere il fascicolo\n    def chiudi_fascicolo(self):\n        self.chiuso = True\n        print(f\"Il fascicolo {self.numero} è stato chiuso.\")\n\n# Creiamo un altro fascicolo\nfascicolo_2 = Fascicolo(\"2024/67890\", \"Giudice Bianchi\", False)\n\n# Chiudiamo il fascicolo\nfascicolo_2.chiudi_fascicolo()\nOutput:\nIl fascicolo 2024/67890 è stato chiuso.\nIn questo esempio, abbiamo aggiunto un metodo chiamato chiudi_fascicolo che modifica l’attributo chiuso di un fascicolo e stampa un messaggio.\n\n\n2.4.4 Utilizzo di più oggetti\nPossiamo creare più istanze della classe Fascicolo per rappresentare diversi fascicoli.\nfascicolo_3 = Fascicolo(\"2024/54321\", \"Giudice Verdi\", False)\nfascicolo_4 = Fascicolo(\"2024/98765\", \"Giudice Neri\", True)\n\nprint(f\"Fascicolo 3 - Giudice: {fascicolo_3.giudice}, Chiuso: {fascicolo_3.chiuso}\")\nprint(f\"Fascicolo 4 - Giudice: {fascicolo_4.giudice}, Chiuso: {fascicolo_4.chiuso}\")\nOutput:\nFascicolo 3 - Giudice: Giudice Verdi, Chiuso: False\nFascicolo 4 - Giudice: Giudice Neri, Chiuso: True\n\n\n2.4.5 Ereditarietà tra classi\nL’ereditarietà consente di creare una nuova classe che eredita attributi e metodi da un’altra classe. Vediamo come creare una classe FascicoloPenale che eredita dalla classe Fascicolo.\nclass FascicoloPenale(Fascicolo):\n    def __init__(self, numero, giudice, chiuso, reato):\n        super().__init__(numero, giudice, chiuso)  # Chiamata al costruttore della classe genitore\n        self.reato = reato  # Attributo specifico del fascicolo penale\n\n# Creiamo un fascicolo penale\nfascicolo_penale = FascicoloPenale(\"2024/11111\", \"Giudice Gialli\", False, \"Frode\")\n\nprint(f\"Fascicolo Penale - Numero: {fascicolo_penale.numero}, Reato: {fascicolo_penale.reato}\")\nOutput:\nFascicolo Penale - Numero: 2024/11111, Reato: Frode\nIn questo caso, FascicoloPenale eredita attributi e metodi dalla classe Fascicolo e aggiunge un nuovo attributo chiamato reato.\nGli oggetti in Python offrono una grande flessibilità nel modellare e organizzare il codice. Con la programmazione orientata agli oggetti, puoi creare classi che rappresentano concetti del mondo reale, semplificando la gestione di dati complessi. Con l’uso di attributi, metodi e ereditarietà, diventa possibile creare programmi modulari e riutilizzabili per affrontare problemi sempre più complessi.\nIn questo capitolo, abbiamo esplorato le principali strutture dati di Python, tra cui liste, dizionari, set e tuple, e le funzionalità principali come le funzioni e i moduli, applicandole a contesti giuridici. Queste strutture dati e funzionalità sono fondamentali per scrivere programmi efficienti e ben organizzati e saranno essenziali per affrontare i compiti di intelligenza artificiale nei capitoli successivi.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Elementi di Python</span>"
    ]
  },
  {
    "objectID": "2 algoritmi.html",
    "href": "2 algoritmi.html",
    "title": "3  Algoritmi",
    "section": "",
    "text": "3.1 Inferenza Logica\nL’inferenza logica è un processo fondamentale nel campo della logica, della matematica e della filosofia, utilizzato per derivare conclusioni a partire da premesse o informazioni date. Questo processo può essere visto come un mezzo per scoprire nuove verità o per confermare la validità di affermazioni esistenti. L’inferenza logica si suddivide principalmente in due categorie: deduttiva e induttiva.\nL’inferenza deduttiva è quella in cui la conclusione deriva necessariamente dalle premesse; se le premesse sono vere, la conclusione non può che essere vera. Un classico esempio di inferenza deduttiva è il sillogismo: “Tutti gli uomini sono mortali; Socrate è un uomo; quindi, Socrate è mortale.” In questo caso, la verità delle premesse garantisce la verità della conclusione.\nL’inferenza induttiva, invece, opera diversamente: partendo da osservazioni specifiche o da una serie di dati, arriva a conclusioni più generali, che non sono necessariamente certe ma probabili. Ad esempio, se si osserva che il sole è sorto ogni giorno, si potrebbe inferire che il sole sorgerà anche domani. Questa forma di inferenza è molto utilizzata nella scienza, dove gli scienziati formulano ipotesi basate su dati osservati e sperimentali.\nUn altro tipo di inferenza logica è l’abduzione, che implica la formazione della migliore spiegazione possibile data un insieme di osservazioni. Questo tipo di inferenza è spesso utilizzato nella diagnosi medica, nella ricerca scientifica e nelle indagini criminali, dove si cerca di spiegare i dati osservati nel modo più coerente possibile.\nL’inferenza logica è strettamente legata al concetto di validità e di correttezza degli argomenti. Un’argomentazione è valida se la sua struttura logica è tale che, qualora le premesse siano vere, anche la conclusione deve essere vera. Tuttavia, un’argomentazione può essere valida senza essere corretta; per essere corretta, deve avere anche premesse vere. Ad esempio, l’argomentazione “Tutti gli unicorni sono verdi; io possiedo un unicorno; quindi, il mio unicorno è verde” è valida dal punto di vista logico, ma non è corretta perché le premesse non sono vere.\nL’inferenza logica è alla base di molti sistemi di intelligenza artificiale e di calcolo automatico, dove gli algoritmi vengono progettati per inferire nuove informazioni a partire da dati iniziali. Nei sistemi esperti, per esempio, vengono utilizzate regole di inferenza per simulare il processo decisionale umano. In conclusione, l’inferenza logica è uno strumento potente e versatile che permea molte aree del pensiero umano e della tecnologia, consentendo di avanzare nella conoscenza e nella comprensione del mondo che ci circonda. L’inferenza logica è una tecnica fondamentale dell’intelligenza artificiale che utilizza le regole logiche per derivare nuove informazioni da quelle esistenti. Nella giurisprudenza, l’inferenza logica può essere utilizzata per analizzare le leggi e determinare le conseguenze logiche delle azioni legali.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algoritmi</span>"
    ]
  },
  {
    "objectID": "2 algoritmi.html#inferenza-logica",
    "href": "2 algoritmi.html#inferenza-logica",
    "title": "3  Algoritmi",
    "section": "",
    "text": "definizione Treccani: inferenza logica sinonimo di «argomentazione logica» utilizzato per designare il processo di deduzione di una formula A, detta conclusione, a partire da una o più formule, dette premesse. Secondo A. De Morgan, una inferenza è la «produzione di una proposizione come conseguenza necessaria di una o più proposizioni».\n\n\n\n\n\n\n\n\nI sistemi esperti - Negli anni ’80, l’inferenza logica è stata fondamentale nello sviluppo dei sistemi esperti, strumenti avanzati di intelligenza artificiale progettati per risolvere problemi complessi emulando il ragionamento umano. Due noti prodotti commerciali di quel periodo sono stati MYCIN, un sistema esperto per la diagnosi di infezioni del sangue, e XCON, utilizzato per configurare sistemi di computer VAX di Digital Equipment Corporation. MYCIN e XCON sfruttavano regole di inferenza per elaborare informazioni e fornire raccomandazioni o soluzioni, dimostrando l’efficacia dell’inferenza logica in applicazioni pratiche e commerciali &gt; - “Rule-based Expert Systems : The MYCIN Experiments of the Stanford Heuristic Programming Project”, edited by Bruce G. Buchanan, Edward H. Shortliffe (AddisonWesley, 1984) - “RI: an Expert in the Computer Systems Domain”\n\n\n3.1.1 Proposizioni Logiche\nLe proposizioni logiche sono dichiarazioni atomiche che possono essere valutate come vere o false. Le proposizioni possono essere combinate utilizzando operatori logici come AND, OR, NOT, IMPLIES, che permettono di costruire regole complesse rappresentate da formule logiche.\nEcco alcuni esempi di proposizioni logiche:\np: “Il sole è luminoso” (Vero) q: “La Luna è fatta di formaggio” (Falso) r: “Se piove, allora la strada sarà bagnata” (Condizionale)\n\n\n3.1.2 Calcolo delle Proposizioni Logiche\nLe proposizioni logiche possono essere manipolate utilizzando vari operatori logici che eseguono operazioni specifiche:\nCongiunzione (AND - ∧): L’operatore AND restituisce vero solo quando entrambe le proposizioni coinvolte sono vere. Ad esempio, se abbiamo due proposizioni p e q, p ∧ q è vero solo se entrambe p e q sono vere. La cosidetta tabella di verità riportata qui sotto consente di vedere come funziona l’operatore AD.\n\nTavola della verità per la congiunzione\n\n\np\nq\np ∧ q\n\n\n\n\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\n\n\nTrue\nTrue\nTrue\n\n\n\nDisgiunzione (OR - ∨): L’operatore OR restituisce vero se almeno una delle due proposizioni coinvolte è vera. Ad esempio, p ∨ q è vero se p è vero oppure se q è vero oppure se entrambi sono veri. La tabella di verità riportata qui sotto consente di vedere come funziona l’operatore OR.\n\nTavola della verità per la disgiunzione\n\n\np\nq\np ∨ q\n\n\n\n\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nTrue\nTrue\nTrue\n\n\n\nNegazione (NOT - ¬): L’operatore NOT cambia il valore di verità di una proposizione. Ad esempio, ¬p è vero se p è falso e viceversa.\n\nTavola della verità per la negazione\n\n\np\n¬p\n\n\n\n\nFalse\nTrue\n\n\nTrue\nFalse\n\n\n\nImplicazione (→): L’implicazione è un’operazione logica che collega due proposizioni e stabilisce una relazione di condizionalità. Si rappresenta con il simbolo “→” e si legge come “se… allora”. In un’implicazione del tipo “p → q”, la proposizione p è chiamata l’antecedente e la proposizione q è il conseguente. L’implicazione è falsa solo nel caso in cui l’antecedente è vero e il conseguente è falso. In tutti gli altri casi, l’implicazione è considerata vera. Poiché questa operazione è alla base di molti algoritmi di inferenza, è importante capire come funziona. La tabella di verità riportata qui sotto consente di vedere come funziona l’operatore implicazione.\n\nTavola della verità per l’implicazione\n\n\np\nq\np → q\n\n\n\n\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nTrue\nFalse\nFalse\n\n\nTrue\nTrue\nTrue\n\n\n\nEsempio di Implicazione: supponiamo di avere le seguenti proposizioni: - p: Il sole splende. - q: Faccio una passeggiata. - L’implicazione che possiamo formulare è: “Se il sole splende, allora faccio una passeggiata”, che si scrive come “p → q”. Dalla tabella della verità, possiamo vedere che in tre dei quattro casi l’implicazione “p → q” è vera. L’unico caso in cui l’implicazione è falsa è quando il sole splende (p è vero) ma non faccio una passeggiata (q è falso).\nQuindi, in base alla logica dell’implicazione, se il sole splende, sto effettivamente facendo una passeggiata o potrei anche non farla (ad eccezione del caso in cui il sole splenda e io non faccia una passeggiata, in cui l’implicazione è falsa).\nImplicazione Bilaterale (↔︎): L’implicazione bilaterale è un’operazione logica che stabilisce che due proposizioni sono equivalenti, cioè che entrambe le proposizioni hanno lo stesso valore di verità. Si rappresenta con il simbolo “↔︎” e si legge come “se e solo se”. L’implicazione bilaterale è vera solo quando le proposizioni hanno lo stesso valore di verità, sia entrambe vere che entrambe false.\n\nTavola della verità per l’implicazione bilaterale\n\n\np\nq\np ↔︎ q\n\n\n\n\nFalse\nFalse\nTrue\n\n\nFalse\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\n\n\nTrue\nTrue\nTrue\n\n\n\nL’implicazione bilaterale, anche conosciuta come “se e solo se”, è un importante concetto logico che stabilisce che due proposizioni sono logicamente equivalenti, cioè entrambe sono vere o entrambe sono false contemporaneamente.\nEsempio di Implicazione Bilaterale: supponiamo di avere le seguenti proposizioni:\n\np: Oggi è venerdì.\nq: Domani è sabato.\n\nL’implicazione bilaterale tra p e q può essere scritta come p ↔︎ q, che si legge come “Oggi è venerdì se e solo se domani è sabato”.\nDalla tabella di verità, possiamo notare che l’implicazione bilaterale “Oggi è venerdì se e solo se domani è sabato” è vera solo nei casi in cui entrambe le proposizioni sono vere (primo e ultimo caso) o entrambe sono false. Se c’è una discrepanza nelle verità delle proposizioni, l’implicazione bilaterale diventa falsa (secondo e terzo caso).\nQuindi, nel nostro esempio, l’affermazione “Oggi è venerdì se e solo se domani è sabato” è vera solo quando entrambe le proposizioni sono vere o entrambe sono false, evidenziando l’equivalenza logica tra le due proposizioni nel contesto dell’implicazione bilaterale.\n\n\n3.1.3 Basi della Conoscenza\nLa base della conoscenza in un agente a inferenza logica è costituita da proposizioni logiche, che sono affermazioni dichiarative che possono essere vere o false. Le proposizioni possono essere atomiche o composte e sono spesso rappresentate utilizzando variabili proposizionali. Queste variabili assumono valori di verità (vero o falso) e vengono combinate tramite operatori logici per formare regole logiche complesse. La base della conoscenza in un sistema logico definisce le relazioni tra le proposizioni e fornisce le fondamenta per il ragionamento e l’inferenza. Un agente a inferenza logica usa la Base della Conoscenza per giungere a conclusioni circa il mondo che la circonda; Per fare ciò ha bisogno di regole di implicazione logica (⊨): Se α ⊨ β, ovvero se α implica logicamente β, in ogni mondo dove α è vera allora β è vera. È diversa dall’implicazione perché non è un connettivo logico ma una relazione che dice che se α è vera allora β è vera e basta!\n\n\n3.1.4 Sistemi basati sulla conoscenza\nI sistemi basati sulla conoscenza sono strumenti informatici progettati per emulare il processo decisionale umano attraverso l’utilizzo di una base di conoscenza strutturata. Questi sistemi raccolgono, organizzano e utilizzano informazioni specifiche di un dominio per risolvere problemi complessi che richiedono competenza specialistica. Una componente fondamentale è la base di conoscenza, che contiene fatti, regole ed euristiche rappresentative del sapere umano in un determinato campo. Il motore di inferenza è l’altro elemento chiave: applica regole logiche ai dati presenti nella base di conoscenza per dedurre nuove informazioni o prendere decisioni informate.\n\n\n\nProcesso di creazione e gestione di un sistema basato sulla conoscenza\n\n\nIl processo di creazione di un sistema esperto basato sull’inferenza logica inizia con l’acquisizione della conoscenza, dove gli esperti del dominio collaborano per estrarre informazioni e regole rilevanti. Queste conoscenze vengono poi formalizzate nella rappresentazione della conoscenza, utilizzando strutture come regole if-then, ontologie o reti semantiche, che alimentano la base di conoscenza. Il motore di inferenza viene sviluppato per applicare queste regole logiche ai dati forniti, deducendo nuove informazioni o prendendo decisioni informate. La gestione del sistema include l’aggiornamento continuo della base di conoscenza per riflettere nuove scoperte o cambiamenti nel dominio, nonché la verifica e la validazione del sistema per garantirne l’accuratezza e l’affidabilità. Gli utenti interagiscono con il sistema attraverso un’interfaccia che facilita l’inserimento dei dati e la visualizzazione dei risultati, permettendo anche il feedback per miglioramenti futuri.\nQuesti sistemi trovano applicazione in vari settori, come la medicina, l’ingegneria, la finanza e l’assistenza clienti. Ad esempio, in ambito medico, un sistema basato sulla conoscenza può aiutare nella diagnosi di malattie analizzando sintomi e storie cliniche dei pazienti. L’efficacia di tali sistemi dipende dalla qualità e dall’aggiornamento costante della base di conoscenza, nonché dalla capacità del motore di inferenza di elaborare correttamente le informazioni.\nUn vantaggio significativo dei sistemi basati sulla conoscenza è la possibilità di conservare e diffondere l’esperienza di esperti, rendendola accessibile a un pubblico più ampio e contribuendo alla standardizzazione delle pratiche. Tuttavia, la creazione e la manutenzione di una base di conoscenza richiedono notevoli risorse e competenze. Con l’avanzamento dell’intelligenza artificiale e dell’apprendimento automatico, questi sistemi continuano a evolversi, integrando nuove tecniche per migliorare l’efficienza, l’accuratezza e la capacità di apprendimento autonomo nelle loro applicazioni.\n\n\n3.1.5 Semplice Sistema Esperto in ambito penale\nIn questo paragrafo, useremo la libreria SymPy in Python per creare un semplice sistema esperto basato sull’inferenza logica nell’ambito del diritto penale. Questo sistema aiuterà a determinare se determinati comportamenti costituiscono un reato, in base ai fatti noti e alle norme applicabili. Si noti che la libreria SymPy è stata sviluppata per consentire il calcolo simbolico in Python. In questo caso useremo le funzionalità di calcolo simbolico per la rappresentazione della conoscenza, usando le funzionalità di calcolo logico, e per l’inferenza logica.\n\n(click-ando su questo pulsante aprirete il quaderno all’interno di COLAB di Google dove potrete eseguire il quaderno online senza bisogno di avere un ambiente Python sulla vostra macchina.)\n\n3.1.5.1 Introduzione\nIl diritto penale si basa su norme che definiscono quali comportamenti sono considerati reati e quali elementi devono essere presenti affinché un’azione sia punibile. Un sistema esperto in questo contesto può aiutare a:\n\nValutare se un’azione specifica costituisce un reato.\nIdentificare gli elementi costitutivi del reato.\nFornire una base logica per decisioni legali.\n\nUtilizzeremo SymPy per modellare proposizioni logiche, regole legali e per effettuare inferenze.\n\n\n\n3.1.5.2 Installazione di SymPy\nAssicurati di avere SymPy installato:\npip install sympy\nSe stai utilizzando questo notebook in un ambiente in cui SymPy non è installato, esegui la seguente cella:\n\n!pip install sympy\n\n\n\n3.1.5.3 Concetti di Base nel Diritto Penale\nPrima di iniziare, definiamo alcuni concetti chiave:\n\nFatti: Eventi o azioni specifiche accadute.\nReati: Comportamenti definiti come illeciti dalla legge penale.\nElementi Costitutivi del Reato: Condizioni che devono essere soddisfatte perché un comportamento sia considerato un reato (ad esempio, azione, intenzione, nesso causale).\nRegole Legali: Norme che stabiliscono le condizioni in cui un comportamento è punibile.\n\n\n\n\n3.1.5.4 Modellazione con SymPy\nPasso 1: Importare i Moduli Necessari\nImportiamo i moduli necessari da SymPy per lavorare con la logica proposizionale.\n\nfrom sympy import symbols\nfrom sympy.logic.boolalg import And, Or, Not, Implies, Equivalent\nfrom sympy.logic.inference import satisfiable\n\nPasso 2: Definire le Proposizioni Logiche\nDefiniamo le variabili che rappresentano i fatti e gli elementi costitutivi del reato.\n\n# Fatti\nAzione, Intenzione, NessoCausale = symbols('Azione Intenzione NessoCausale')\n\n# Reato\nOmicidio = symbols('Omicidio')\n\nPasso 3: Definire le Regole che discendono dal Codice Penale\nAd esempio, secondo il codice penale, l’omicidio richiede:\n\nAzione: Causare la morte di una persona.\nIntenzione: Volontà di causare la morte (dolo).\nNesso Causale: La morte è conseguenza dell’azione.\n\nDefiniamo la regola:\n\n# Regola: Se c'è Azione, Intenzione e Nesso Causale, allora si configura l'Omicidio\nregola_omicidio = Implies(And(Azione, Intenzione, NessoCausale), Omicidio)\n\nPasso 4: Definire i Fatti Noti\nSupponiamo di avere i seguenti fatti:\n\nUna persona ha compiuto un’azione che ha causato la morte di un’altra.\nAveva l’intenzione di causare la morte.\nEsiste un nesso causale tra l’azione e la morte.\n\n\n# Fatti noti\nfatto1 = Azione  # L'azione di causare la morte\nfatto2 = Intenzione  # Intenzione di causare la morte\nfatto3 = NessoCausale  # La morte è conseguenza dell'azione\n\nPasso 5: Creare la Base di Conoscenza\nCombiniamo fatti e regole:\n\n# Base di conoscenza\nbase_conoscenza = And(fatto1, fatto2, fatto3, regola_omicidio)\n\nPasso 6: Inferenza Logica\nVerifichiamo se, sulla base dei fatti e delle regole, possiamo concludere che si tratta di omicidio.\n\n# Verifichiamo se Omicidio è deducibile\nipotesi = And(base_conoscenza, Not(Omicidio))\nrisultato = satisfiable(ipotesi)\n\nif not risultato:\n    print(\"Si configura il reato di omicidio.\")\nelse:\n    print(\"Non possiamo concludere che si tratti di omicidio.\")\n\nSi configura il reato di omicidio.\n\n\nOutput atteso:\nSi configura il reato di omicidio.\n\n\n3.1.5.5 Espansione del Sistema\nCaso con Mancanza di Intenzione\nSupponiamo che l’intenzione non sia presente (ad esempio, si tratta di omicidio colposo).\n\n# Fatti noti senza Intenzione\nfatto1 = Azione\nfatto2 = Not(Intenzione)  # Mancanza di intenzione\nfatto3 = NessoCausale\n\n# Base di conoscenza aggiornata\nbase_conoscenza = And(fatto1, fatto2, fatto3, regola_omicidio)\n\nInferenza per Omicidio\n\n# Inferenza\nipotesi = And(base_conoscenza, Not(Omicidio))\nrisultato = satisfiable(ipotesi)\n\nif not risultato:\n    print(\"Si configura il reato di omicidio.\")\nelse:\n    print(\"Non possiamo concludere che si tratti di omicidio.\")\n\nNon possiamo concludere che si tratti di omicidio.\n\n\nOutput atteso:\nNon possiamo concludere che si tratti di omicidio.\n\n3.1.5.5.1 Aggiunta di Altre Regole\nAggiungiamo la regola per l’omicidio colposo:\n\n# Definizione del reato di Omicidio Colposo\nOmicidioColposo = symbols('OmicidioColposo')\n\n# Regola per Omicidio Colposo: Azione e Nesso Causale senza Intenzione\nregola_omicidio_colposo = Implies(And(Azione, Not(Intenzione), NessoCausale), OmicidioColposo)\n\n# Aggiorniamo la base di conoscenza\nbase_conoscenza = And(fatto1, fatto2, fatto3, regola_omicidio, regola_omicidio_colposo)\n\nInferenza per Omicidio Colposo\n\n# Verifichiamo se si configura l'Omicidio Colposo\nipotesi = And(base_conoscenza, Not(OmicidioColposo))\nrisultato = satisfiable(ipotesi)\n\nif not risultato:\n    print(\"Si configura il reato di omicidio colposo.\")\nelse:\n    print(\"Non possiamo concludere che si tratti di omicidio colposo.\")\n\nSi configura il reato di omicidio colposo.\n\n\nOutput atteso:\nSi configura il reato di omicidio colposo.\n\n\n\n3.1.5.6 Conclusione\nAbbiamo visto come utilizzare SymPy per modellare un semplice sistema esperto nel campo del diritto penale. Questo esempio illustra come le regole legali e i fatti possono essere formalizzati utilizzando la logica proposizionale, permettendo al sistema di effettuare inferenze logiche.\nRicorda che questo è un modello semplificato e che il diritto penale è complesso e richiede una comprensione approfondita per essere modellato accuratamente. Questo sistema può essere un punto di partenza per sviluppi più avanzati e per esplorare l’intersezione tra intelligenza artificiale e diritto.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algoritmi</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Laboratorio di Intelligenza Artificiale",
    "section": "",
    "text": "Prefazione\nBozza del testo Labopratorio di Intelligenza Artificiale",
    "crumbs": [
      "Prefazione"
    ]
  }
]